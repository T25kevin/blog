<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://kanoc.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://kanoc.gitee.io/"/>
  <updated>2025-06-09T10:44:59.626Z</updated>
  <id>https://kanoc.gitee.io/</id>
  
  <author>
    <name>Kanoc Ge</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GoLang的websocket编程</title>
    <link href="https://kanoc.gitee.io/2025/06/08/GoLang%E7%9A%84websocket%E7%BC%96%E7%A8%8B/"/>
    <id>https://kanoc.gitee.io/2025/06/08/GoLang%E7%9A%84websocket%E7%BC%96%E7%A8%8B/</id>
    <published>2025-06-08T05:03:35.000Z</published>
    <updated>2025-06-09T10:44:59.626Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>GoLang的websocket编程</strong></font></p><span id="more"></span><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gorilla/websocket&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> upgrader = websocket.Upgrader&#123;</span><br><span class="line">CheckOrigin: <span class="function"><span class="keyword">func</span><span class="params">(r *http.Request)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;, <span class="comment">// 解决跨域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleWebSocket</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">conn, err := upgrader.Upgrade(w, r, <span class="literal">nil</span>) <span class="comment">// HTTP 升级为 WebSocket</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;升级失败:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msgType, msg, err := conn.ReadMessage() <span class="comment">// 读取消息</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;读取错误:&quot;</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(msg)</span><br><span class="line">fmt.Println(reflect.TypeOf(msg))</span><br><span class="line">fmt.Println(reflect.TypeOf(msgType))</span><br><span class="line">log.Printf(<span class="string">&quot;收到: %s&quot;</span>, msg)</span><br><span class="line"><span class="comment">// 原样返回消息（实现 Echo 服务）</span></span><br><span class="line"><span class="keyword">if</span> err := conn.WriteMessage(msgType, msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;发送错误:&quot;</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/ws&quot;</span>, handleWebSocket)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1、核心代码实现"><a href="#1、核心代码实现" class="headerlink" title="1、核心代码实现"></a>1、核心代码实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字符串转换为字节切片，明确指定为文本消息类型</span></span><br><span class="line"><span class="keyword">if</span> err := conn.WriteMessage(websocket.TextMessage, []<span class="type">byte</span>(msg)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;消息推送失败: %v&quot;</span>, err)</span><br><span class="line">    <span class="comment">// 可选：返回错误信息给调用方</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;推送失败: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// websocket.TextMessage：适用于 UTF-8 编码的字符串（如 JSON/XML）</span></span><br><span class="line"><span class="comment">// websocket.BinaryMessage：适用于二进制数据（如图片/音视频）</span></span><br><span class="line"><span class="comment">// 字符串消息必须使用 TextMessage 类型</span></span><br></pre></td></tr></table></figure><h3 id="2、错误处理优化："><a href="#2、错误处理优化：" class="headerlink" title="2、错误处理优化："></a>2、错误处理优化：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := conn.WriteMessage(websocket.TextMessage, []<span class="type">byte</span>(msg)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 识别特定错误类型</span></span><br><span class="line">    <span class="keyword">if</span> websocket.IsCloseError(err, websocket.CloseNormalClosure) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;连接已正常关闭&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录原始错误日志</span></span><br><span class="line">    log.Printf(<span class="string">&quot;WS_ERR: %v | 消息: %s&quot;</span>, err, msg) </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;服务繁忙，请重试&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区分连接关闭和发送失败场景</span></span><br><span class="line"><span class="comment">// 生产环境建议用结构化日志（如 JSON 格式）</span></span><br></pre></td></tr></table></figure><h2 id="消息推送："><a href="#消息推送：" class="headerlink" title="消息推送："></a>消息推送：</h2><h3 id="1、设置字符串返回类型"><a href="#1、设置字符串返回类型" class="headerlink" title="1、设置字符串返回类型"></a>1、设置字符串返回类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设msg是字符串类型</span></span><br><span class="line">message := <span class="string">&quot;这是要返回的字符串消息&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串转换为字节切片</span></span><br><span class="line">msgBytes := []<span class="type">byte</span>(message)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送文本消息</span></span><br><span class="line"><span class="keyword">if</span> err := conn.WriteMessage(websocket.TextMessage, msgBytes); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    log.Println(<span class="string">&quot;发送消息失败:&quot;</span>, err)</span><br><span class="line">    <span class="comment">// 可以选择断开连接或进行其他处理</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、设置JSON返回类型"><a href="#2、设置JSON返回类型" class="headerlink" title="2、设置JSON返回类型"></a>2、设置<code>JSON</code>返回类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code <span class="type">int</span>    <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">    Data <span class="type">string</span> <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendJSON</span><span class="params">(conn *websocket.Conn, msg <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    resp := Response&#123;Code: <span class="number">200</span>, Data: msg&#125;</span><br><span class="line">    jsonData, _ := json.Marshal(resp)  <span class="comment">// 序列化为 JSON</span></span><br><span class="line">    <span class="keyword">return</span> conn.WriteMessage(websocket.TextMessage, jsonData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、-广播消息实现"><a href="#3、-广播消息实现" class="headerlink" title="3、 广播消息实现"></a>3、 广播消息实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clients = <span class="built_in">make</span>(<span class="keyword">map</span>[*websocket.Conn]<span class="type">bool</span>) <span class="comment">// 全局连接池</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> client := <span class="keyword">range</span> clients &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c *websocket.Conn)</span></span> &#123; <span class="comment">// 并发发送避免阻塞</span></span><br><span class="line">            <span class="keyword">if</span> err := c.WriteMessage(websocket.TextMessage, []<span class="type">byte</span>(msg)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">delete</span>(clients, c) <span class="comment">// 移除失效连接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(client)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⚠️-关键注意事项"><a href="#⚠️-关键注意事项" class="headerlink" title="⚠️ 关键注意事项"></a>⚠️ 关键注意事项</h3><ol><li><p><strong>并发安全</strong></p><ul><li>使用 <code>sync.Mutex</code> 保护共享资源（如 <code>clients</code> 连接池）</li><li>通道传递消息避免竞态条件：</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    Conn *websocket.Conn</span><br><span class="line">    Text <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">msgChan := <span class="built_in">make</span>(<span class="keyword">chan</span> Message, <span class="number">100</span>) <span class="comment">// 缓冲队列</span></span><br></pre></td></tr></table></figure></li><li><p><strong>性能优化</strong></p><ul><li>大消息（&gt; 64KB）启用分片传输：</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn.SetWriteDeadline(time.Now().Add(<span class="number">10</span> * time.Second)) <span class="comment">// 设置超时</span></span><br><span class="line">writer, _ := conn.NextWriter(websocket.TextMessage)</span><br><span class="line">io.Copy(writer, bytes.NewReader(largeData)) <span class="comment">// 流式写入</span></span><br><span class="line">writer.Close()</span><br></pre></td></tr></table></figure><ul><li>启用压缩减少带宽：</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">upgrader := websocket.Upgrader&#123;</span><br><span class="line">    EnableCompression: <span class="literal">true</span>, <span class="comment">// 开启压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>连接生命周期</strong></p><ul><li>心跳机制维持长连接：</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> time.Tick(<span class="number">30</span> * time.Second) &#123;</span><br><span class="line">        <span class="keyword">if</span> err := conn.WriteMessage(websocket.PingMessage, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// 心跳失败终止连接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;GoLang的websocket编程&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/categories/Golang/"/>
    
    <category term="websocket" scheme="https://kanoc.gitee.io/categories/Golang/websocket/"/>
    
    
    <category term="websocket" scheme="https://kanoc.gitee.io/tags/websocket/"/>
    
    <category term="Go" scheme="https://kanoc.gitee.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu-apt安装ffmpeg最新版-ffmpeg6-or-ffmpeg7</title>
    <link href="https://kanoc.gitee.io/2025/06/04/Ubuntu-apt%E5%AE%89%E8%A3%85ffmpeg%E6%9C%80%E6%96%B0%E7%89%88-ffmpeg6-or-ffmpeg7/"/>
    <id>https://kanoc.gitee.io/2025/06/04/Ubuntu-apt%E5%AE%89%E8%A3%85ffmpeg%E6%9C%80%E6%96%B0%E7%89%88-ffmpeg6-or-ffmpeg7/</id>
    <published>2025-06-04T12:37:25.000Z</published>
    <updated>2025-06-10T01:06:07.985Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Ubuntu使用<code>apt</code>安装最新版本<code>FFmpeg</code></strong></font></p><span id="more"></span><h3 id="第一步：添加ppa源"><a href="#第一步：添加ppa源" class="headerlink" title="第一步：添加ppa源"></a>第一步：添加<code>ppa</code>源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二选一，重复使用会出现覆盖</span></span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:ubuntuhandbook1/ffmpeg7   <span class="comment"># ffmpeg7版本源</span></span><br><span class="line"><span class="comment"># sudo add-apt-repository ppa:ubuntuhandbook1/ffmpeg6   # ffmpeg6版本源</span></span><br></pre></td></tr></table></figure><h3 id="第二步：更新apt缓存"><a href="#第二步：更新apt缓存" class="headerlink" title="第二步：更新apt缓存"></a>第二步：更新<code>apt</code>缓存</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h3 id="第三步：安装ffmpeg"><a href="#第三步：安装ffmpeg" class="headerlink" title="第三步：安装ffmpeg"></a>第三步：安装<code>ffmpeg</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install ffmpeg</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 如果之前安装过 ：更新ffmpeg</span></span><br><span class="line"><span class="comment"># sudo apt upgrade ffmpeg    # 更新命令</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/06/04/kLrnaDMZRFsJQ75.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Ubuntu使用&lt;code&gt;apt&lt;/code&gt;安装最新版本&lt;code&gt;FFmpeg&lt;/code&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A5-安装教程" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
    <category term="ubuntu" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/ubuntu/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu配置安装GPU转码</title>
    <link href="https://kanoc.gitee.io/2025/05/26/Ubuntu%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85GPU%E8%BD%AC%E7%A0%81/"/>
    <id>https://kanoc.gitee.io/2025/05/26/Ubuntu%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85GPU%E8%BD%AC%E7%A0%81/</id>
    <published>2025-05-26T14:07:58.000Z</published>
    <updated>2025-06-10T01:07:50.100Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Ubuntu配置安装GPU转码</strong></font></p><span id="more"></span><h2 id="ubuntu-测试使用-GPU-ffmpeg-转码视频"><a href="#ubuntu-测试使用-GPU-ffmpeg-转码视频" class="headerlink" title="ubuntu 测试使用 GPU-ffmpeg 转码视频"></a>ubuntu 测试使用 GPU-ffmpeg 转码视频</h2><h3 id="额外命令："><a href="#额外命令：" class="headerlink" title="额外命令："></a>额外命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsb_release -a   <span class="comment"># 查看发行版本及代号</span></span><br><span class="line">lspci | grep -i vga   <span class="comment"># 查看是否存在gpu</span></span><br></pre></td></tr></table></figure><h3 id="第一步：安装ffmpeg"><a href="#第一步：安装ffmpeg" class="headerlink" title="第一步：安装ffmpeg"></a>第一步：安装ffmpeg</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install ffmpeg</span><br></pre></td></tr></table></figure><h3 id="第二步：1-安装-NVIDIA-驱动"><a href="#第二步：1-安装-NVIDIA-驱动" class="headerlink" title="第二步：1. 安装 NVIDIA 驱动"></a>第二步：<strong>1. 安装 NVIDIA 驱动</strong></h3><h4 id="1-添加官方驱动仓库并更新"><a href="#1-添加官方驱动仓库并更新" class="headerlink" title="(1) 添加官方驱动仓库并更新"></a>(1) 添加官方驱动仓库并更新</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure><h4 id="2-查看推荐驱动版本"><a href="#2-查看推荐驱动版本" class="headerlink" title="(2) 查看推荐驱动版本"></a>(2) 查看推荐驱动版本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ubuntu-drivers devices</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">== /sys/devices/pci0000:00/0000:00:02.0/0000:03:00.0 ==</span><br><span class="line">modalias : pci:v000010DEd00001C82sv000010DEsd00001C82bc03sc00i00</span><br><span class="line">vendor   : NVIDIA Corporation</span><br><span class="line">model    : GP107 [GeForce GTX 1050 Ti]</span><br><span class="line">driver   : nvidia-driver-570-server - distro non-free</span><br><span class="line">driver   : nvidia-driver-550 - distro non-free</span><br><span class="line">driver   : nvidia-driver-418-server - distro non-free</span><br><span class="line">driver   : nvidia-driver-570 - distro non-free recommended</span><br><span class="line">driver   : nvidia-driver-545 - distro non-free</span><br><span class="line">driver   : nvidia-driver-535-server - distro non-free</span><br><span class="line">driver   : nvidia-driver-535 - distro non-free</span><br><span class="line">driver   : nvidia-driver-450-server - distro non-free</span><br><span class="line">driver   : nvidia-driver-390 - distro non-free</span><br><span class="line">driver   : nvidia-driver-470 - distro non-free</span><br><span class="line">driver   : nvidia-driver-470-server - distro non-free</span><br><span class="line">driver   : xserver-xorg-video-nouveau - distro free <span class="built_in">builtin</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-安装推荐的驱动（如-570-版本）"><a href="#3-安装推荐的驱动（如-570-版本）" class="headerlink" title="(3) 安装推荐的驱动（如 570 版本）"></a>(3) 安装推荐的驱动（如 570 版本）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install nvidia-driver-570</span><br></pre></td></tr></table></figure><h4 id="4-重启系统"><a href="#4-重启系统" class="headerlink" title="(4) 重启系统"></a>(4) 重启系统</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> reboot</span><br></pre></td></tr></table></figure><h4 id="5-验证驱动"><a href="#5-验证驱动" class="headerlink" title="(5) 验证驱动"></a>(5) 验证驱动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>正常输出应显示 GPU 状态：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 535.161.07   Driver Version: 535.161.07   CUDA Version: 12.2     |</span><br><span class="line">|-----------------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|=========================================+======================+======================|</span><br><span class="line">|   0  NVIDIA GeForce GTX 1050 Ti    Off  | 00000000:03:00.0 Off |                  N/A |</span><br><span class="line">| 30%   35C    P8              N/A /  75W |      0MiB /  4096MiB |      0%      Default |</span><br><span class="line">+-----------------------------------------+----------------------+----------------------+</span><br></pre></td></tr></table></figure><hr><h3 id="第三步：-安装-CUDA-工具包（可选）"><a href="#第三步：-安装-CUDA-工具包（可选）" class="headerlink" title="第三步： 安装 CUDA 工具包（可选）"></a><strong>第三步： 安装 CUDA 工具包（可选）</strong></h3><p>如果需开发 GPU 计算应用（如 AI、深度学习），安装 CUDA：</p><h4 id="1-访问-CUDA-Toolkit-Archive-选择版本（推荐-CUDA-11-8-或-12-x）"><a href="#1-访问-CUDA-Toolkit-Archive-选择版本（推荐-CUDA-11-8-或-12-x）" class="headerlink" title="(1) 访问 CUDA Toolkit Archive 选择版本（推荐 CUDA 11.8 或 12.x）"></a>(1) 访问 <a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA Toolkit Archive</a> 选择版本（推荐 CUDA 11.8 或 12.x）</h4><h4 id="2-通过命令行安装（以-CUDA-12-2-为例）"><a href="#2-通过命令行安装（以-CUDA-12-2-为例）" class="headerlink" title="(2) 通过命令行安装（以 CUDA 12.2 为例）"></a>(2) 通过命令行安装（以 CUDA 12.2 为例）</h4><ul><li>该命令需要去英伟达官网实时生成：<a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&target_arch=x86_64&Distribution=Ubuntu&target_version=22.04&target_type=deb_local">CUDA Toolkit 12.9 Downloads | NVIDIA Developer</a></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/cuda-ubuntu2204.pin</span><br><span class="line">sudo mv cuda-ubuntu2204.pin /etc/apt/preferences.d/cuda-repository-pin-600</span><br><span class="line">wget https://developer.download.nvidia.com/compute/cuda/12.9.0/local_installers/cuda-repo-ubuntu2204-12-9-local_12.9.0-575.51.03-1_amd64.deb</span><br><span class="line">sudo dpkg -i cuda-repo-ubuntu2204-12-9-local_12.9.0-575.51.03-1_amd64.deb</span><br><span class="line">sudo cp /var/cuda-repo-ubuntu2204-12-9-local/cuda-*-keyring.gpg /usr/share/keyrings/</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install cuda-toolkit-12-9</span><br></pre></td></tr></table></figure><h4 id="3-添加变量"><a href="#3-添加变量" class="headerlink" title="(3) 添加变量"></a>(3) 添加变量</h4><p>虽然系统显示 <code>cuda-toolkit-12-9</code> 已安装，但 <code>nvcc</code> 的路径未添加到系统环境变量中。此时需要手动将 CUDA 的二进制目录加入 <code>PATH</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/local/cuda/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h4 id="4-验证-CUDA"><a href="#4-验证-CUDA" class="headerlink" title="(4) 验证 CUDA"></a>(4) 验证 CUDA</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvcc --version</span><br></pre></td></tr></table></figure><p>正常输出应显示 CUDA 版本。</p><h3 id="第四步：-验证-GPU-加速是否生效"><a href="#第四步：-验证-GPU-加速是否生效" class="headerlink" title="第四步： 验证 GPU 加速是否生效"></a><strong>第四步： 验证 GPU 加速是否生效</strong></h3><h4 id="1、检查编码器"><a href="#1、检查编码器" class="headerlink" title="1、检查编码器"></a>1、检查编码器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -encoders | grep nvenc</span><br><span class="line"><span class="comment"># 应输出包含 h264_nvenc 的行</span></span><br></pre></td></tr></table></figure><p>正常输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@R7-13:~# ffmpeg -encoders | grep nvenc</span><br><span class="line">ffmpeg version 4.4.2-0ubuntu0.22.04.1 Copyright (c) 2000-2021 the FFmpeg developers</span><br><span class="line">  built with gcc 11 (Ubuntu 11.2.0-19ubuntu1)</span><br><span class="line">  configuration: --prefix=/usr --extra-version=0ubuntu0.22.04.1 --toolchain=hardened --libdir=/usr/lib/x86_64-linux-gnu --incdir=/usr/include/x86_64-linux-gnu --<span class="built_in">arch</span>=amd64 --enable-gpl --disable-stripping --enable-gnutls --enable-ladspa --enable-libaom --enable-libass --enable-libbluray --enable-libbs2b --enable-libcaca --enable-libcdio --enable-libcodec2 --enable-libdav1d --enable-libflite --enable-libfontconfig --enable-libfreetype --enable-libfribidi --enable-libgme --enable-libgsm --enable-libjack --enable-libmp3lame --enable-libmysofa --enable-libopenjpeg --enable-libopenmpt --enable-libopus --enable-libpulse --enable-librabbitmq --enable-librubberband --enable-libshine --enable-libsnappy --enable-libsoxr --enable-libspeex --enable-libsrt --enable-libssh --enable-libtheora --enable-libtwolame --enable-libvidstab --enable-libvorbis --enable-libvpx --enable-libwebp --enable-libx265 --enable-libxml2 --enable-libxvid --enable-libzimg --enable-libzmq --enable-libzvbi --enable-lv2 --enable-omx --enable-openal --enable-opencl --enable-opengl --enable-sdl2 --enable-pocketsphinx --enable-librsvg --enable-libmfx --enable-libdc1394 --enable-libdrm --enable-libiec61883 --enable-chromaprint --enable-frei0r --enable-libx264 --enable-shared</span><br><span class="line">  libavutil      56. 70.100 / 56. 70.100</span><br><span class="line">  libavcodec     58.134.100 / 58.134.100</span><br><span class="line">  libavformat    58. 76.100 / 58. 76.100</span><br><span class="line">  libavdevice    58. 13.100 / 58. 13.100</span><br><span class="line">  libavfilter     7.110.100 /  7.110.100</span><br><span class="line">  libswscale      5.  9.100 /  5.  9.100</span><br><span class="line">  libswresample   3.  9.100 /  3.  9.100</span><br><span class="line">  libpostproc    55.  9.100 / 55.  9.100</span><br><span class="line"> V....D h264_nvenc           NVIDIA NVENC H.264 encoder (codec h264)</span><br><span class="line"> V..... nvenc                NVIDIA NVENC H.264 encoder (codec h264)</span><br><span class="line"> V..... nvenc_h264           NVIDIA NVENC H.264 encoder (codec h264)</span><br><span class="line"> V..... nvenc_hevc           NVIDIA NVENC hevc encoder (codec hevc)</span><br><span class="line"> V....D hevc_nvenc           NVIDIA NVENC hevc encoder (codec hevc)</span><br></pre></td></tr></table></figure><h4 id="2、监控-GPU-使用情况"><a href="#2、监控-GPU-使用情况" class="headerlink" title="2、监控 GPU 使用情况"></a>2、监控 GPU 使用情况</h4><h5 id="2-1、nvidia-smi-watch-组合命令"><a href="#2-1、nvidia-smi-watch-组合命令" class="headerlink" title="2.1、nvidia-smi + watch 组合命令*"></a>2.1、<code>nvidia-smi</code> + <code>watch</code> 组合命令*</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每秒刷新一次 GPU 状态，适合快速查看核心利用率、显存占用和温度</span></span><br><span class="line">watch -n 1 nvidia-smi  <span class="comment"># Linux/macOS</span></span><br></pre></td></tr></table></figure><p>windows 方案：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="variable">$true</span>) &#123; nvidia-smi; Start-Sleep -Milliseconds 500 &#125;</span><br></pre></td></tr></table></figure><h5 id="2-2、nvtop（类-htop-工具）"><a href="#2-2、nvtop（类-htop-工具）" class="headerlink" title="2.2、nvtop（类 htop 工具）"></a>2.2、<strong><code>nvtop</code>（类 htop 工具）</strong></h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 支持交互式操作和动态排序，适合多 GPU 服务器</span></span><br><span class="line"><span class="built_in">sudo</span> apt install nvtop  <span class="comment"># Ubuntu/Debian</span></span><br><span class="line">nvtop</span><br></pre></td></tr></table></figure><h2 id="第四步：使用GPU转码"><a href="#第四步：使用GPU转码" class="headerlink" title="第四步：使用GPU转码"></a>第四步：使用GPU转码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地文件转码</span></span><br><span class="line">ffmpeg -nostats -loglevel warning -hwaccel cuda -i ace.mp4 -vf <span class="string">&quot;scale=720:1270,setsar=1/1&quot;</span> -c:v h264_nvenc -preset p3 -rc vbr -b:v 0 -cq 23 -multipass fullres -tune hq -c:a aac -r 30 -y 3.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带请求头</span></span><br><span class="line">ffmpeg -nostats -loglevel warning -hwaccel cuda -headers <span class="string">&quot;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36\r\nReferer: https://exx.tv/\r\n&quot;</span> -i <span class="string">&quot;https://xxx.m3u8&quot;</span> -vf <span class="string">&quot;scale=720:1270,setsar=1/1&quot;</span> -c:v h264_nvenc -preset p3 -rc vbr -b:v 0 -cq 23 -multipass fullres -tune hq -c:a aac -r 30 -y 3.mp4</span><br></pre></td></tr></table></figure><h4 id="命令详解："><a href="#命令详解：" class="headerlink" title="命令详解："></a>命令详解：</h4><h5 id="基础参数"><a href="#基础参数" class="headerlink" title="基础参数"></a><strong>基础参数</strong></h5><ol><li><strong><code>-nostats</code></strong><ul><li><strong>功能</strong>：禁用编码统计信息的输出。</li><li><strong>说明</strong>：默认情况下，FFmpeg 会实时显示比特率、帧数等统计信息，此参数可减少输出干扰。</li></ul></li><li><strong><code>-loglevel warning</code></strong><ul><li><strong>功能</strong>：设置日志级别为 <code>warning</code>。</li><li><strong>说明</strong>：仅显示警告和错误信息，抑制冗余日志，使输出更简洁。</li></ul></li><li><strong><code>-hwaccel cuda</code></strong><ul><li><strong>功能</strong>：启用 NVIDIA CUDA 硬件加速解码。</li><li><strong>说明</strong>：利用 GPU 加速视频解码流程，提升处理速度。</li></ul></li><li><strong><code>-i ace.mp4</code></strong><ul><li><strong>功能</strong>：指定输入文件为 <code>ace.mp4</code>。</li></ul></li></ol><hr><h5 id="视频处理参数"><a href="#视频处理参数" class="headerlink" title="视频处理参数"></a><strong>视频处理参数</strong></h5><ol><li><strong><code>-vf &quot;scale=720:1270,setsar=1/1&quot;</code></strong><ul><li><strong>功能</strong>：应用视频滤镜链。<ul><li><strong><code>scale=720:1270</code></strong>：将视频缩放至 <code>720x1270</code> 分辨率（注意宽高比可能被改变）。</li><li><strong><code>setsar=1/1</code></strong>：设置像素宽高比（Sample Aspect Ratio）为 1:1，确保方形像素显示。</li></ul></li><li><strong>说明</strong>：调整分辨率后需修正宽高比，避免播放时变形。</li></ul></li></ol><hr><h5 id="视频编码参数"><a href="#视频编码参数" class="headerlink" title="视频编码参数"></a><strong>视频编码参数</strong></h5><ol><li><strong><code>-c:v h264_nvenc</code></strong><ul><li><strong>功能</strong>：使用 NVIDIA NVENC 硬件编码器生成 H.264 视频流。</li><li><strong>说明</strong>：相比 CPU 编码（如 <code>libx264</code>），硬件编码速度更快，但压缩效率略低。</li></ul></li><li><strong><code>-preset p3</code></strong><ul><li><strong>功能</strong>：设置编码器预设为 <code>p3</code>。</li><li><strong>说明</strong>：NVENC 预设范围 <code>p1</code>（最快）到 <code>p7</code>（最慢但质量更好），<code>p3</code> 平衡速度与质量。</li></ul></li><li><strong><code>-rc vbr</code></strong><ul><li><strong>功能</strong>：使用可变比特率（Variable Bitrate）控制模式。</li><li><strong>说明</strong>：VBR 根据内容复杂度动态分配码率，相比 CBR（恒定码率）更节省存储。</li></ul></li><li><strong><code>-b:v 0</code></strong><ul><li><strong>功能</strong>：将视频目标比特率设为 <code>0</code>。</li><li><strong>说明</strong>：在 <code>-rc vbr</code> + <code>-cq</code> 模式下，此参数表示由质量参数（<code>-cq</code>）主导码率分配。</li></ul></li><li><strong><code>-cq 23</code></strong><ul><li><strong>功能</strong>：设置恒定质量模式的质量值为 <code>23</code>。</li><li><strong>说明</strong>：NVENC 的 <code>cq</code> 范围通常为 <code>0</code>（无损）到 <code>51</code>（最差），<code>23</code> 是常见高质量选择。</li></ul></li><li><strong><code>-multipass fullres</code></strong><ul><li><strong>功能</strong>：启用两趟编码（Two-Pass Encoding），使用全分辨率分析。</li><li><strong>说明</strong>：首趟分析视频内容，次趟优化码率分配，提升压缩效率（需更高计算资源）。</li></ul></li><li><strong><code>-tune hq</code></strong><ul><li><strong>功能</strong>：优化编码参数以追求高质量。</li><li><strong>说明</strong>：适用于对画质要求较高的场景，可能牺牲部分编码速度。</li></ul></li></ol><hr><h5 id="音频与帧率参数"><a href="#音频与帧率参数" class="headerlink" title="音频与帧率参数"></a><strong>音频与帧率参数</strong></h5><ol><li><strong><code>-c:a aac</code></strong><ul><li><strong>功能</strong>：使用 AAC 编码器压缩音频流。</li><li><strong>说明</strong>：AAC 是通用音频格式，平衡音质与文件大小。</li></ul></li><li><strong><code>-r 30</code></strong><ul><li><strong>功能</strong>：强制输出视频帧率为 <code>30 FPS</code>。</li><li><strong>说明</strong>：若输入帧率不一致，FFmpeg 会通过丢帧或插帧适配。</li></ul></li></ol><hr><h5 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a><strong>其他参数</strong></h5><ol><li><strong><code>-y</code></strong><ul><li><strong>功能</strong>：自动覆盖输出文件（<code>3.mp4</code>），无需用户确认。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Ubuntu配置安装GPU转码&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A5-安装教程" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
    <category term="ubuntu" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/ubuntu/"/>
    
    
    <category term="转码" scheme="https://kanoc.gitee.io/tags/%E8%BD%AC%E7%A0%81/"/>
    
    <category term="gpu" scheme="https://kanoc.gitee.io/tags/gpu/"/>
    
    <category term="NVIDIA" scheme="https://kanoc.gitee.io/tags/NVIDIA/"/>
    
  </entry>
  
  <entry>
    <title>go交叉编译错误:sqlite数据库</title>
    <link href="https://kanoc.gitee.io/2025/05/26/go%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF-sqlite%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://kanoc.gitee.io/2025/05/26/go%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF-sqlite%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2025-05-26T01:18:39.000Z</published>
    <updated>2025-06-09T10:40:26.730Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>go交叉编译错误:sqlite数据库：</strong></font></p><span id="more"></span><p><font color=#f26522 size=4 face=宋体><strong>错误内容：</strong></font></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; CGO_ENABLED=1 GOOS=linux GOARCH=amd64 go build -o SaveVideo</span><br><span class="line"># runtime/cgo</span><br><span class="line">linux_syscall.c:67:13: error: call to undeclared function &#x27;setresgid&#x27;; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration]</span><br><span class="line">linux_syscall.c:67:13: note: did you mean &#x27;setregid&#x27;?</span><br><span class="line">/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h:593:6: note: &#x27;setregid&#x27; declared here</span><br><span class="line">linux_syscall.c:73:13: error: call to undeclared function &#x27;setresuid&#x27;; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration]</span><br><span class="line">linux_syscall.c:73:13: note: did you mean &#x27;setreuid&#x27;?</span><br><span class="line">/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h:595:6: note: &#x27;setreuid&#x27; declared here</span><br></pre></td></tr></table></figure><p><font color=#f26522 size=5 face=宋体><strong>错误说明：</strong></font></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">嗯，用户遇到了在MacOS上交叉编译到Linux时出现的CGO错误。错误信息指出`setresgid`和`setresuid`函数未声明，而系统头文件里只有`setregid`和`setreuid`。我需要仔细分析这个问题，找到根本原因，并提供有效的解决方案。</span><br><span class="line"></span><br><span class="line">首先，用户使用的命令是`CGO_ENABLED=1 GOOS=linux GOARCH=amd64 go build -o SaveVideo`。他们启用了CGO，并且尝试交叉编译到Linux的amd64架构。错误来自C代码中的函数调用，说明在交叉编译时，MacOS的本地C编译器（可能是clang）在尝试编译针对Linux的C代码时找不到这些函数。</span><br><span class="line"></span><br><span class="line">接下来，我需要确认`setresgid`和`setresuid`在Linux中的情况。这两个函数是Linux特有的系统调用，用于设置真实、有效和保存的组ID和用户ID。在MacOS的标准库中，并没有这两个函数，取而代之的是`setregid`和`setreuid`，这解释了为什么编译器会提示函数未声明。</span><br><span class="line"></span><br><span class="line">可能的原因是，交叉编译时使用的C编译器（比如MacOS自带的clang）默认链接了MacOS的系统头文件，而这些头文件里没有Linux特定的函数声明。因此，当交叉编译到Linux时，需要确保使用适合目标平台的C库和头文件。</span><br><span class="line"></span><br><span class="line">解决方案方面，用户需要安装一个针对Linux的C交叉编译工具链，比如musl工具链，这样在编译时可以使用Linux兼容的头文件和库。同时，可能需要指定使用musl-gcc作为编译器，以确保正确的函数声明和链接。</span><br><span class="line"></span><br><span class="line">另外，用户可能需要检查代码中是否有直接或间接使用这些系统调用的情况。如果是某个依赖库（如go-sqlite3）使用了这些函数，可能需要查看该库的文档或问题列表，确认是否有已知的跨平台编译问题，或者是否需要特定的编译标签。</span><br><span class="line"></span><br><span class="line">总结步骤应该是：安装musl交叉编译工具链，配置环境变量使用正确的编译器，确保依赖库的安装，然后重新编译。如果问题依然存在，可能需要进一步检查代码或依赖库的兼容性，或者考虑在Linux环境中进行编译以避免跨平台问题。</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>此错误是由于在 <strong>MacOS 上交叉编译 Linux 可执行文件</strong>时，C 编译器使用了 MacOS 的系统头文件，而 Linux 特有的系统调用 <code>setresgid</code> 和 <code>setresuid</code> 未在 MacOS 头文件中声明。以下是分步修复方法：</p><hr><h4 id="1-安装-Linux-交叉编译工具链"><a href="#1-安装-Linux-交叉编译工具链" class="headerlink" title="1. 安装 Linux 交叉编译工具链"></a>1. <strong>安装 Linux 交叉编译工具链</strong></h4><p>需要安装针对 Linux 的 C 编译器（如 <code>musl-gcc</code>），以正确识别 Linux 系统调用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 musl 交叉编译工具链（MacOS）</span></span><br><span class="line">brew install FiloSottile/musl-cross/musl-cross</span><br></pre></td></tr></table></figure><hr><h4 id="2-配置编译命令"><a href="#2-配置编译命令" class="headerlink" title="2. 配置编译命令"></a>2. <strong>配置编译命令</strong></h4><p>指定使用 <code>musl-gcc</code> 作为 C 编译器，并启用静态链接：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED=1 \</span><br><span class="line">GOOS=linux \</span><br><span class="line">GOARCH=amd64 \</span><br><span class="line">CC=x86_64-linux-musl-gcc \</span><br><span class="line">CXX=x86_64-linux-musl-g++ \</span><br><span class="line">go build -ldflags <span class="string">&#x27;-extldflags &quot;-static&quot;&#x27;</span> -o SaveVideo</span><br></pre></td></tr></table></figure><hr><h4 id="3-验证静态编译"><a href="#3-验证静态编译" class="headerlink" title="3. 验证静态编译"></a>3. <strong>验证静态编译</strong></h4><p>检查生成的二进制文件是否为静态链接：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查文件类型</span></span><br><span class="line">file SaveVideo</span><br><span class="line"><span class="comment"># 期望输出：ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查动态库依赖（应无输出）</span></span><br><span class="line">ldd SaveVideo</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;go交叉编译错误:sqlite数据库：&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A9-错误解决" scheme="https://kanoc.gitee.io/categories/A9-%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
    
    <category term="Golang" scheme="https://kanoc.gitee.io/categories/A9-%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/Golang/"/>
    
    
    <category term="错误" scheme="https://kanoc.gitee.io/tags/%E9%94%99%E8%AF%AF/"/>
    
    <category term="编译" scheme="https://kanoc.gitee.io/tags/%E7%BC%96%E8%AF%91/"/>
    
    <category term="交叉编译" scheme="https://kanoc.gitee.io/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Go版本管理工具goenv-安装教程</title>
    <link href="https://kanoc.gitee.io/2025/05/26/Go%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7goenv-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>https://kanoc.gitee.io/2025/05/26/Go%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7goenv-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</id>
    <published>2025-05-25T22:55:33.000Z</published>
    <updated>2025-06-09T10:39:42.160Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Go版本管理工具goenv-安装教程</strong></font></p><span id="more"></span><h2 id="goenv"><a href="#goenv" class="headerlink" title="goenv"></a><strong>goenv</strong></h2><p><font color=#f26522 size=4 face=宋体><strong><strong>特点</strong>: 轻量级，类似 <code>pyenv</code> 或 <code>rbenv</code>，通过环境变量管理版本。</strong></font></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/syndbg/goenv.git ~/.goenv</span><br><span class="line"><span class="comment"># 在 shell 配置文件中添加（如 ~/.bashrc/zshrc）:</span></span><br><span class="line"><span class="built_in">export</span> GOENV_ROOT=<span class="string">&quot;<span class="variable">$HOME</span>/.goenv&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$GOENV_ROOT</span>/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(goenv init -)</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="root用户安装环境"><a href="#root用户安装环境" class="headerlink" title="root用户安装环境"></a>root用户安装环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/syndbg/goenv.git ~/.goenv</span><br><span class="line"><span class="comment"># 编辑全局环境变量文件（影响所有用户）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export GOENV_ROOT=&quot;/root/.goenv&quot;&#x27;</span> &gt;&gt; /etc/profile.d/goenv.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$GOENV_ROOT/bin:$PATH&quot;&#x27;</span> &gt;&gt; /etc/profile.d/goenv.sh</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;if command -v goenv 1&gt;/dev/null 2&gt;&amp;1; then\n eval &quot;$(goenv init -)&quot;\nfi&#x27;</span> &gt;&gt; /etc/profile.d/goenv.sh</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令:"></a><strong>常用命令</strong>:</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">goenv install 1.21.0     <span class="comment"># 安装1.21.0版本</span></span><br><span class="line">goenv global 1.21.0      <span class="comment"># 设置全局版本</span></span><br><span class="line">goenv <span class="built_in">local</span> 1.20.5       <span class="comment"># 设置当前目录版本（生成 .go-version 文件）</span></span><br><span class="line">goenv install --list     <span class="comment"># 列出所有可安装版本</span></span><br><span class="line">goenv global 1.21.5      <span class="comment"># 所有项目默认使用此版本</span></span><br><span class="line">goenv <span class="built_in">local</span> 1.21.5       <span class="comment"># 设置当前目录版本  生成 .go-version 文件，仅当前目录生效</span></span><br><span class="line">goenv shell 1.21.5       <span class="comment"># 设置 Shell 会话版本</span></span><br><span class="line">goenv versions           <span class="comment"># 查看已安装版本</span></span><br><span class="line">goenv uninstall 1.21.5   <span class="comment"># 卸载版本</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看当前生效的 Go 版本及路径</span></span><br><span class="line">goenv version         <span class="comment"># 显示当前版本及来源（全局/本地/Shell）</span></span><br><span class="line">goenv <span class="built_in">which</span> go        <span class="comment"># 显示当前使用的 Go 可执行文件路径</span></span><br><span class="line">goenv <span class="built_in">rehash</span>          <span class="comment"># 刷新 Shims 缓存</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Go版本管理工具goenv-安装教程&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A5-安装教程" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
    <category term="Golang" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Golang/"/>
    
    
    <category term="go" scheme="https://kanoc.gitee.io/tags/go/"/>
    
    <category term="goenv" scheme="https://kanoc.gitee.io/tags/goenv/"/>
    
    <category term="版本管理工具" scheme="https://kanoc.gitee.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Django配置-channels-WS的ASGI服务器</title>
    <link href="https://kanoc.gitee.io/2025/05/22/Django%E9%85%8D%E7%BD%AE-channels-WS%E7%9A%84ASGI%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://kanoc.gitee.io/2025/05/22/Django%E9%85%8D%E7%BD%AE-channels-WS%E7%9A%84ASGI%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2025-05-22T01:06:19.000Z</published>
    <updated>2025-06-09T08:37:54.419Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Django配置-channels-WS的ASGI服务器</strong></font></p><span id="more"></span><h1 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h1><p>该环境几乎算是目前最新的版本的asgi服务器了</p><ul><li><p>系统环境：MacOS（M系列）</p></li><li><p>Python版本：<code>3.12</code></p></li><li><p>Django版本：<code>5.1.7</code></p></li><li><p>daphne版本：<code>4.2.0</code></p></li><li><p>channels版本：<code>4.2.2</code></p></li><li><p>asgiref版本：<code>3.8.1</code></p></li></ul><p><img src="https://s2.loli.net/2025/05/22/IktHlRLTXoCMpZq.png" alt="image-20250522090858536"></p><h2 id="项目结构："><a href="#项目结构：" class="headerlink" title="项目结构："></a>项目结构：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── MyPorject</span><br><span class="line">│   ├── asgi.py</span><br><span class="line">│   ├── routing.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   └── wsgi.py</span><br><span class="line">├── apps</span><br><span class="line">│   ├── __pycache__</span><br><span class="line">│   │   └── consumers.cpython-312.pyc</span><br><span class="line">│   ├── consumers.py（位于主app下）</span><br><span class="line">│   └── **其他app**</span><br><span class="line">├── manage.py</span><br></pre></td></tr></table></figure><h2 id="特别说明："><a href="#特别说明：" class="headerlink" title="特别说明："></a>特别说明：</h2><p><font color=red size=4 face=宋体><strong><code>channels</code> 大于 3.0.5 必须配置<code>daphne</code>或者<code>uvicorn</code>使用</strong></font></p><h3 id="第一步：安装带达芙妮的-channels版本，以及其他环境"><a href="#第一步：安装带达芙妮的-channels版本，以及其他环境" class="headerlink" title="第一步：安装带达芙妮的 channels版本，以及其他环境"></a>第一步：安装带<code>达芙妮</code>的 <code>channels</code>版本，以及其他环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install channels[daphne]</span><br><span class="line"><span class="comment"># daphne==4.2.0  channels==4.2.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Django</span></span><br><span class="line">pip install Django==5.1.7</span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装 asgiref</span></span><br><span class="line">pip install asgiref==3.8.1</span><br></pre></td></tr></table></figure><h3 id="第二步：配置-MyPorject-settings-py"><a href="#第二步：配置-MyPorject-settings-py" class="headerlink" title="第二步：配置 MyPorject__settings.py"></a>第二步：配置 <code>MyPorject__settings.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&quot;daphne&quot;</span>,</span><br><span class="line">    <span class="string">&quot;其他app&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 开启 ASGI访问</span></span><br><span class="line">WSGI_APPLICATION = <span class="string">&#x27;MyPorject.wsgi.application&#x27;</span></span><br><span class="line"><span class="comment"># 添加 Channels 配置</span></span><br><span class="line">ASGI_APPLICATION = <span class="string">&#x27;MyPorject.asgi.application&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="第三步：配置-MyPorject-asgi-py"><a href="#第三步：配置-MyPorject-asgi-py" class="headerlink" title="第三步：配置 MyPorject__asgi.py"></a>第三步：配置 <code>MyPorject__asgi.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> ProtocolTypeRouter, URLRouter</span><br><span class="line"><span class="keyword">from</span> django.core.asgi <span class="keyword">import</span> get_asgi_application</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> routing</span><br><span class="line"></span><br><span class="line">os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="string">&#x27;MyPorject.settings&#x27;</span>)</span><br><span class="line">django_asgi_app = get_asgi_application()</span><br><span class="line"></span><br><span class="line">application = ProtocolTypeRouter(&#123;</span><br><span class="line">    <span class="string">&quot;http&quot;</span>: django_asgi_app,</span><br><span class="line">    <span class="string">&quot;websocket&quot;</span>: URLRouter(routing.websocket_urlpatterns)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="第四步：新建-MyPorject-routing-py"><a href="#第四步：新建-MyPorject-routing-py" class="headerlink" title="第四步：新建 MyPorject__routing.py"></a>第四步：新建 <code>MyPorject__routing.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yourapp/routing.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, re_path</span><br><span class="line"><span class="keyword">from</span> apps <span class="keyword">import</span> consumers</span><br><span class="line"></span><br><span class="line">websocket_urlpatterns = [</span><br><span class="line">    <span class="comment"># xxxx/ws/x1</span></span><br><span class="line">    path(<span class="string">&#x27;ws&#x27;</span>, consumers.ChatConsumer.as_asgi()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="第五步：新建-MyPorject-apps-consumers-py"><a href="#第五步：新建-MyPorject-apps-consumers-py" class="headerlink" title="第五步：新建 MyPorject__apps__consumers.py"></a>第五步：新建 <code>MyPorject__apps__consumers.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> channels.generic.websocket <span class="keyword">import</span> AsyncWebsocketConsumer</span><br><span class="line"><span class="keyword">from</span> channels.exceptions <span class="keyword">import</span> StopConsumer</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatConsumer</span>(<span class="title class_ inherited__">AsyncWebsocketConsumer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line">        <span class="variable language_">self</span>.clientData = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.SendDataJsonKeys = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">await</span> <span class="variable language_">self</span>.accept()</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">disconnect</span>(<span class="params">self, close_code=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">raise</span> StopConsumer()</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">receive</span>(<span class="params">self, text_data=<span class="literal">None</span>, bytes_data=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 传递回来的参数的转换</span></span><br><span class="line">            <span class="variable language_">self</span>.clientData = json.loads(text_data)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;传递过来参数了&quot;</span>, <span class="variable language_">self</span>.clientData)</span><br><span class="line">            <span class="variable language_">self</span>.SendDataJsonKeys = <span class="variable language_">self</span>.clientData.keys()   <span class="comment"># 获取传递上来的参数</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> text_data == <span class="string">&quot;断开&quot;</span>:</span><br><span class="line">                <span class="keyword">await</span> <span class="variable language_">self</span>.send(<span class="string">f&quot;<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">await</span> <span class="variable language_">self</span>.send(<span class="string">&quot;网络连接断开！&quot;</span>)</span><br><span class="line">                <span class="keyword">await</span> <span class="variable language_">self</span>.close()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Django配置-channels-WS的ASGI服务器&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://kanoc.gitee.io/categories/Python/"/>
    
    <category term="Django_channels" scheme="https://kanoc.gitee.io/categories/Python/Django-channels/"/>
    
    
    <category term="django" scheme="https://kanoc.gitee.io/tags/django/"/>
    
    <category term="python" scheme="https://kanoc.gitee.io/tags/python/"/>
    
    <category term="ASGI服务器" scheme="https://kanoc.gitee.io/tags/ASGI%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="异步WEB" scheme="https://kanoc.gitee.io/tags/%E5%BC%82%E6%AD%A5WEB/"/>
    
  </entry>
  
  <entry>
    <title>python安装方式集合(ubuntu)</title>
    <link href="https://kanoc.gitee.io/2025/05/21/python%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%E9%9B%86%E5%90%88(ubuntu)/"/>
    <id>https://kanoc.gitee.io/2025/05/21/python%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%E9%9B%86%E5%90%88(ubuntu)/</id>
    <published>2025-05-21T10:19:17.000Z</published>
    <updated>2025-06-10T00:53:27.435Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>python安装方式集合(ubuntu)</strong></font></p><span id="more"></span><h2 id="方式一：apt包管理器方式安装："><a href="#方式一：apt包管理器方式安装：" class="headerlink" title="方式一：apt包管理器方式安装："></a>方式一：apt包管理器方式安装：</h2><h3 id="1、解除仓库限制"><a href="#1、解除仓库限制" class="headerlink" title="1、解除仓库限制"></a>1、解除<code>仓库限制</code></h3><ul><li>官方仓库的 Python 版本通常较保守（如 Ubuntu 22.04 默认仅支持到 Python 3.10）。</li><li>若需更新版本（如 Python 3.11&#x2F;3.12），需添加第三方 PPA 仓库：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 deadsnakes PPA（Ubuntu 适用）</span></span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:deadsnakes/ppa</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure><h3 id="2、查看可安装python版本"><a href="#2、查看可安装python版本" class="headerlink" title="2、查看可安装python版本"></a>2、查看可安装python版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt list <span class="string">&#x27;python3.*&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="3、安装python3-13"><a href="#3、安装python3-13" class="headerlink" title="3、安装python3.13"></a>3、安装python3.13</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install python3.13</span><br></pre></td></tr></table></figure><h3 id="4、设置环境"><a href="#4、设置环境" class="headerlink" title="4、设置环境"></a>4、设置环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 验证安装路径</span></span><br><span class="line"><span class="built_in">which</span> python3.13</span><br><span class="line"><span class="comment"># 输出示例：/usr/bin/python3.13</span></span><br><span class="line">python3.13 -c <span class="string">&quot;import sys; print(sys.executable)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置全局python版本</span></span><br><span class="line"><span class="built_in">ln</span> -s /usr/bin/python3.13 /usr/bin/python3 </span><br></pre></td></tr></table></figure><h3 id="5、安装pip"><a href="#5、安装pip" class="headerlink" title="5、安装pip"></a>5、安装pip</h3><ul><li>方法 1：使用 <code>ensurepip</code>（推荐）—— Python 内置的 <code>ensurepip</code> 模块可直接安装 <code>pip</code>：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为 Python 3.13 安装 pip</span></span><br><span class="line">python3.13 -m ensurepip --upgrade</span><br></pre></td></tr></table></figure><ul><li>方法 2：通过 <code>get-pip.py</code> 脚本 —— 若 <code>ensurepip</code> 不可用（如编译时被禁用），手动下载并安装：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ==================== python3.13 安装</span></span><br><span class="line">curl -O https://bootstrap.pypa.io/get-pip.py <span class="comment"># 下载安装脚本</span></span><br><span class="line">python3.13 get-pip.py    <span class="comment"># 为 Python 3.13 安装 pip</span></span><br><span class="line"><span class="built_in">rm</span> get-pip.py    <span class="comment"># 删除脚本（可选）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==================== python3.8 安装</span></span><br><span class="line"><span class="built_in">sudo</span> apt install python3.8-distutils python3.8-venv</span><br><span class="line">curl -O https://bootstrap.pypa.io/pip/3.8/get-pip.py   <span class="comment"># 版本太小 需要使用专用的pip安装</span></span><br><span class="line">python3.13 get-pip.py    <span class="comment"># 为 Python 3.8 安装 pip</span></span><br><span class="line"><span class="built_in">rm</span> get-pip.py    <span class="comment"># 删除脚本（可选）</span></span><br></pre></td></tr></table></figure><ul><li>方法 3：通过 APT 安装（需仓库支持）—— 若 Python 3.13 来自第三方仓库（如 <code>deadsnakes</code>），尝试安装对应 <code>pip</code>：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python3.13-pip  <span class="comment"># 实际包名可能不同（如 python3-pip）</span></span><br></pre></td></tr></table></figure><p>pip  pip3  pip3.13</p><ul><li>修复路径与权限 —— 安装后，<code>pip</code> 的可执行文件应位于：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/pip3.13    <span class="comment"># 手动或 get-pip.py 安装的路径</span></span><br><span class="line">/usr/bin/pip3.13          <span class="comment"># APT 安装的路径</span></span><br></pre></td></tr></table></figure><ul><li>设置全局变量</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /usr/local/bin/pip3.13 /usr/bin/pip3</span><br></pre></td></tr></table></figure><h2 id="方式二：Pyenv多版本管理方式："><a href="#方式二：Pyenv多版本管理方式：" class="headerlink" title="方式二：Pyenv多版本管理方式："></a>方式二：Pyenv多版本管理方式：</h2><p>Pyenv版本优先级：Shell &gt; Local &gt; Global</p><h3 id="1、更新系统"><a href="#1、更新系统" class="headerlink" title="1、更新系统"></a>1、更新系统</h3><p>首先，你需要确保你的 Ubuntu 系统是最新的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt upgrade</span><br></pre></td></tr></table></figure><h3 id="2、安装pyenv-前置依赖"><a href="#2、安装pyenv-前置依赖" class="headerlink" title="2、安装pyenv 前置依赖"></a>2、安装pyenv 前置依赖</h3><p>PyENV 需要一些依赖项才能正常工作，运行以下命令安装它们。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential libbz2-dev libncurses5-dev libncursesw5-dev libffi-dev libreadline-dev libssl-dev libsqlite3-dev liblzma-dev zlib1g-dev wget curl llvm libncurses-dev xz-utils git</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、安装-PyENV"><a href="#3、安装-PyENV" class="headerlink" title="3、安装 PyENV"></a>3、安装 PyENV</h3><p>执行以下命令，安装 PyENV</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://pyenv.run | bash</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/05/21/ihVmX4TtpKM7Jdg.png" alt="Installing PyENV on Ubuntu"></p><h3 id="4、更新Shell配置"><a href="#4、更新Shell配置" class="headerlink" title="4、更新Shell配置"></a>4、更新Shell配置</h3><ul><li><code>4.1：（非root用户）</code></li></ul><p>​安装 PyENV 后，您需要将其添加到 shell 配置中，编辑 <strong>~&#x2F;.bashrc</strong> 文件，添加以下行，以便每次打开终端时它都会加载。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$HOME</span>/.pyenv/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv init --path)</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv init -)</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv virtualenv-init -)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>​使用 source 命令，使更改生效。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><ul><li><code>4.2、root用户安装方式</code></li></ul><p>​安装 PyENV 后，您需要将其添加到 shell 配置中，编辑 <strong>~&#x2F;.bashrc</strong> 文件，添加以下行，以便每次打开终端时它都会加载。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑全局环境变量文件（影响所有用户）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PYENV_ROOT=&quot;/root/.pyenv&quot;&#x27;</span> &gt;&gt; /etc/profile.d/pyenv.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> &gt;&gt; /etc/profile.d/pyenv.sh</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\n eval &quot;$(pyenv init -)&quot;\nfi&#x27;</span> &gt;&gt; /etc/profile.d/pyenv.sh</span><br></pre></td></tr></table></figure><p>​使用 source 命令，使更改生效。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使配置立即生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/pyenv.sh</span><br></pre></td></tr></table></figure><h3 id="5、安装不同的python版本"><a href="#5、安装不同的python版本" class="headerlink" title="5、安装不同的python版本"></a>5、安装不同的python版本</h3><p>现在您可以安装所需的任何版本的 Python。例如，要安装 Python 3.12</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv install 3.12</span><br></pre></td></tr></table></figure><p>或者您可能需要安装 Python 2.7 等旧版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv install 2.7</span><br></pre></td></tr></table></figure><p>列出系统上安装的所有 Python 版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv install --list</span><br></pre></td></tr></table></figure><h3 id="6、设置全局python版本"><a href="#6、设置全局python版本" class="headerlink" title="6、设置全局python版本"></a>6、设置全局python版本</h3><p>您可以设置默认使用的全局 Python 版本，比如将 Python 3.12 设置为全局版本。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv global 3.12</span><br></pre></td></tr></table></figure><p>查看当前全局 Python 版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv version</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/05/21/9xWJdsCVoDtKe2h.png" alt="PyENV Set Default Python Version"></p><h3 id="7、设置其他版本"><a href="#7、设置其他版本" class="headerlink" title="7、设置其他版本"></a>7、设置其他版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入你的项目目录</span></span><br><span class="line">cd ~/projects/legacy-project</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置该目录的 Python 版本为 3.8</span></span><br><span class="line">pyenv local 3.8.12   # 假设已安装 3.8.12</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这会生成一个隐藏文件 `.python-version`，记录版本号</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 验证</span></span></span><br><span class="line">pyenv shell 3.8.12   # 临时设置</span><br><span class="line">python --version      # 应显示 3.8.12</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出临时模式（恢复全局或本地设置）</span></span><br><span class="line">pyenv shell --unset</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复全局版本</span></span><br><span class="line">cd ~/projects/legacy-project</span><br><span class="line">rm .python-version   # 删除版本标记文件</span><br></pre></td></tr></table></figure><h3 id="使用虚拟环境隔离项目（推荐）"><a href="#使用虚拟环境隔离项目（推荐）" class="headerlink" title="使用虚拟环境隔离项目（推荐）"></a>使用虚拟环境隔离项目（推荐）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建虚拟环境（基于 Python 3.8）</span></span><br><span class="line">pyenv virtualenv 3.8.12 my-legacy-env</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入项目目录并激活虚拟环境</span></span><br><span class="line">cd ~/projects/legacy-project</span><br><span class="line">pyenv local my-legacy-env  # 自动激活</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证</span></span><br><span class="line">python --version  # 显示 3.8.12，且环境独立</span><br><span class="line">pip list          # 显示该环境独立的包</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出虚拟环境</span></span><br><span class="line">pyenv deactivate</span><br></pre></td></tr></table></figure><h3 id="Step-9-验证版本切换"><a href="#Step-9-验证版本切换" class="headerlink" title="Step 9: 验证版本切换"></a>Step 9: 验证版本切换</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~  # 退出项目目录</span><br><span class="line">python --version  # 应显示全局版本 3.13.0</span><br><span class="line"></span><br><span class="line">cd ~/projects/legacy-project</span><br><span class="line">python --version  # 应显示本地版本 3.8.12 或虚拟环境</span><br></pre></td></tr></table></figure><h3 id="11、删除pyenv环境"><a href="#11、删除pyenv环境" class="headerlink" title="11、删除pyenv环境"></a>11、删除pyenv环境</h3><ul><li>1、<strong>删除 <code>pyenv</code> 本体及所有 Python 版本</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除 pyenv 根目录（默认路径）</span></span><br><span class="line"><span class="built_in">rm</span> -rf ~/.pyenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果自定义过安装路径（通过 PYENV_ROOT 变量），删除对应目录</span></span><br><span class="line"><span class="comment"># rm -rf /path/to/your/custom/pyenv</span></span><br></pre></td></tr></table></figure><ul><li><p>2、清理 Shell 环境配置 – 编辑你的 Shell 配置文件（根据实际使用的 Shell）：</p><ul><li><strong>Bash</strong>：<code>~/.bashrc</code>, <code>~/.bash_profile</code></li><li><strong>Zsh</strong>：<code>~/.zshrc</code></li><li><strong>Fish</strong>：<code>~/.config/fish/config.fish</code></li></ul><p><strong>删除以下内容</strong>：</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找并删除与 pyenv 相关的代码块，例如：</span></span><br><span class="line"><span class="built_in">export</span> PYENV_ROOT=<span class="string">&quot;<span class="variable">$HOME</span>/.pyenv&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PYENV_ROOT</span>/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv init -)</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv virtualenv-init -)</span>&quot;</span>  <span class="comment"># 如果配置了虚拟环境插件</span></span><br></pre></td></tr></table></figure><ul><li>**3、 移除已安装的 Python 版本（可选）– 如果之前通过 <code>pyenv</code> 安装了多个 Python 版本，可手动删除：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除所有版本（默认安装路径）</span></span><br><span class="line"><span class="built_in">rm</span> -rf ~/.pyenv/versions/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果自定义过版本路径，删除对应目录</span></span><br><span class="line"><span class="comment"># rm -rf /path/to/your/python/versions</span></span><br></pre></td></tr></table></figure><ul><li>4、清除缓存和临时文件</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf ~/.pyenv/cache     <span class="comment"># 安装时的源码缓存</span></span><br><span class="line"><span class="built_in">rm</span> -f ~/.pyenv/version    <span class="comment"># 当前使用的 Python 版本记录</span></span><br></pre></td></tr></table></figure><ul><li>5、验证卸载 – 重新启动终端或执行：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span> <span class="variable">$SHELL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 然后检查命令是否失效：</span></span><br><span class="line">pyenv --version      <span class="comment"># 应提示 &quot;command not found&quot;</span></span><br><span class="line"><span class="built_in">which</span> python         <span class="comment"># 应指向系统默认 Python，而非 pyenv 路径</span></span><br></pre></td></tr></table></figure><ul><li>6、残留环境变量</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多用户环境：</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/local/pyenv</span><br><span class="line"><span class="comment"># 插件清理：</span></span><br><span class="line"><span class="built_in">rm</span> -rf ~/.pyenv/plugins</span><br></pre></td></tr></table></figure><h2 id="方式三：UV方式："><a href="#方式三：UV方式：" class="headerlink" title="方式三：UV方式："></a>方式三：UV方式：</h2><p>本文参考自：1、<a href="https://blog.csdn.net/muxuen/article/details/147544307">【Python】使用uv管理python虚拟环境_uv环境python-CSDN博客</a></p><p>本文参考自：2、<a href="https://blog.csdn.net/qq_41472205/article/details/145686414">uv 简易安装与更换国内镜像源_uv 国内源-CSDN博客</a></p><h3 id="1、安装uv管理器"><a href="#1、安装uv管理器" class="headerlink" title="1、安装uv管理器"></a>1、安装uv管理器</h3><ul><li>Mac || Linux安装：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -LsSf https://astral.sh/uv/install.sh | sh</span><br></pre></td></tr></table></figure><ul><li>Windows安装：</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式1: 在 Windows 上：使用 Astral.sh 提供的安装脚本</span></span><br><span class="line">powershell <span class="literal">-ExecutionPolicy</span> ByPass <span class="literal">-c</span> <span class="string">&quot;irm https://astral.sh/uv/install.ps1 | iex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2: 在 Windows 上：使用 scoop 安装 uv</span></span><br><span class="line">scoop install uv</span><br></pre></td></tr></table></figure><ul><li>pip安装方式：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install uv</span><br></pre></td></tr></table></figure><ul><li>验证是否安装成功：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 验证安装是否成功</span></span><br><span class="line">uv --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看uv版本</span></span><br><span class="line">uv --version</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/05/21/K5D4J9ovWYuiejn.jpg" alt="img"></p><h3 id="2、卸载uv："><a href="#2、卸载uv：" class="headerlink" title="2、卸载uv："></a>2、卸载uv：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv cache clean</span><br><span class="line"><span class="built_in">rm</span> -r <span class="string">&quot;<span class="subst">$(uv python dir)</span>&quot;</span></span><br><span class="line"><span class="built_in">rm</span> -r <span class="string">&quot;<span class="subst">$(uv tool dir)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mac/linux</span></span><br><span class="line"><span class="built_in">rm</span> ~/.local/bin/uv ~/.local/bin/uvx</span><br><span class="line"><span class="comment"># windows</span></span><br><span class="line"><span class="built_in">rm</span> <span class="variable">$HOME</span>.<span class="built_in">local</span>\bin\uv.exe</span><br><span class="line"><span class="built_in">rm</span> <span class="variable">$HOME</span>.<span class="built_in">local</span>\bin\uvx.exe</span><br></pre></td></tr></table></figure><h3 id="3、python管理："><a href="#3、python管理：" class="headerlink" title="3、python管理："></a>3、python管理：</h3><ul><li>查看python可用版本</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv python list</span><br></pre></td></tr></table></figure><ul><li>安装python3.13</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标准安装方式</span></span><br><span class="line">uv python install 3.13</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他安装Python的方式实现，比如PyPy实现的python</span></span><br><span class="line">uv python install pypy@3.13</span><br></pre></td></tr></table></figure><ul><li>查找某个python版本的路径</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv python find 3.10</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># /Library/Frameworks/Python.framework/Versions/3.10/bin/python3.10</span></span><br></pre></td></tr></table></figure><ul><li>选用python版本（在具体的某个项目中，进入项目目录，使用如下命令指定选用的python版本）</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv python pin 版本号</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个命令会在指定目录下创建一个 `.python-version` 文件，内容如下</span></span><br><span class="line"></span><br><span class="line">uv python pin 3.10</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># Pinned `.python-version` to `3.10`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> .python-version</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 3.10</span></span><br></pre></td></tr></table></figure><h3 id="4、创建虚拟环境（项目）"><a href="#4、创建虚拟环境（项目）" class="headerlink" title="4、创建虚拟环境（项目）"></a>4、创建虚拟环境（项目）</h3><ul><li>方式1：创建项目有两种方式，第一种方式，先创建好项目目录，然后设置python版本并初始化uv虚拟环境</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv python pin 3.10</span><br><span class="line">uv init <span class="comment"># 初始化</span></span><br></pre></td></tr></table></figure><ul><li>执行了uv init之后，会在当前目录下创建几个文件，同时也会在当前目录下执行git init创建出一个新的git仓库来</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/data/code/python/test_code                                                                                                      </span><br><span class="line">❯ uv python pin 3.13</span><br><span class="line">Pinned `.python-version` to `3.13`</span><br><span class="line"></span><br><span class="line">~/data/code/python/test_code                                                                                                      </span><br><span class="line">❯ uv init           </span><br><span class="line">Initialized project `test-code`</span><br><span class="line"></span><br><span class="line">~/data/code/python/test_code main ?6                                                                                              </span><br><span class="line">❯ <span class="built_in">ls</span></span><br><span class="line">README.md      main.py        pyproject.toml</span><br></pre></td></tr></table></figure><ul><li>方式2：另外一个方式是在init之后添加一个项目名，会自动创建项目文件夹</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uv init 项目名</span><br></pre></td></tr></table></figure><h3 id="5、添加依赖"><a href="#5、添加依赖" class="headerlink" title="5、添加依赖"></a>5、添加依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv add 依赖项</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比如添加requests库</span></span><br><span class="line">uv add requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以指定具体版本</span></span><br><span class="line">uv add requests==版本号</span><br></pre></td></tr></table></figure><p>执行了这个命令后，会在当前目录下创建.venv虚拟环境目录（在vscode里面可以选择这个目录作为虚拟环境，否则代码解析会有问题），并添加我们要的依赖项，同时会新增一个uv.lock文件，用于存放依赖项版本相关的信息。pyproject.toml文件中的dependencies字段也会包含需要的依赖项。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/data/code/python/test_code main ?6                                                                                              </span><br><span class="line">❯ uv add requests</span><br><span class="line">Using CPython 3.13.1 interpreter at: /opt/homebrew/opt/python@3.13/bin/python3.13</span><br><span class="line">Creating virtual environment at: .venv</span><br><span class="line">Resolved 6 packages <span class="keyword">in</span> 13.85s</span><br><span class="line">Prepared 5 packages <span class="keyword">in</span> 5.55s</span><br><span class="line">Installed 5 packages <span class="keyword">in</span> 13ms</span><br><span class="line"> + certifi==2025.1.31</span><br><span class="line"> + charset-normalizer==3.4.1</span><br><span class="line"> + idna==3.10</span><br><span class="line"> + requests==2.32.3</span><br><span class="line"> + urllib3==2.4.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而且，从这个输出中也能看到，它自动使用了<code>.python-version</code>指定的3.13版本的python，和当前我们全局目录下的python3指向什么版本没有关系（我的全局python3指向的是3.10版本）</p><h3 id="6、运行程序"><a href="#6、运行程序" class="headerlink" title="6、运行程序"></a>6、运行程序</h3><p>依赖添加好后，就可以使用uv来运行python程序了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv run 程序文件名 [命令行参数]</span><br></pre></td></tr></table></figure><p>uv会自动按照我们的配置来运行程序，无序我们手动维护依赖项，也不需要手动去source各式各样的虚拟环境了。</p><h3 id="7、uvx命令"><a href="#7、uvx命令" class="headerlink" title="7、uvx命令"></a>7、uvx命令</h3><p>随着uv下载的还有一个uvx命令，uvx命令本质上是uv tool run命令的别名</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uvx python main.py</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">uv run main.py</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">uv tool run main.py</span><br></pre></td></tr></table></figure><p>实际例子，如下这两个命令是等价的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ uvx --directory ~/data/code/python/test_code python main.py</span><br><span class="line">Hello from test-code!</span><br><span class="line">    </span><br><span class="line">❯ uv tool run --directory ~/data/code/python/test_code python main.py</span><br><span class="line">Hello from test-code!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8、设置下载包的镜像源"><a href="#8、设置下载包的镜像源" class="headerlink" title="8、设置下载包的镜像源"></a>8、设置下载包的镜像源</h3><p>uv下载第三方库本质上也是通过pypi源下载的，所以在国内网络环境中默认链接速度会很慢，可以在项目目录的<code>pyproject.toml</code>中添加如下内容来使用清华源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[tool.uv.index]]</span><br><span class="line">url = <span class="string">&quot;https://pypi.tuna.tsinghua.edu.cn/simple&quot;</span></span><br><span class="line">default = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>运行uv add命令的时候也可以指定镜像源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv add --default-index https://pypi.tuna.tsinghua.edu.cn/simple requests</span><br></pre></td></tr></table></figure><p>uv也提供了全局的配置项，可以通过环境变量<code>UV_DEFAULT_INDEX</code>配置镜像源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> UV_DEFAULT_INDEX=https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>全局的配置项优先级低于<code>pyproject.toml</code>中配置的镜像源。如果<code>pyproject.toml</code>里面配置了镜像源，则会使用<code>pyproject.toml</code>的配置。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;python安装方式集合(ubuntu)&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A5-安装教程" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
    <category term="Python" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Python/"/>
    
    
    <category term="python管理器" scheme="https://kanoc.gitee.io/tags/python%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu22安装uv管理python</title>
    <link href="https://kanoc.gitee.io/2025/05/21/ubuntu22%E5%AE%89%E8%A3%85uv%E7%AE%A1%E7%90%86python/"/>
    <id>https://kanoc.gitee.io/2025/05/21/ubuntu22%E5%AE%89%E8%A3%85uv%E7%AE%A1%E7%90%86python/</id>
    <published>2025-05-20T16:13:25.000Z</published>
    <updated>2025-06-10T01:07:15.388Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>ubuntu22安装uv管理器</strong></font></p><span id="more"></span><p>本文参考自：1、<a href="https://blog.csdn.net/muxuen/article/details/147544307">【Python】使用uv管理python虚拟环境_uv环境python-CSDN博客</a></p><p>本文参考自：2、<a href="https://blog.csdn.net/qq_41472205/article/details/145686414">uv 简易安装与更换国内镜像源_uv 国内源-CSDN博客</a></p><h3 id="1、安装uv管理器"><a href="#1、安装uv管理器" class="headerlink" title="1、安装uv管理器"></a>1、安装uv管理器</h3><ul><li>Mac || Linux安装：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -LsSf https://astral.sh/uv/install.sh | sh</span><br></pre></td></tr></table></figure><ul><li>Windows安装：</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式1: 在 Windows 上：使用 Astral.sh 提供的安装脚本</span></span><br><span class="line">powershell <span class="literal">-ExecutionPolicy</span> ByPass <span class="literal">-c</span> <span class="string">&quot;irm https://astral.sh/uv/install.ps1 | iex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2: 在 Windows 上：使用 scoop 安装 uv</span></span><br><span class="line">scoop install uv</span><br></pre></td></tr></table></figure><ul><li>pip安装方式：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install uv</span><br></pre></td></tr></table></figure><ul><li>验证是否安装成功：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 验证安装是否成功</span></span><br><span class="line">uv --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看uv版本</span></span><br><span class="line">uv --version</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/05/21/iSowqNnKdsv9CbB.jpg" alt="img"></p><h3 id="2、卸载uv："><a href="#2、卸载uv：" class="headerlink" title="2、卸载uv："></a>2、卸载uv：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv cache clean</span><br><span class="line"><span class="built_in">rm</span> -r <span class="string">&quot;<span class="subst">$(uv python dir)</span>&quot;</span></span><br><span class="line"><span class="built_in">rm</span> -r <span class="string">&quot;<span class="subst">$(uv tool dir)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mac/linux</span></span><br><span class="line"><span class="built_in">rm</span> ~/.local/bin/uv ~/.local/bin/uvx</span><br><span class="line"><span class="comment"># windows</span></span><br><span class="line"><span class="built_in">rm</span> <span class="variable">$HOME</span>.<span class="built_in">local</span>\bin\uv.exe</span><br><span class="line"><span class="built_in">rm</span> <span class="variable">$HOME</span>.<span class="built_in">local</span>\bin\uvx.exe</span><br></pre></td></tr></table></figure><h3 id="3、python管理："><a href="#3、python管理：" class="headerlink" title="3、python管理："></a>3、python管理：</h3><ul><li>查看python可用版本</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv python list</span><br></pre></td></tr></table></figure><ul><li>安装python3.13</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标准安装方式</span></span><br><span class="line">uv python install 3.13</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他安装Python的方式实现，比如PyPy实现的python</span></span><br><span class="line">uv python install pypy@3.13</span><br></pre></td></tr></table></figure><ul><li>查找某个python版本的路径</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv python find 3.10</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># /Library/Frameworks/Python.framework/Versions/3.10/bin/python3.10</span></span><br></pre></td></tr></table></figure><ul><li>选用python版本（在具体的某个项目中，进入项目目录，使用如下命令指定选用的python版本）</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv python pin 版本号</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个命令会在指定目录下创建一个 `.python-version` 文件，内容如下</span></span><br><span class="line"></span><br><span class="line">uv python pin 3.10</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># Pinned `.python-version` to `3.10`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> .python-version</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 3.10</span></span><br></pre></td></tr></table></figure><h3 id="4、创建虚拟环境（项目）"><a href="#4、创建虚拟环境（项目）" class="headerlink" title="4、创建虚拟环境（项目）"></a>4、创建虚拟环境（项目）</h3><ul><li>方式1：创建项目有两种方式，第一种方式，先创建好项目目录，然后设置python版本并初始化uv虚拟环境</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv python pin 3.10</span><br><span class="line">uv init <span class="comment"># 初始化</span></span><br></pre></td></tr></table></figure><ul><li>执行了uv init之后，会在当前目录下创建几个文件，同时也会在当前目录下执行git init创建出一个新的git仓库来</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/data/code/python/test_code                                                                                                      </span><br><span class="line">❯ uv python pin 3.13</span><br><span class="line">Pinned `.python-version` to `3.13`</span><br><span class="line"></span><br><span class="line">~/data/code/python/test_code                                                                                                      </span><br><span class="line">❯ uv init           </span><br><span class="line">Initialized project `test-code`</span><br><span class="line"></span><br><span class="line">~/data/code/python/test_code main ?6                                                                                              </span><br><span class="line">❯ <span class="built_in">ls</span></span><br><span class="line">README.md      main.py        pyproject.toml</span><br></pre></td></tr></table></figure><ul><li>方式2：另外一个方式是在init之后添加一个项目名，会自动创建项目文件夹</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uv init 项目名</span><br></pre></td></tr></table></figure><h3 id="5、添加依赖"><a href="#5、添加依赖" class="headerlink" title="5、添加依赖"></a>5、添加依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv add 依赖项</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比如添加requests库</span></span><br><span class="line">uv add requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以指定具体版本</span></span><br><span class="line">uv add requests==版本号</span><br></pre></td></tr></table></figure><p>执行了这个命令后，会在当前目录下创建.venv虚拟环境目录（在vscode里面可以选择这个目录作为虚拟环境，否则代码解析会有问题），并添加我们要的依赖项，同时会新增一个uv.lock文件，用于存放依赖项版本相关的信息。pyproject.toml文件中的dependencies字段也会包含需要的依赖项。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/data/code/python/test_code main ?6                                                                                              </span><br><span class="line">❯ uv add requests</span><br><span class="line">Using CPython 3.13.1 interpreter at: /opt/homebrew/opt/python@3.13/bin/python3.13</span><br><span class="line">Creating virtual environment at: .venv</span><br><span class="line">Resolved 6 packages <span class="keyword">in</span> 13.85s</span><br><span class="line">Prepared 5 packages <span class="keyword">in</span> 5.55s</span><br><span class="line">Installed 5 packages <span class="keyword">in</span> 13ms</span><br><span class="line"> + certifi==2025.1.31</span><br><span class="line"> + charset-normalizer==3.4.1</span><br><span class="line"> + idna==3.10</span><br><span class="line"> + requests==2.32.3</span><br><span class="line"> + urllib3==2.4.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而且，从这个输出中也能看到，它自动使用了<code>.python-version</code>指定的3.13版本的python，和当前我们全局目录下的python3指向什么版本没有关系（我的全局python3指向的是3.10版本）</p><h3 id="6、运行程序"><a href="#6、运行程序" class="headerlink" title="6、运行程序"></a>6、运行程序</h3><p>依赖添加好后，就可以使用uv来运行python程序了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv run 程序文件名 [命令行参数]</span><br></pre></td></tr></table></figure><p>uv会自动按照我们的配置来运行程序，无序我们手动维护依赖项，也不需要手动去source各式各样的虚拟环境了。</p><h3 id="7、uvx命令"><a href="#7、uvx命令" class="headerlink" title="7、uvx命令"></a>7、uvx命令</h3><p>随着uv下载的还有一个uvx命令，uvx命令本质上是uv tool run命令的别名</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uvx python main.py</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">uv run main.py</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">uv tool run main.py</span><br></pre></td></tr></table></figure><p>实际例子，如下这两个命令是等价的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ uvx --directory ~/data/code/python/test_code python main.py</span><br><span class="line">Hello from test-code!</span><br><span class="line">    </span><br><span class="line">❯ uv tool run --directory ~/data/code/python/test_code python main.py</span><br><span class="line">Hello from test-code!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8、设置下载包的镜像源"><a href="#8、设置下载包的镜像源" class="headerlink" title="8、设置下载包的镜像源"></a>8、设置下载包的镜像源</h3><p>uv下载第三方库本质上也是通过pypi源下载的，所以在国内网络环境中默认链接速度会很慢，可以在项目目录的<code>pyproject.toml</code>中添加如下内容来使用清华源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[tool.uv.index]]</span><br><span class="line">url = <span class="string">&quot;https://pypi.tuna.tsinghua.edu.cn/simple&quot;</span></span><br><span class="line">default = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>运行uv add命令的时候也可以指定镜像源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uv add --default-index https://pypi.tuna.tsinghua.edu.cn/simple requests</span><br></pre></td></tr></table></figure><p>uv也提供了全局的配置项，可以通过环境变量<code>UV_DEFAULT_INDEX</code>配置镜像源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> UV_DEFAULT_INDEX=https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>全局的配置项优先级低于<code>pyproject.toml</code>中配置的镜像源。如果<code>pyproject.toml</code>里面配置了镜像源，则会使用<code>pyproject.toml</code>的配置。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;ubuntu22安装uv管理器&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A5-安装教程" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
    <category term="ubuntu" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/ubuntu/"/>
    
    
    <category term="pyenv" scheme="https://kanoc.gitee.io/tags/pyenv/"/>
    
  </entry>
  
  <entry>
    <title>windows安装配置pyenv</title>
    <link href="https://kanoc.gitee.io/2025/05/03/windows%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEpyenv/"/>
    <id>https://kanoc.gitee.io/2025/05/03/windows%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEpyenv/</id>
    <published>2025-05-03T05:44:09.000Z</published>
    <updated>2025-06-10T01:09:30.152Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>windows安装配置pyenv</strong></font></p><span id="more"></span><p>根据官方文档的命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Invoke-WebRequest -UseBasicParsing -Uri &quot;https://raw.githubusercontent.com/pyenv-win/pyenv-win/master/pyenv-win/install-pyenv-win.ps1&quot; -OutFile &quot;./install-pyenv-win.ps1&quot;; &amp;&quot;./install-pyenv-win.ps1&quot;</span><br></pre></td></tr></table></figure><p>直接执行该命令可能会出现错误。我们可以使用下面的方法：</p><ul><li>进入<a href="https://raw.githubusercontent.com/pyenv-win/pyenv-win/master/pyenv-win/install-pyenv-win.ps1">pyenv-win配置文件</a>的下载地址 ，将该名为<code>install-pyenv-win.ps1</code>的配置文件下载至电脑某目录(如<code>D:\pyenv</code>)</li><li>将脚本文件下载完成后，在终端(<code>PowerShell</code>) 中，使用cd命令切换到保存该脚本文件的目录，然后运行以下命令来执行脚本</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./install-pyenv-win.ps1</span><br></pre></td></tr></table></figure><ul><li>执行完成后，运行下面的命令确认是否安装成功：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv --version</span><br></pre></td></tr></table></figure><p>显示以下画面，说明安装成功：</p><p><img src="https://s2.loli.net/2025/05/03/kTM8bmwgpzqLl9Q.webp" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;windows安装配置pyenv&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A5-安装教程" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
    <category term="windows" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/windows/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>NVM、Pyenv安装的程序，在宝塔面板中无法识别解决方案</title>
    <link href="https://kanoc.gitee.io/2025/05/02/NVM%E3%80%81Pyenv%E5%AE%89%E8%A3%85%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%9C%A8%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E4%B8%AD%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://kanoc.gitee.io/2025/05/02/NVM%E3%80%81Pyenv%E5%AE%89%E8%A3%85%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%9C%A8%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E4%B8%AD%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2025-05-02T15:28:06.000Z</published>
    <updated>2025-06-09T13:06:42.160Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>NVM、Pyenv安装的程序，在宝塔面板中无法识别解决方案</strong></font></p><span id="more"></span><p>将 <code>nvm</code> 安装的 Node.js 软链接到系统全局路径 <code>/usr/bin</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s ~/.nvm/versions/node/v18.14.2/bin/node /usr/bin/node</span><br><span class="line">sudo ln -s ~/.nvm/versions/node/v18.14.2/bin/npm /usr/bin/npm</span><br><span class="line">sudo ln -s ~/.nvm/versions/node/v18.14.2/bin/npx /usr/bin/npx</span><br></pre></td></tr></table></figure><p><strong>验证</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">which node  # 应输出 /usr/bin/node</span><br></pre></td></tr></table></figure><h3 id="Pyenv的处理与NVM的处理类似"><a href="#Pyenv的处理与NVM的处理类似" class="headerlink" title="Pyenv的处理与NVM的处理类似"></a>Pyenv的处理与NVM的处理类似</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;NVM、Pyenv安装的程序，在宝塔面板中无法识别解决方案&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A5-安装教程" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
    <category term="Node" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Node/"/>
    
    
    <category term="Pyenv" scheme="https://kanoc.gitee.io/tags/Pyenv/"/>
    
    <category term="NVM" scheme="https://kanoc.gitee.io/tags/NVM/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu-部署Pyenv-并使用不同环境</title>
    <link href="https://kanoc.gitee.io/2025/04/28/ubuntu-%E9%83%A8%E7%BD%B2Pyenv-%E5%B9%B6%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83/"/>
    <id>https://kanoc.gitee.io/2025/04/28/ubuntu-%E9%83%A8%E7%BD%B2Pyenv-%E5%B9%B6%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83/</id>
    <published>2025-04-28T13:07:42.000Z</published>
    <updated>2025-06-10T01:05:50.370Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>ubuntu 部署Pyenv 并使用不同环境</strong></font></p><span id="more"></span><h1 id="Pyenv版本优先级：Shell-Local-Global"><a href="#Pyenv版本优先级：Shell-Local-Global" class="headerlink" title="Pyenv版本优先级：Shell &gt; Local &gt; Global"></a>Pyenv版本优先级：Shell &gt; Local &gt; Global</h1><h3 id="Step-1-Update-Your-System"><a href="#Step-1-Update-Your-System" class="headerlink" title="Step 1: Update Your System"></a>Step 1: Update Your System</h3><p>首先，你需要确保你的 Ubuntu 系统是最新的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt upgrade</span><br></pre></td></tr></table></figure><h3 id="Step-2-Install-Prerequisites"><a href="#Step-2-Install-Prerequisites" class="headerlink" title="Step 2: Install Prerequisites"></a>Step 2: Install Prerequisites</h3><p>PyENV 需要一些依赖项才能正常工作，运行以下命令安装它们。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential libbz2-dev libncurses5-dev libncursesw5-dev libffi-dev libreadline-dev libssl-dev libsqlite3-dev liblzma-dev zlib1g-dev wget curl llvm libncurses-dev xz-utils git</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Step-3-Install-PyENV"><a href="#Step-3-Install-PyENV" class="headerlink" title="Step 3: Install PyENV"></a>Step 3: Install PyENV</h3><p>执行以下命令，安装 PyENV</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://pyenv.run | bash</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/04/28/A6ftuGO3xJBviVI.png" alt="Installing PyENV on Ubuntu"></p><h3 id="Step-4-Update-Your-Shell-Configuration"><a href="#Step-4-Update-Your-Shell-Configuration" class="headerlink" title="Step 4: Update Your Shell Configuration"></a>Step 4: Update Your Shell Configuration</h3><p>安装 PyENV 后，您需要将其添加到 shell 配置中，编辑 <strong>~&#x2F;.bashrc</strong> 文件，添加以下行，以便每次打开终端时它都会加载。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$HOME</span>/.pyenv/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv init --path)</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv init -)</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv virtualenv-init -)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>使用 source 命令，使更改生效。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="Step-4-Update-Your-Shell-Configuration-root用户安装方式"><a href="#Step-4-Update-Your-Shell-Configuration-root用户安装方式" class="headerlink" title="Step 4: Update Your Shell Configuration(root用户安装方式)"></a>Step 4: Update Your Shell Configuration(root用户安装方式)</h3><p>安装 PyENV 后，您需要将其添加到 shell 配置中，编辑 <strong>~&#x2F;.bashrc</strong> 文件，添加以下行，以便每次打开终端时它都会加载。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑全局环境变量文件（影响所有用户）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PYENV_ROOT=&quot;/root/.pyenv&quot;&#x27;</span> &gt;&gt; /etc/profile.d/pyenv.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> &gt;&gt; /etc/profile.d/pyenv.sh</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\n eval &quot;$(pyenv init -)&quot;\nfi&#x27;</span> &gt;&gt; /etc/profile.d/pyenv.sh</span><br></pre></td></tr></table></figure><p>使用 source 命令，使更改生效。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使配置立即生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/pyenv.sh</span><br></pre></td></tr></table></figure><h3 id="Step-5-Install-Python-Versions"><a href="#Step-5-Install-Python-Versions" class="headerlink" title="Step 5: Install Python Versions"></a>Step 5: Install Python Versions</h3><p>现在您可以安装所需的任何版本的 Python。例如，要安装 Python 3.12</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv install 3.12</span><br></pre></td></tr></table></figure><p>或者您可能需要安装 Python 2.7 等旧版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv install 2.7</span><br></pre></td></tr></table></figure><p>列出系统上安装的所有 Python 版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv install --list</span><br></pre></td></tr></table></figure><h3 id="Step-6-Set-a-Global-Python-Version"><a href="#Step-6-Set-a-Global-Python-Version" class="headerlink" title="Step 6: Set a Global Python Version"></a>Step 6: Set a Global Python Version</h3><p>您可以设置默认使用的全局 Python 版本，比如将 Python 3.12 设置为全局版本。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv global 3.12</span><br></pre></td></tr></table></figure><p>查看当前全局 Python 版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv version</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/04/28/aWyE9BJAwHVMdmT.png" alt="PyENV Set Default Python Version"></p><h3 id="Step-7-设置其他版本"><a href="#Step-7-设置其他版本" class="headerlink" title="Step 7: 设置其他版本"></a>Step 7: 设置其他版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入你的项目目录</span></span><br><span class="line">cd ~/projects/legacy-project</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置该目录的 Python 版本为 3.8</span></span><br><span class="line">pyenv local 3.8.12   # 假设已安装 3.8.12</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这会生成一个隐藏文件 `.python-version`，记录版本号</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 验证</span></span></span><br><span class="line">pyenv shell 3.8.12   # 临时设置</span><br><span class="line">python --version      # 应显示 3.8.12</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出临时模式（恢复全局或本地设置）</span></span><br><span class="line">pyenv shell --unset</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复全局版本</span></span><br><span class="line">cd ~/projects/legacy-project</span><br><span class="line">rm .python-version   # 删除版本标记文件</span><br></pre></td></tr></table></figure><h3 id="Step-8-使用虚拟环境隔离项目（推荐）"><a href="#Step-8-使用虚拟环境隔离项目（推荐）" class="headerlink" title="Step 8: 使用虚拟环境隔离项目（推荐）"></a>Step 8: 使用虚拟环境隔离项目（推荐）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建虚拟环境（基于 Python 3.8）</span></span><br><span class="line">pyenv virtualenv 3.8.12 my-legacy-env</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入项目目录并激活虚拟环境</span></span><br><span class="line">cd ~/projects/legacy-project</span><br><span class="line">pyenv local my-legacy-env  # 自动激活</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证</span></span><br><span class="line">python --version  # 显示 3.8.12，且环境独立</span><br><span class="line">pip list          # 显示该环境独立的包</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出虚拟环境</span></span><br><span class="line">pyenv deactivate</span><br></pre></td></tr></table></figure><h3 id="Step-9-验证版本切换"><a href="#Step-9-验证版本切换" class="headerlink" title="Step 9: 验证版本切换"></a>Step 9: 验证版本切换</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~  # 退出项目目录</span><br><span class="line">python --version  # 应显示全局版本 3.13.0</span><br><span class="line"></span><br><span class="line">cd ~/projects/legacy-project</span><br><span class="line">python --version  # 应显示本地版本 3.8.12 或虚拟环境</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;ubuntu 部署Pyenv 并使用不同环境&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A5-安装教程" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
    <category term="ubuntu" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/ubuntu/"/>
    
    
    <category term="pyenv" scheme="https://kanoc.gitee.io/tags/pyenv/"/>
    
  </entry>
  
  <entry>
    <title>破解cloudflare拦截神器_puppeteer</title>
    <link href="https://kanoc.gitee.io/2025/02/25/%E7%A0%B4%E8%A7%A3cloudflare%E6%8B%A6%E6%88%AA%E7%A5%9E%E5%99%A8-puppeteer/"/>
    <id>https://kanoc.gitee.io/2025/02/25/%E7%A0%B4%E8%A7%A3cloudflare%E6%8B%A6%E6%88%AA%E7%A5%9E%E5%99%A8-puppeteer/</id>
    <published>2025-02-24T18:52:13.000Z</published>
    <updated>2025-06-09T03:57:07.693Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>破解cloudflare拦截神器_puppeteer</strong></font></p><span id="more"></span><h3 id="安装番外：安装node-js环境"><a href="#安装番外：安装node-js环境" class="headerlink" title="安装番外：安装node.js环境"></a>安装番外：安装node.js环境</h3><h4 id="安装nvm管理器"><a href="#安装nvm管理器" class="headerlink" title="安装nvm管理器"></a>安装<code>nvm</code>管理器</h4><ul><li>第1步：mac 安装：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install nvm</span><br></pre></td></tr></table></figure><ul><li>第2_1步：命令安装：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</span><br><span class="line">或</span><br><span class="line">$ wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</span><br></pre></td></tr></table></figure><ul><li>第2_2步：国内安装</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</span><br><span class="line">或</span><br><span class="line">$ wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</span><br></pre></td></tr></table></figure><ul><li>第3步：添加环境</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、这是本地不存在配置文件的时候提示需要添加的配置</span></span><br><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/.nvm&quot;</span></span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span>  <span class="comment"># This loads nvm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、这是本地存在配置文件的时候提示需要添加的配置（推荐）</span></span><br><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/.nvm&quot;</span></span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/bash_completion&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/bash_completion&quot;</span>  <span class="comment"># This loads nvm bash_completion</span></span><br></pre></td></tr></table></figure><ul><li>第4步：加载环境：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><ul><li>第5步：测试安装是否成功</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nvm -v</span><br><span class="line">或</span><br><span class="line">$ nvm use system</span><br></pre></td></tr></table></figure><ul><li>第6步：<code>nvm</code>相关命令</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm install stable</span><br><span class="line">nvm install &lt;version&gt;     <span class="comment"># 安装指定版本 node</span></span><br><span class="line">nvm uninstall &lt;version&gt;   <span class="comment"># 删除指定版本 node</span></span><br><span class="line"></span><br><span class="line">nvm use &lt;version&gt;         <span class="comment"># 切换使用指定的版本 node</span></span><br><span class="line">nvm <span class="built_in">alias</span> default &lt;version&gt;   <span class="comment"># 永久版本 - 所有窗口生效指定版本</span></span><br><span class="line"></span><br><span class="line">nvm <span class="built_in">ls</span>    <span class="comment"># 列出所有安装的版本</span></span><br><span class="line">nvm ls-remote   <span class="comment"># 列出所有远程服务器的版本（官方 node version list）</span></span><br><span class="line">nvm current   <span class="comment"># 显示当前的版本</span></span><br><span class="line">nvm <span class="built_in">alias</span> &lt;name&gt; &lt;version&gt;   <span class="comment"># 给不同的版本号添加别名</span></span><br><span class="line">nvm <span class="built_in">unalias</span> &lt;name&gt;   <span class="comment"># 删除已定义的别名</span></span><br><span class="line"></span><br><span class="line">nvm reinstall-packages &lt;version&gt;     <span class="comment"># 在当前版本 node 环境下，重新全局安装指定版本号的 npm 包</span></span><br></pre></td></tr></table></figure><h3 id="第一步：安装puppeteer"><a href="#第一步：安装puppeteer" class="headerlink" title="第一步：安装puppeteer"></a>第一步：安装puppeteer</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i puppeteer</span><br></pre></td></tr></table></figure><h3 id="第二步：-安装插件-puppeteer-extra、puppeteer-extra-plugin-stealth"><a href="#第二步：-安装插件-puppeteer-extra、puppeteer-extra-plugin-stealth" class="headerlink" title="第二步： 安装插件 puppeteer-extra、puppeteer-extra-plugin-stealth"></a>第二步： 安装插件 puppeteer-extra、puppeteer-extra-plugin-stealth</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install puppeteer-extra puppeteer-extra-plugin-stealth express</span><br></pre></td></tr></table></figure><h3 id="第三步：使用nodejs获取数据："><a href="#第三步：使用nodejs获取数据：" class="headerlink" title="第三步：使用nodejs获取数据："></a>第三步：使用nodejs获取数据：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer-extra&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">StealthPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer-extra-plugin-stealth&#x27;</span>)</span><br><span class="line">puppeteer.<span class="title function_">use</span>(<span class="title class_">StealthPlugin</span>())</span><br><span class="line"><span class="keyword">const</span> &#123;executablePath&#125; = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puppeteer.<span class="title function_">launch</span>(&#123; <span class="attr">headless</span>: <span class="literal">false</span>, <span class="attr">executablePath</span>: <span class="title function_">executablePath</span>() &#125;).<span class="title function_">then</span>(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>()</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://xxx.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Promise 来等待</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">2000</span>))  <span class="comment">// 等待 2 秒</span></span><br><span class="line">    <span class="comment">// 获取页面的文本内容</span></span><br><span class="line">    <span class="keyword">const</span> pageContent = <span class="keyword">await</span> page.<span class="title function_">evaluate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span>;  <span class="comment">// 获取页面的所有文本</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印页面文本内容</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(pageContent);</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">screenshot</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;cointracker_home.png&#x27;</span>, <span class="attr">fullPage</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="keyword">await</span> browser.<span class="title function_">close</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="第四步：当然你也可以把他写成接口"><a href="#第四步：当然你也可以把他写成接口" class="headerlink" title="第四步：当然你也可以把他写成接口"></a>第四步：当然你也可以把他写成接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.....</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;破解cloudflare拦截神器_puppeteer&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A7-逆向" scheme="https://kanoc.gitee.io/categories/A7-%E9%80%86%E5%90%91/"/>
    
    <category term="puppeteer" scheme="https://kanoc.gitee.io/categories/A7-%E9%80%86%E5%90%91/puppeteer/"/>
    
    
    <category term="逆向" scheme="https://kanoc.gitee.io/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="nodejs" scheme="https://kanoc.gitee.io/tags/nodejs/"/>
    
    <category term="后端" scheme="https://kanoc.gitee.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="puppeteer" scheme="https://kanoc.gitee.io/tags/puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>mongodb数据库的备份与恢复</title>
    <link href="https://kanoc.gitee.io/2025/02/23/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>https://kanoc.gitee.io/2025/02/23/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</id>
    <published>2025-02-22T19:37:49.000Z</published>
    <updated>2025-06-09T12:55:43.401Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Docker下：mongodb数据库的备份与恢复</strong></font></p><span id="more"></span><h2 id="备份篇："><a href="#备份篇：" class="headerlink" title="备份篇："></a>备份篇：</h2><ul><li>备份数据库名称：<code>ttd</code></li><li>本地备份容器：<code>126bf65cd37f</code></li></ul><h3 id="1、进入容器："><a href="#1、进入容器：" class="headerlink" title="1、进入容器："></a>1、进入容器：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps   <span class="comment"># 查看正在运行的docker 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 126bf65cd37f /bin/bash   <span class="comment"># 进入ID：126bf65cd37f 的容器</span></span><br><span class="line">mongodump --uri=<span class="string">&quot;mongodb://username:password@localhost:27017/ttd&quot;</span> --out /path/to/backup/    <span class="comment"># 将数据库备份到/path/to/backup/ 文件夹下</span></span><br></pre></td></tr></table></figure><h3 id="2、打包备份文件"><a href="#2、打包备份文件" class="headerlink" title="2、打包备份文件"></a>2、打包备份文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -cvf /path/to/ttd.tar /path/to/backup/      <span class="comment"># 将/path/to/backup/ 文件夹下的备份数据库  打包到 /path/to/ttd.tar</span></span><br></pre></td></tr></table></figure><h3 id="3、复制备份打包文件到宿主机器"><a href="#3、复制备份打包文件到宿主机器" class="headerlink" title="3、复制备份打包文件到宿主机器"></a>3、复制备份打包文件到宿主机器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将备份的文件复制到宿主机</span></span><br><span class="line">docker <span class="built_in">cp</span> 126bf65cd37f:/path/to/ttd.tar /home/mycp/DataBases   <span class="comment"># 将打包文件 复制到宿主的/home/mycp/DataBases下</span></span><br></pre></td></tr></table></figure><h2 id="恢复篇："><a href="#恢复篇：" class="headerlink" title="恢复篇："></a>恢复篇：</h2><ul><li>恢复数据库名称：<code>ttd</code></li><li>本地备份容器：<code>126bf65cd37f</code></li></ul><h3 id="1、上传压缩包到恢复的宿主机器"><a href="#1、上传压缩包到恢复的宿主机器" class="headerlink" title="1、上传压缩包到恢复的宿主机器"></a>1、上传压缩包到恢复的宿主机器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里就不讲怎么恢复了！</span><br></pre></td></tr></table></figure><h3 id="2、传入docker-机器-上传后的路径：-home-cdd-DataBases-ttd-tar"><a href="#2、传入docker-机器-上传后的路径：-home-cdd-DataBases-ttd-tar" class="headerlink" title="2、传入docker 机器(上传后的路径：/home/cdd/DataBases/ttd.tar)"></a>2、传入docker 机器(上传后的路径：<code>/home/cdd/DataBases/ttd.tar</code>)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /DBFiles   <span class="comment"># 创建路径，不然可能报错</span></span><br><span class="line">docker <span class="built_in">cp</span> /home/cdd/DataBases/ttd.tar 8ba9426d45e3:/DBFiles   <span class="comment"># 复制到docker机器</span></span><br></pre></td></tr></table></figure><h3 id="3、解压缩"><a href="#3、解压缩" class="headerlink" title="3、解压缩"></a>3、解压缩</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf ttd.tar    <span class="comment"># 解压完成会出现一个新的文件夹：ttd</span></span><br></pre></td></tr></table></figure><h3 id="4、恢复"><a href="#4、恢复" class="headerlink" title="4、恢复"></a>4、恢复</h3><ul><li>避坑1：备份的文件夹中存在 <code>.json</code>文件，如果直接用文件夹恢复命令是会报错的</li><li>避坑2：必须要指定<code>--authenticationDatabase admin</code> 否则会提示权限</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongorestore -h 127.0.0.1:27017 --authenticationDatabase admin -u &lt;username&gt; -p &lt;password&gt; -d &lt;database&gt; /home/cdd/DataBases/ttd/Images.bson</span><br><span class="line"><span class="comment"># 如果没有 .json 文件 可以用下面的命令恢复</span></span><br><span class="line">mongorestore --uri=<span class="string">&quot;mongodb://username:password@localhost:27017&quot;</span> /home/cdd/DataBases/ttd</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Docker下：mongodb数据库的备份与恢复&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_9-数据库" scheme="https://kanoc.gitee.io/categories/9-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="mongodb" scheme="https://kanoc.gitee.io/categories/9-%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="mongoldb" scheme="https://kanoc.gitee.io/tags/mongoldb/"/>
    
    <category term="备份与恢复" scheme="https://kanoc.gitee.io/tags/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu-设置swap交换空间</title>
    <link href="https://kanoc.gitee.io/2025/02/17/ubuntu-%E8%AE%BE%E7%BD%AEswap%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4/"/>
    <id>https://kanoc.gitee.io/2025/02/17/ubuntu-%E8%AE%BE%E7%BD%AEswap%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4/</id>
    <published>2025-02-17T01:23:10.000Z</published>
    <updated>2025-06-10T01:05:39.505Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong><code>ubuntu</code> 设置<code>swap</code>交换空间</strong></font></p><span id="more"></span><p>在 <code>Ubuntu</code> 上设置交换空间（<code>Swap Space</code>）可以帮助系统在物理内存不足时使用硬盘空间来存储临时数据。以下是设置交换空间的步骤：</p><h3 id="步骤-1-检查当前交换空间"><a href="#步骤-1-检查当前交换空间" class="headerlink" title="步骤 1: 检查当前交换空间"></a>步骤 1: 检查当前交换空间</h3><p>首先，检查当前的交换空间是否已启用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo swapon --show</span><br></pre></td></tr></table></figure><p>如果没有输出，表示当前没有启用的交换空间。</p><h3 id="步骤-2-创建交换文件"><a href="#步骤-2-创建交换文件" class="headerlink" title="步骤 2: 创建交换文件"></a>步骤 2: 创建交换文件</h3><ol><li>选择交换文件的大小：决定你想要创建的交换文件的大小。例如，假设你想创建一个 <code>2GB</code> 的交换文件。</li><li>创建交换文件：使用 <code>fallocate</code> 命令创建交换文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo fallocate -l 2G /swapfile</span><br></pre></td></tr></table></figure><p>如果 fallocate 不可用，可以使用 <code>dd</code> 命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dd if=/dev/zero of=/swapfile bs=1G count=2  </span><br></pre></td></tr></table></figure><h3 id="步骤-3-设置交换文件权限"><a href="#步骤-3-设置交换文件权限" class="headerlink" title="步骤 3: 设置交换文件权限"></a>步骤 3: 设置交换文件权限</h3><p>为了安全起见，设置交换文件的权限，使其只能由 <code>root</code> 用户访问：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 600 /swapfile</span><br></pre></td></tr></table></figure><h3 id="步骤-4-将文件设置为交换空间"><a href="#步骤-4-将文件设置为交换空间" class="headerlink" title="步骤 4: 将文件设置为交换空间"></a>步骤 4: 将文件设置为交换空间</h3><p>使用以下命令将文件设置为交换空间：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkswap /swapfile</span><br></pre></td></tr></table></figure><h3 id="步骤-5-启用交换空间"><a href="#步骤-5-启用交换空间" class="headerlink" title="步骤 5: 启用交换空间"></a>步骤 5: 启用交换空间</h3><p>启用交换空间：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo swapon /swapfile</span><br></pre></td></tr></table></figure><h3 id="步骤-6-验证交换空间"><a href="#步骤-6-验证交换空间" class="headerlink" title="步骤 6: 验证交换空间"></a>步骤 6: 验证交换空间</h3><p>再次检查交换空间是否已启用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo swapon --show</span><br></pre></td></tr></table></figure><p>你应该能看到 <code>/swapfile</code> 列在输出中。</p><h3 id="步骤-7-设置开机自动挂载"><a href="#步骤-7-设置开机自动挂载" class="headerlink" title="步骤 7: 设置开机自动挂载"></a>步骤 7: 设置开机自动挂载</h3><p>为了在系统重启后自动启用交换空间，需要将其添加到 <code>/etc/fstab</code> 文件中：</p><ol><li>打开 <code>/etc/fstab</code> 文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/fstab</span><br></pre></td></tr></table></figure><ol start="2"><li>在文件末尾添加以下行：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/swapfile none swap sw 0 0</span><br></pre></td></tr></table></figure><p>保存并退出编辑器（在 <code>nano</code> 中，按 <code>CTRL + X</code>，然后按 <code>Y</code> 确认保存）。</p><h3 id="步骤-8-调整交换空间使用策略（可选）"><a href="#步骤-8-调整交换空间使用策略（可选）" class="headerlink" title="步骤 8: 调整交换空间使用策略（可选）"></a>步骤 8: 调整交换空间使用策略（可选）</h3><p>你可以调整系统使用交换空间的策略。默认情况下，<code>Linux</code> 系统会在物理内存使用到一定程度后才会使用交换空间。你可以通过调整<code> vm.swappiness</code> 参数来改变这一行为：</p><p>查看当前的 <code>swappiness</code> 值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/vm/swappiness</span><br></pre></td></tr></table></figure><p>临时设置 <code>swappiness</code> 值（范围 <code>0-100</code>，值越低，越不倾向于使用交换空间）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sysctl vm.swappiness=10</span><br></pre></td></tr></table></figure><p>要永久更改 <code>swappiness</code> 值，可以编辑 <code>/etc/sysctl.conf</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>在文件中添加或修改以下行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vm.swappiness=10</span><br></pre></td></tr></table></figure><p>保存并退出编辑器。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上步骤，你可以在 <code>Ubuntu</code> 上成功设置和启用交换空间。这将有助于在物理内存不足时提高系统的稳定性和性能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;&lt;code&gt;ubuntu&lt;/code&gt; 设置&lt;code&gt;swap&lt;/code&gt;交换空间&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A5-安装教程" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
    <category term="ubuntu" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/ubuntu/"/>
    
    
    <category term="ubuntu" scheme="https://kanoc.gitee.io/tags/ubuntu/"/>
    
    <category term="swap" scheme="https://kanoc.gitee.io/tags/swap/"/>
    
    <category term="交换空间" scheme="https://kanoc.gitee.io/tags/%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你搭建Docker私有仓库Harbor</title>
    <link href="https://kanoc.gitee.io/2025/02/16/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BADocker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93Harbor/"/>
    <id>https://kanoc.gitee.io/2025/02/16/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BADocker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93Harbor/</id>
    <published>2025-02-16T11:37:35.000Z</published>
    <updated>2025-06-09T07:39:15.791Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>手把手教你搭建Docker私有仓库Harbor</strong></font></p><p>本文搬运自：<a href="https://www.cnblogs.com/sowler/p/18242819">手把手教你搭建Docker私有仓库Harbor - sowler - 博客园</a></p><span id="more"></span><h4 id="1、什么是Docker私有仓库"><a href="#1、什么是Docker私有仓库" class="headerlink" title="1、什么是Docker私有仓库"></a>1、什么是Docker私有仓库</h4><p>Docker私有仓库是用于存储和管理Docker镜像的私有存储库。Docker默认会有一个公共的仓库Docker Hub，而与Docker Hub不同，私有仓库是受限访问的，只有授权用户才能够上传、下载和管理其中的镜像。这种私有仓库可以部署在本地云环境中，用于组织内部开发、测试和生产环境中的容器镜像管理。保证数据安全性。</p><h4 id="2、Docker有哪些私有仓库"><a href="#2、Docker有哪些私有仓库" class="headerlink" title="2、Docker有哪些私有仓库"></a>2、Docker有哪些私有仓库</h4><p><strong>以下是一些常见的Docker私有仓库：</strong></p><ul><li><strong>Harbor</strong>：作为一个企业级的Docker Registry服务，Harbor提供了安全、可信赖的镜像存储和管理功能。它支持RBAC权限控制、镜像复制、镜像签名、漏洞扫描等功能。</li><li><strong>Docker Trusted Registry (DTR)</strong>：由Docker官方推出的企业级Docker私有仓库服务，与Docker Engine紧密集成，支持高度的安全性和可靠性。</li><li><strong>Portus</strong>：一个开源的Docker镜像管理和认证服务，提供用户管理、团队管理、镜像审核等功能，与Docker Registry兼容。</li><li><strong>Nexus Repository Manager</strong>：虽然主要是用于构建和管理Java组件，但也可以用作Docker私有仓库。它具有强大的存储管理和权限控制功能。</li><li><strong>GitLab Container Registry</strong>：GitLab集成了容器注册表功能，允许您存储、管理和分发Docker镜像。这是GitLab自带的功能，无需额外部署。</li><li><strong>AWS Elastic Container Registry (ECR)</strong>：如果使用AWS云服务，可以考虑使用AWS ECR作为私有仓库。它与AWS的其他服务集成紧密，对AWS用户来说是一个方便的选择。</li></ul><p>本篇使用Harbor搭建Docker私有仓库。</p><h4 id="3、Harbor简介"><a href="#3、Harbor简介" class="headerlink" title="3、Harbor简介"></a>3、Harbor简介</h4><p>Harbor是一个开源的企业级Docker Registry服务，它提供了一个安全、可信赖的仓库来存储和管理Docker镜像。Harbor翻译为中文名称为”庇护；居住;”。可以理解为是Docker镜像的”居住环境”或者是镜像的”庇护所”。Harbor最初由VMware公司开发，旨在解决企业级Docker镜像管理的安全和可信任性问题。VMware于2016年发布，在2017年，VMware将Harbor开源，这使得更广泛的社区和组织可以自由地使用和贡献代码。Harbor是一个成熟、功能丰富且安全可靠的企业级Docker Registry服务，为企业容器化应用的部署和管理提供了强大的支持。</p><p>Harbor官网地址：<a href="https://goharbor.io/">Harbor (goharbor.io)</a></p><p>Github开源地址：<a href="https://github.com/goharbor/harbor">https://github.com/goharbor/harbor</a></p><h4 id="4、Harbor下载"><a href="#4、Harbor下载" class="headerlink" title="4、Harbor下载"></a>4、Harbor下载</h4><h5 id="4-1、通过Linux命令下载"><a href="#4-1、通过Linux命令下载" class="headerlink" title="4.1、通过Linux命令下载"></a>4.1、通过Linux命令下载</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://github.com/goharbor/harbor/releases/download/v2.10.0/harbor-offline-installer-v2.10.0.tgz</span><br></pre></td></tr></table></figure><h5 id="4-2、GitHub下载"><a href="#4-2、GitHub下载" class="headerlink" title="4.2、GitHub下载"></a>4.2、GitHub下载</h5><p>下载地址：<a href="https://github.com/goharbor/harbor/releases">https://github.com/goharbor/harbor/releases</a> 下载离线版本</p><p><img src="https://s2.loli.net/2025/02/16/meHfNQrXgctVMnx.png" alt="img"></p><p>下载成功后，把包通过 <code>xftp</code> 上传到服务器。</p><h5 id="4-3、解压"><a href="#4-3、解压" class="headerlink" title="4.3、解压"></a>4.3、解压</h5><p>解压文件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf harbor-offline-installer-v2.10.0.tgz </span><br></pre></td></tr></table></figure><h4 id="5、启动Harbor"><a href="#5、启动Harbor" class="headerlink" title="5、启动Harbor"></a>5、启动Harbor</h4><h5 id="5-1、修改配置文件"><a href="#5-1、修改配置文件" class="headerlink" title="5.1、修改配置文件"></a>5.1、修改配置文件</h5><p>复制<code>harbor.yml.tmpl</code> 文件并重命名为<code>harbor.yml</code>修改此配置文件，需要设置hostname、端口、数据库密码等。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> harbor.yml.tmpl harbor.yml <span class="comment">#拷贝</span></span><br><span class="line"></span><br><span class="line">vim harbor.yml</span><br></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改hostname的值，如果没有域名就使用本机IP地址</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.42</span><span class="number">.133</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置启动端口号</span></span><br><span class="line"><span class="comment"># http related config </span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="comment"># port for http, default is 80. If https enabled, this port will redirect to https port</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有申请证书，需要隐藏https</span></span><br><span class="line"><span class="comment">#https:</span></span><br><span class="line">  <span class="comment"># https port for harbor, default is 443</span></span><br><span class="line"><span class="comment">#  port: 443</span></span><br><span class="line">  <span class="comment"># The path of cert and key files for nginx</span></span><br><span class="line"><span class="comment">#  certificate: /your/certificate/path</span></span><br><span class="line"><span class="comment">#  private_key: /your/private/key/path</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动成功后，admin用户登录密码</span></span><br><span class="line"><span class="comment"># Remember Change the admin password from UI after launching Harbor.</span></span><br><span class="line"><span class="attr">harbor_admin_password:</span> <span class="string">AdminHarbor12345</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/02/16/uflyIABjz3amckh.png" alt="img"></p><h5 id="5-2、启动"><a href="#5-2、启动" class="headerlink" title="5.2、启动"></a>5.2、启动</h5><p>配置文件修改成功后，执行 <code>install.sh</code> 脚本进行安装harbor</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./install.sh </span><br></pre></td></tr></table></figure><p>启动报错：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Step 0]: checking if docker is installed ...</span><br><span class="line"></span><br><span class="line">Note: docker version: 26.1.3</span><br><span class="line"></span><br><span class="line">[Step 1]: checking docker-compose is installed ...</span><br><span class="line">/opt/harbor/common.sh: line 119: docker-compose: command not found</span><br><span class="line">✖ Failed to parse docker-compose version.</span><br></pre></td></tr></table></figure><p>可以看到，该服务器安装的 <code>docker</code> 没有安装 <code>docker-compose</code> 插件</p><h5 id="5-3、安装docker-compose"><a href="#5-3、安装docker-compose" class="headerlink" title="5.3、安装docker-compose"></a>5.3、安装docker-compose</h5><p>进入<code>docker-compose</code> 官网下载执行文件，地址： <a href="https://github.com/docker/compose">https://github.com/docker/compose</a> 下载成功后，把可执行文件加入<code>Linux</code> 系统命令目录</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> docker-compose-linux-x86_64 /usr/local/bin/</span><br></pre></td></tr></table></figure><p>重命名：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> docker-compose-linux-x86_64 docker-compose</span><br></pre></td></tr></table></figure><p>授权：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>执行命令查看是否安装成功：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><p>如果需要卸载，直接删除即可：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><h5 id="5-4、再次启动"><a href="#5-4、再次启动" class="headerlink" title="5.4、再次启动"></a>5.4、再次启动</h5><p>再次执行 <code>./install.sh</code></p><p><img src="https://s2.loli.net/2025/02/16/ilOpYecKCy7wGTZ.png" alt="img"></p><p>提示安装成功。接下来就可以访问Harbor了。访问IP+端口：<a href="http://192.168.42.133:5000/">http://192.168.42.133:5000</a><br><img src="https://s2.loli.net/2025/02/16/FrRKhnkacDUV8lG.png" alt="img"></p><p>访问成功，由于Harbor是通过docker管理的，所以启动非常方便。如果首页访问成功说明Docker私有仓库已经部署成功了。</p><h4 id="6、Harbor-Web页面操作说明"><a href="#6、Harbor-Web页面操作说明" class="headerlink" title="6、Harbor Web页面操作说明"></a>6、Harbor Web页面操作说明</h4><p>默认用户名是admin，密码是启动时设置的密码：<code>AdminHarbor12345</code></p><p><img src="https://s2.loli.net/2025/02/16/9SnuUoJsKBzCFpA.png" alt="img"></p><p>登录成功进入主页面了。从系统首页可以看到系统分为三个菜单：项目、日志、系统管理。</p><h5 id="6-1、项目"><a href="#6-1、项目" class="headerlink" title="6.1、项目"></a>6.1、项目</h5><p>项目管理顾名思义就是用来管理项目的。可以为每一个开发项目创建一个私有项目库，然后把Docker镜像存储到指定的项目中，为每个项目实现项目镜像隔离。创建项目的时候，Harbor提供了公开库（public repository）和私有库（private repository）两种类型的镜像存储空间。</p><p><img src="https://s2.loli.net/2025/02/16/F34W9pclPBSkQHa.png" alt="img"></p><p>通过详情信息可以看到：<strong>公开库中的镜像是对所有用户可见和可访问的，任何人都可以查看和拉取其中的镜像。而私有库中的镜像则需要登录才能访问控制，只有被授权的用户或团队才能够查看、拉取和推送镜像。</strong> 可以根据需要创建相关的项目。</p><p><img src="https://s2.loli.net/2025/02/16/l1pfKPiZngO9sXW.png" alt="img"></p><p>项目创建成功后，可以点击进入项目。在里面可以为每个项目单独设置不同的配置信息。可以为每一个项目添加成员信息。</p><p><img src="https://s2.loli.net/2025/02/16/yBMfu4NG6PHYxdX.png" alt="img"></p><p>角色权限说明：</p><ul><li>**项目管理员（Project Administrator）：**拥有项目的最高权限，可以对项目进行全面管理，包括创建和删除项目、管理项目成员和权限、配置项目属性、查看项目日志等。</li><li>**维护人员（Maintainer）：**类似于项目管理员，但权限稍低，通常用于协助管理项目，可以进行项目的部分管理操作，如添加和删除镜像、配置镜像的复制和同步规则等。</li><li>**开发者（Developer）：**具有对项目中镜像仓库的读写权限，可以拉取、推送和删除镜像，以及管理部分项目配置，但不能进行项目管理操作。</li><li>**访客（Guest）：**只具有对项目中镜像仓库的只读权限，可以查看镜像和元数据，但无法对镜像进行修改或删除操作。通常用于分享项目或镜像给外部团队或用户。</li><li>**受限访客（Restricted Guest）：**是一种更加受限的访客角色，通常用于提供给外部用户或系统，具有对项目中镜像仓库的只读权限，但可能会限制访问的部分内容或功能。</li></ul><p>在右上角显示推送命令，可以通过提示命令进行docker镜像推送。</p><p><img src="https://s2.loli.net/2025/02/16/RFEucUsbXL2jYyG.png" alt="img"></p><h5 id="6-2、日志"><a href="#6-2、日志" class="headerlink" title="6.2、日志"></a>6.2、日志</h5><p>日志菜单就是记录用户操作日志信息的。</p><p><img src="https://s2.loli.net/2025/02/16/B7HKfokDjcG4yNE.png" alt="img"></p><h5 id="6-3、系统管理"><a href="#6-3、系统管理" class="headerlink" title="6.3、系统管理"></a>6.3、系统管理</h5><p>系统管理主要用来管理Harbor用户人员信息、镜像仓库的各种配置、权限和系统设置。</p><p><img src="https://s2.loli.net/2025/02/16/KfL2ViA7z8JyWvT.png" alt="img"></p><h4 id="7、Docker命令使用私有仓库"><a href="#7、Docker命令使用私有仓库" class="headerlink" title="7、Docker命令使用私有仓库"></a>7、Docker命令使用私有仓库</h4><h5 id="7-1、登录"><a href="#7-1、登录" class="headerlink" title="7.1、登录"></a>7.1、登录</h5><p>首先登录私有仓库地址：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker login  -u admin -p AdminHarbor12345 http://192.168.42.133:5000</span><br></pre></td></tr></table></figure><p>会报错：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">Error response from daemon: Get <span class="string">&quot;https://192.168.42.133:5000/v2/&quot;</span>: proxyconnect tcp: dial tcp 192.168.65.7:3128: connect: connection refused</span><br></pre></td></tr></table></figure><p>docker认为这个地址是不安全的，所以需要在docker守护进程配置文件中把该地址加入安全范围。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://ejes884z.mirror.aliyuncs.com&quot;</span>],</span><br><span class="line">  <span class="string">&quot;log-driver&quot;</span>:<span class="string">&quot;json-file&quot;</span>,</span><br><span class="line">  <span class="string">&quot;log-opts&quot;</span>: &#123;<span class="string">&quot;max-size&quot;</span>:<span class="string">&quot;1g&quot;</span>, <span class="string">&quot;max-file&quot;</span>:<span class="string">&quot;3&quot;</span>&#125;,</span><br><span class="line">  <span class="string">&quot;live-restore&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;192.168.42.133:5000&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># insecure-registries 不安全的注册表配置一些不安全的地址信息，让Docker认为是安全的。多个地址使用 &quot;,&quot; 分割</span></span><br></pre></td></tr></table></figure><p>加入配置成功后，再次登录。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">WARNING! Your password will be stored unencrypted <span class="keyword">in</span> /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><p>通过输出发现登录成功。认证信息存储在 <code>~/.docker/config.json</code> 文件中，只要登录信息存在，登录会一直生效不需要每次推送拉取之前都登录。</p><h5 id="7-2、推送"><a href="#7-2、推送" class="headerlink" title="7.2、推送"></a>7.2、推送</h5><p>重新命名镜像名称</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker tag 94543a6c1aef 192.168.42.133:5000/blog_project/nginx:1.26.0</span><br></pre></td></tr></table></figure><p>推送</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker push 192.168.42.133:5000/blog_project/nginx:1.26.0</span><br></pre></td></tr></table></figure><p>查看Harbor仓库，推送成功。</p><p><img src="https://s2.loli.net/2025/02/16/rejyKzPso7aNGOw.png" alt="img"></p><h5 id="7-3、拉取"><a href="#7-3、拉取" class="headerlink" title="7.3、拉取"></a>7.3、拉取</h5><p>通过另一台服务器，使用 <code>docker pull</code>拉取镜像从私有仓库拉取镜像：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull 192.168.42.133:5000/blog_project/nginx:1.26.0</span><br></pre></td></tr></table></figure><p>拉取成功</p><p><img src="https://s2.loli.net/2025/02/16/VQRZWvfTwSmdIbj.png" alt="img"></p><p>查看下载数，发现已经更新了。</p><p><img src="https://s2.loli.net/2025/02/16/kmbMnuydhpYTw5a.png" alt="img"></p><h4 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h4><p>关于使用Harbor搭建Docker私有仓库就介绍完毕了，如果大家有兴趣可以查看一下其他搭建方式，然后在它们之间进行对比一下看看那种方式更适合。本篇为入门级Harbor的基础使用，其他功能可以自行研究。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;手把手教你搭建Docker私有仓库Harbor&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;本文搬运自：&lt;a href=&quot;https://www.cnblogs.com/sowler/p/18242819&quot;&gt;手把手教你搭建Docker私有仓库Harbor - sowler - 博客园&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A5-安装教程" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
    <category term="Docker" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/Docker/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="Harbor" scheme="https://kanoc.gitee.io/tags/Harbor/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu-强制修改密码为简单密码</title>
    <link href="https://kanoc.gitee.io/2025/02/15/ubuntu-%E5%BC%BA%E5%88%B6%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E4%B8%BA%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81/"/>
    <id>https://kanoc.gitee.io/2025/02/15/ubuntu-%E5%BC%BA%E5%88%B6%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E4%B8%BA%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81/</id>
    <published>2025-02-14T23:49:19.000Z</published>
    <updated>2025-06-10T01:05:43.745Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>ubuntu 强制修改密码为简单密码</strong></font></p><span id="more"></span><p>在 <code>Ubuntu</code> 中，出于安全考虑，系统通常会强制要求密码满足一定的复杂性和长度要求。默认情况下，root 密码必须至少包含 8 个字符。但是我们本地测试环境，不需要那么复杂的密码。越简单的密码越容易使用。</p><p>这个时候我们可以 使用 临时禁用密码复杂性检查来修改</p><h3 id="1-修改-PAM-配置"><a href="#1-修改-PAM-配置" class="headerlink" title="1. 修改 PAM 配置"></a>1. 修改 PAM 配置</h3><ol><li>打开终端。</li><li>编辑 PAM 密码策略配置：</li></ol><p>使用以下命令打开 common-password 文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/pam.d/common-password</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># passwordrequisitepam_pwquality.so retry=3  此为修改前的内容</span></span><br><span class="line">password requisite pam_unix.so nullok obscure min=0 max=8  <span class="comment"># 此为修改后的内容</span></span><br><span class="line">password[success=2 default=ignore]pam_unix.so obscure use_authtok try_first_pass yescrypt</span><br><span class="line">passwordsufficientpam_sss.so use_authtok</span><br><span class="line">passwordrequisitepam_deny.so</span><br><span class="line">passwordrequiredpam_permit.so</span><br><span class="line">passwordoptionalpam_gnome_keyring.so </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;ubuntu 强制修改密码为简单密码&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A5-安装教程" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
    <category term="ubuntu" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/ubuntu/"/>
    
    
    <category term="root" scheme="https://kanoc.gitee.io/tags/root/"/>
    
    <category term="密码" scheme="https://kanoc.gitee.io/tags/%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu安装配置docker</title>
    <link href="https://kanoc.gitee.io/2025/02/15/ubuntu%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEdocker/"/>
    <id>https://kanoc.gitee.io/2025/02/15/ubuntu%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEdocker/</id>
    <published>2025-02-14T23:18:23.000Z</published>
    <updated>2025-06-10T01:07:19.943Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>ubuntu安装配置docker</strong></font></p><span id="more"></span><h3 id="1-更新系统"><a href="#1-更新系统" class="headerlink" title="1. 更新系统"></a>1. 更新系统</h3><p>在 Ubuntu 中打开终端，更新系统：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt upgrade</span><br></pre></td></tr></table></figure><h3 id="2-安装-Snap"><a href="#2-安装-Snap" class="headerlink" title="2.  安装 Snap"></a>2.  安装 Snap</h3><p>如果你的系统尚未安装 Snap，可以使用以下命令安装：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install snapd</span><br></pre></td></tr></table></figure><h3 id="3-使用-Snap-安装-Docker"><a href="#3-使用-Snap-安装-Docker" class="headerlink" title="3. 使用 Snap 安装 Docker"></a>3. 使用 Snap 安装 Docker</h3><p>使用以下命令通过 Snap 安装 Docker：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> snap install docker</span><br></pre></td></tr></table></figure><h3 id="4-启动-Docker-服务"><a href="#4-启动-Docker-服务" class="headerlink" title="4. 启动 Docker 服务"></a>4. 启动 Docker 服务</h3><p>安装完成后，Docker 服务应该会自动启动。你可以使用以下命令检查 Docker 服务的状态：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl status snap.docker.dockerd</span><br></pre></td></tr></table></figure><p>如果服务没有运行，可以使用以下命令启动它：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start snap.docker.dockerd</span><br></pre></td></tr></table></figure><h3 id="4-配置国内镜像加速器-国外服务器忽略"><a href="#4-配置国内镜像加速器-国外服务器忽略" class="headerlink" title="4. 配置国内镜像加速器(国外服务器忽略)"></a>4. 配置国内镜像加速器(国外服务器忽略)</h3><ul><li><code>vim /etc/docker/daemon.json</code></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line"><span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://docker.mirrors.tuna.tsinghua.edu.cn&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://www.daocloud.io/mirror&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://mirror.ccs.tencentyun.com&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://hub-mirror.c.163.com&quot;</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-重启-docker服务"><a href="#5-重启-docker服务" class="headerlink" title="5. 重启 docker服务"></a>5. 重启 docker服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="6-验证-Docker-安装"><a href="#6-验证-Docker-安装" class="headerlink" title="6. 验证 Docker 安装"></a>6. 验证 Docker 安装</h3><p>运行以下命令以验证 Docker 是否安装成功：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker --version</span><br></pre></td></tr></table></figure><h3 id="7-运行-Docker-Hello-World-示例"><a href="#7-运行-Docker-Hello-World-示例" class="headerlink" title="7. 运行 Docker Hello World 示例"></a>7. 运行 Docker Hello World 示例</h3><p>为了确保 Docker 正常工作，可以运行一个简单的 Hello World 容器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run hello-world</span><br></pre></td></tr></table></figure><p>如果一切正常，你将看到一条消息，表明 Docker 已成功安装并运行。</p><h3 id="8-（可选）将用户添加到-Docker-组"><a href="#8-（可选）将用户添加到-Docker-组" class="headerlink" title="8. （可选）将用户添加到 Docker 组"></a>8. （可选）将用户添加到 Docker 组</h3><p>如果你希望在不使用 sudo 的情况下运行 Docker 命令，可以将你的用户添加到 Docker 组：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p>添加后，注销并重新登录，或者重启系统以使更改生效。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过 Snap 安装 Docker 是一种简单的方法，适合在 Ubuntu 上快速部署 Docker。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;ubuntu安装配置docker&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A5-安装教程" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
    <category term="ubuntu" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/ubuntu/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="安装" scheme="https://kanoc.gitee.io/tags/%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu-共享文件夹_samba</title>
    <link href="https://kanoc.gitee.io/2025/02/15/ubuntu-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9-samba/"/>
    <id>https://kanoc.gitee.io/2025/02/15/ubuntu-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9-samba/</id>
    <published>2025-02-14T23:08:39.000Z</published>
    <updated>2025-06-10T01:05:46.218Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>ubuntu 共享文件夹 For samba</strong></font></p><span id="more"></span><p>在 Ubuntu 中共享文件夹可以通过多种方式实现，最常见的方法是使用 Samba（适用于 Windows 和 Linux 之间的共享）或 NFS（适用于 Linux 之间的共享）。以下是这两种方法的详细步骤。</p><h3 id="方法-1：使用-Samba-共享文件夹"><a href="#方法-1：使用-Samba-共享文件夹" class="headerlink" title="方法 1：使用 Samba 共享文件夹"></a>方法 1：使用 Samba 共享文件夹</h3><h4 id="1-安装-Samba"><a href="#1-安装-Samba" class="headerlink" title="1. 安装 Samba"></a>1. 安装 Samba</h4><p>首先，确保你的系统已安装 Samba。打开终端并运行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install samba</span><br></pre></td></tr></table></figure><h4 id="2-创建共享文件夹"><a href="#2-创建共享文件夹" class="headerlink" title="2. 创建共享文件夹"></a>2. 创建共享文件夹</h4><p>选择一个目录作为共享文件夹，或者创建一个新的文件夹。例如，创建一个名为 shared 的文件夹：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/shared</span><br></pre></td></tr></table></figure><h4 id="3-配置-Samba"><a href="#3-配置-Samba" class="headerlink" title="3. 配置 Samba"></a>3. 配置 Samba</h4><p>编辑 Samba 配置文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/samba/smb.conf</span><br></pre></td></tr></table></figure><p>在文件的末尾添加以下内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 [global] 部分中，添加或修改以下设置：  开启全速</span></span><br><span class="line"> [global]</span><br><span class="line">   max connections = 100  <span class="comment"># 增加并发性能</span></span><br><span class="line">   max open files = 10000  <span class="comment"># 增加并发性能</span></span><br><span class="line">   <span class="comment"># 性能优化设置</span></span><br><span class="line">   socket options = TCP_NODELAY SO_RCVBUF=8192 SO_SNDBUF=8192</span><br><span class="line">   max protocol = SMB3</span><br><span class="line">   min protocol = SMB2</span><br><span class="line">   </span><br><span class="line">[MyFiles]</span><br><span class="line">   path = /home/kate/SambaFiles</span><br><span class="line">   available = <span class="built_in">yes</span></span><br><span class="line">   valid <span class="built_in">users</span> = root</span><br><span class="line">   <span class="built_in">read</span> only = no</span><br><span class="line">   browsable = <span class="built_in">yes</span></span><br><span class="line">   public = <span class="built_in">yes</span></span><br><span class="line">   writable = <span class="built_in">yes</span></span><br><span class="line">   create mask = 0755</span><br><span class="line">   directory mask = 0755</span><br></pre></td></tr></table></figure><p>请将 your_username 替换为你的实际用户名。</p><h4 id="4-设置-Samba-用户"><a href="#4-设置-Samba-用户" class="headerlink" title="4. 设置 Samba 用户"></a>4. 设置 Samba 用户</h4><p>为 Samba 设置用户密码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> smbpasswd -a your_username</span><br></pre></td></tr></table></figure><h4 id="5-重启-Samba-服务"><a href="#5-重启-Samba-服务" class="headerlink" title="5. 重启 Samba 服务"></a>5. 重启 Samba 服务</h4><p>重启 Samba 服务以使更改生效：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart smbd</span><br></pre></td></tr></table></figure><h4 id="6-访问共享文件夹"><a href="#6-访问共享文件夹" class="headerlink" title="6. 访问共享文件夹"></a>6. 访问共享文件夹</h4><p>在 Windows 系统中，你可以通过以下方式访问共享文件夹：</p><ol><li>打开文件资源管理器。</li></ol><p>在地址栏中输入 \your_ubuntu_ip\SharedFolder，将 your_ubuntu_ip 替换为 Ubuntu 机器的 IP 地址。</p><p>输入 Samba 用户名和密码进行访问。</p><h3 id="方法-2：使用-NFS-共享文件夹"><a href="#方法-2：使用-NFS-共享文件夹" class="headerlink" title="方法 2：使用 NFS 共享文件夹"></a>方法 2：使用 NFS 共享文件夹</h3><p>NFS（网络文件系统）适用于 Linux 之间的共享。</p><h4 id="1-安装-NFS"><a href="#1-安装-NFS" class="headerlink" title="1. 安装 NFS"></a>1. 安装 NFS</h4><p>首先，确保你的系统已安装 NFS：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install nfs-kernel-server</span><br></pre></td></tr></table></figure><h4 id="2-创建共享文件夹-1"><a href="#2-创建共享文件夹-1" class="headerlink" title="2. 创建共享文件夹"></a>2. 创建共享文件夹</h4><p>选择一个目录作为共享文件夹，或者创建一个新的文件夹。例如，创建一个名为 shared 的文件夹：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/shared</span><br></pre></td></tr></table></figure><h4 id="3-配置-NFS"><a href="#3-配置-NFS" class="headerlink" title="3. 配置 NFS"></a>3. 配置 NFS</h4><p>编辑 NFS 配置文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/exports</span><br></pre></td></tr></table></figure><p>在文件中添加以下行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/your_username/shared *(rw,<span class="built_in">sync</span>,no_subtree_check)</span><br></pre></td></tr></table></figure><p>请将 your_username 替换为你的实际用户名。</p><h4 id="4-重启-NFS-服务"><a href="#4-重启-NFS-服务" class="headerlink" title="4. 重启 NFS 服务"></a>4. 重启 NFS 服务</h4><p>重启 NFS 服务以使更改生效：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> exportfs -a</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart nfs-kernel-server</span><br></pre></td></tr></table></figure><h4 id="5-访问共享文件夹"><a href="#5-访问共享文件夹" class="headerlink" title="5. 访问共享文件夹"></a>5. 访问共享文件夹</h4><p>在另一台 Linux 机器上，你可以通过以下命令挂载 NFS 共享：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mount your_ubuntu_ip:/home/your_username/shared /mnt</span><br></pre></td></tr></table></figure><p>将 your_ubuntu_ip 替换为 Ubuntu 机器的 IP 地址，&#x2F;mnt 是你希望挂载的本地目录。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上步骤，你可以在 Ubuntu 中共享文件夹。选择 Samba 或 NFS 取决于你的需求和网络环境。如果在配置或使用过程中遇到任何问题，请提供具体的错误信息，以便进一步排查。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;ubuntu 共享文件夹 For samba&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A5-安装教程" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
    <category term="ubuntu" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/ubuntu/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="文件夹共享" scheme="https://kanoc.gitee.io/tags/%E6%96%87%E4%BB%B6%E5%A4%B9%E5%85%B1%E4%BA%AB/"/>
    
    <category term="挂载" scheme="https://kanoc.gitee.io/tags/%E6%8C%82%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>nodejs部署后端项目教程</title>
    <link href="https://kanoc.gitee.io/2024/12/13/nodejs%E9%83%A8%E7%BD%B2%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/"/>
    <id>https://kanoc.gitee.io/2024/12/13/nodejs%E9%83%A8%E7%BD%B2%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/</id>
    <published>2024-12-13T09:28:45.000Z</published>
    <updated>2025-06-09T13:05:53.014Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>nodejs部署后端项目教程(以部署图片压缩接口为例)</strong></font></p><span id="more"></span><p>这里我们将使用 Node.js 和 Express 框架来构建后端，并使用 <code>sharp</code> 库来进行图片压缩。</p><p>首先，确保你已经安装了 Node.js 和 npm。然后，创建一个新的项目目录，并初始化一个新的 Node.js 项目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> image-compressor-backend</span><br><span class="line"><span class="built_in">cd</span> image-compressor-backend</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>接下来，安装所需的依赖项：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install express sharp multer</span><br></pre></td></tr></table></figure><p>然后，创建一个 <code>server.js</code> 文件，并添加以下代码来构建后端服务：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> sharp = <span class="built_in">require</span>(<span class="string">&#x27;sharp&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">&#x27;multer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3001</span>; <span class="comment">// 确保与前端通信的端口不同</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置 multer 存储配置</span></span><br><span class="line"><span class="keyword">const</span> storage = multer.<span class="title function_">memoryStorage</span>();</span><br><span class="line"><span class="keyword">const</span> upload = <span class="title function_">multer</span>(&#123; <span class="attr">storage</span>: storage &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 处理图片压缩请求</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/compress&#x27;</span>, upload.<span class="title function_">single</span>(<span class="string">&#x27;image&#x27;</span>), <span class="title function_">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> file = req.<span class="property">file</span>;</span><br><span class="line">  <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">send</span>(<span class="string">&#x27;No file uploaded.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">const</span> quality = <span class="built_in">parseInt</span>(req.<span class="property">body</span>.<span class="property">quality</span>, <span class="number">10</span>) || <span class="number">80</span>; <span class="comment">// 默认质量为80%</span></span><br><span class="line">  <span class="keyword">const</span> maxWidth = <span class="built_in">parseInt</span>(req.<span class="property">body</span>.<span class="property">maxWidth</span>, <span class="number">10</span>) || <span class="number">2000</span>;</span><br><span class="line">  <span class="keyword">const</span> maxHeight = <span class="built_in">parseInt</span>(req.<span class="property">body</span>.<span class="property">maxHeight</span>, <span class="number">10</span>) || <span class="number">2000</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 sharp 进行图片压缩</span></span><br><span class="line">    <span class="keyword">const</span> compressedBuffer = <span class="keyword">await</span> <span class="title function_">sharp</span>(file.<span class="property">buffer</span>)</span><br><span class="line">      .<span class="title function_">resize</span>(&#123; <span class="attr">width</span>: maxWidth, <span class="attr">height</span>: maxHeight, <span class="attr">fit</span>: <span class="string">&#x27;inside&#x27;</span>, <span class="attr">withoutEnlargement</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">      .<span class="title function_">jpeg</span>(&#123; <span class="attr">quality</span>: quality &#125;)</span><br><span class="line">      .<span class="title function_">toBuffer</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置响应头并发送压缩后的图片</span></span><br><span class="line">    res.<span class="title function_">set</span>(&#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;image/jpeg&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Content-Length&#x27;</span>: compressedBuffer.<span class="property">length</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    res.<span class="title function_">send</span>(compressedBuffer);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error compressing image:&#x27;</span>, error);</span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;Error compressing image.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server is running at http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个后端服务监听在端口 3001 上，并提供了一个 <code>/compress</code> 路由来处理图片压缩请求。它使用 <code>multer</code> 中间件来处理文件上传，并使用 <code>sharp</code> 库来进行图片压缩。</p><p>前端代码需要稍作修改以与这个后端服务配合。特别是，<code>compressFile</code> 函数需要发送一个请求到后端来压缩图片。这里是一个修改后的 <code>compressFile</code> 函数示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设你有一个字典来存储文件名和对应的文件对象</span></span><br><span class="line">files = &#123;</span><br><span class="line">    <span class="string">&#x27;example.jpg&#x27;</span>: <span class="built_in">open</span>(<span class="string">&#x27;path/to/example.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compress_file</span>(<span class="params">file_name</span>):</span><br><span class="line">    file_data = files.get(file_name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> file_data:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取质量值（这里假设是从某个地方获取的，比如用户输入）</span></span><br><span class="line">    quality = <span class="number">80</span>  <span class="comment"># 示例值，你可以从UI或其他地方获取这个值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置最大宽度和高度</span></span><br><span class="line">    max_width = <span class="number">2000</span></span><br><span class="line">    max_height = <span class="number">2000</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建表单数据</span></span><br><span class="line">    form_data = &#123;</span><br><span class="line">        <span class="string">&#x27;image&#x27;</span>: file_data,</span><br><span class="line">        <span class="string">&#x27;quality&#x27;</span>: quality,</span><br><span class="line">        <span class="string">&#x27;maxWidth&#x27;</span>: max_width,</span><br><span class="line">        <span class="string">&#x27;maxHeight&#x27;</span>: max_height</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 发送POST请求</span></span><br><span class="line">        response = requests.post(<span class="string">&#x27;http://localhost:3001/compress&#x27;</span>, files=form_data)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查响应状态码</span></span><br><span class="line">        <span class="keyword">if</span> response.status_code != <span class="number">200</span>:</span><br><span class="line">            response.raise_for_status()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取压缩后的图像数据</span></span><br><span class="line">        compressed_image_data = response.content</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将图像数据保存为文件</span></span><br><span class="line">        compressed_file_name = <span class="string">&#x27;compressed-&#x27;</span> + file_name</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(compressed_file_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> compressed_file:</span><br><span class="line">            compressed_file.write(compressed_image_data)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新文件字典（如果需要）</span></span><br><span class="line">        files[file_name] = &#123;</span><br><span class="line">            <span class="string">&#x27;original&#x27;</span>: file_data,</span><br><span class="line">            <span class="string">&#x27;compressed&#x27;</span>: <span class="built_in">open</span>(compressed_file_name, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新文件列表（这个函数需要你根据实际需求实现）</span></span><br><span class="line">        update_file_list()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> requests.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;压缩 <span class="subst">&#123;file_name&#125;</span> 失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例调用</span></span><br><span class="line">compress_file(<span class="string">&#x27;example.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：这个函数需要在适当的地方被调用，并且需要确保文件路径和服务器地址是正确的。</span></span><br></pre></td></tr></table></figure><p>请注意，这个示例假设前端和后端运行在同一个域下，或者你已经配置了 CORS（跨源资源共享）来允许前端与后端通信。如果你遇到跨域问题，你可能需要在后端添加适当的 CORS 头。</p><p>现在，当你运行后端服务器并使用前端页面上传和压缩图片时，前端会将图片发送到后端的 <code>/compress</code> 路由，后端会使用 <code>sharp</code> 库进行压缩，并将压缩后的图片发送回前端。前端然后会显示压缩后的图片，并提供下载选项。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;nodejs部署后端项目教程(以部署图片压缩接口为例)&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A2-前端" scheme="https://kanoc.gitee.io/categories/A2-%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Nodejs" scheme="https://kanoc.gitee.io/categories/A2-%E5%89%8D%E7%AB%AF/Nodejs/"/>
    
    
    <category term="教程" scheme="https://kanoc.gitee.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="服务器" scheme="https://kanoc.gitee.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="nodejs" scheme="https://kanoc.gitee.io/tags/nodejs/"/>
    
    <category term="后端" scheme="https://kanoc.gitee.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>django配置ASGI服务器教程</title>
    <link href="https://kanoc.gitee.io/2024/12/09/django%E9%85%8D%E7%BD%AEASGI%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://kanoc.gitee.io/2024/12/09/django%E9%85%8D%E7%BD%AEASGI%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B/</id>
    <published>2024-12-08T19:08:44.000Z</published>
    <updated>2025-06-09T08:38:17.116Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>django配置ASGI服务器教程</strong></font></p><span id="more"></span><h1 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h1><ul><li><p>系统环境：Alibaba3</p></li><li><p>Python版本：<code>3.13</code></p></li><li><p>Django版本：<code>5.1.4</code></p></li><li><p>uvicorn版本：<code>0.32.1</code></p></li></ul><h2 id="1、安装-uvicorn-服务器"><a href="#1、安装-uvicorn-服务器" class="headerlink" title="1、安装 uvicorn 服务器"></a>1、安装 <strong>uvicorn</strong> 服务器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install django uvicorn</span><br></pre></td></tr></table></figure><h3 id="2、创建ASGI应用程序"><a href="#2、创建ASGI应用程序" class="headerlink" title="2、创建ASGI应用程序"></a>2、创建ASGI应用程序</h3><p>在Django 3.0及更高版本中，Django默认提供了一个<code>asgi.py</code>文件，该文件位于与<code>wsgi.py</code>相同的位置（通常是项目的主目录下）。这个文件包含了一个ASGI应用程序的实例，你可以直接使用它。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> django.core.asgi <span class="keyword">import</span> get_asgi_application</span><br><span class="line"></span><br><span class="line">os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="string">&#x27;&lt;your_project_name&gt;.settings&#x27;</span>)  <span class="comment"># &lt;your_project_name&gt; 替换成你的项目</span></span><br><span class="line">application = get_asgi_application()</span><br></pre></td></tr></table></figure><h2 id="3、设置settings-py"><a href="#3、设置settings-py" class="headerlink" title="3、设置settings.py"></a>3、设置settings.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># WSGI_APPLICATION = &#x27;&lt;your_project_name&gt;.wsgi.application&#x27;   # 同步请求 直接注销掉 我们不需要</span></span><br><span class="line">ASGI_APPLICATION = <span class="string">&#x27;&lt;your_project_name&gt;.asgi.application&#x27;</span>   <span class="comment"># 异步项目  将 &lt;your_project_name&gt; 替换成你的项目</span></span><br></pre></td></tr></table></figure><h3 id="4、-安装并运行ASGI服务器"><a href="#4、-安装并运行ASGI服务器" class="headerlink" title="4、 安装并运行ASGI服务器"></a>4、 安装并运行ASGI服务器</h3><p>要运行ASGI应用，你需要安装一个<code>ASGI</code>服务器，如<code>Uvicorn</code>、<code>Daphne</code>或<code>Hypercorn</code>。然后，你可以使用这些服务器来启动你的<code>Django</code>应用。例如，使用<code>Uvicorn</code>启动<code>Django</code>应用的命令可能看起来像这样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uvicorn your_project_name.asgi:application   # 默认启动  访问地址为  http://127.0.0.1:8000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以自己指定端口</span></span><br><span class="line">uvicorn your_project_name.asgi:application --host <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> --port <span class="number">8035</span>    <span class="comment"># 指定所有ip可访问 项目运行端口为 8035</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;django配置ASGI服务器教程&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://kanoc.gitee.io/categories/Python/"/>
    
    <category term="Django" scheme="https://kanoc.gitee.io/categories/Python/Django/"/>
    
    
    <category term="django" scheme="https://kanoc.gitee.io/tags/django/"/>
    
    <category term="python" scheme="https://kanoc.gitee.io/tags/python/"/>
    
    <category term="ASGI服务器" scheme="https://kanoc.gitee.io/tags/ASGI%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="异步WEB" scheme="https://kanoc.gitee.io/tags/%E5%BC%82%E6%AD%A5WEB/"/>
    
  </entry>
  
</feed>
