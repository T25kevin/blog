<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://kanoc.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://kanoc.gitee.io/"/>
  <updated>2025-03-14T07:37:16.752Z</updated>
  <id>https://kanoc.gitee.io/</id>
  
  <author>
    <name>Kanoc Ge</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker-Volume-数据持久化方案</title>
    <link href="https://kanoc.gitee.io/2025/03/14/Docker-Volume-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <id>https://kanoc.gitee.io/2025/03/14/Docker-Volume-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88/</id>
    <published>2025-03-14T07:19:50.000Z</published>
    <updated>2025-03-14T07:37:16.752Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Docker Volume 数据持久化方案：</strong></font></p><span id="more"></span><h3 id="使用-Docker-Volume-代替直接挂载"><a href="#使用-Docker-Volume-代替直接挂载" class="headerlink" title="使用 Docker Volume 代替直接挂载"></a>使用 Docker Volume 代替直接挂载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建 volume</span></span><br><span class="line">docker volume create mongo_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">docker run -d --restart=always -p 27017:27017 --name mymongo -v volume:/data/db -e MONGO_LOG_MAX_SIZE=5242880 mongo:latest --wiredTigerCacheSizeGB 1 --auth</span><br></pre></td></tr></table></figure><h3 id="查看-Volume-物理路径（MacOS）"><a href="#查看-Volume-物理路径（MacOS）" class="headerlink" title="查看 Volume 物理路径（MacOS）"></a>查看 Volume 物理路径（MacOS）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume inspect mongo_data</span><br></pre></td></tr></table></figure><h4 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a>输出示例：</h4><p>实际数据存储在 Docker 虚拟机中，避免直接操作宿主机文件系统。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;<span class="number">2025</span>-<span class="number">03</span>-<span class="number">14</span>T05:XX:XXZ&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/mongo_data/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;mongo_data&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="进入mongo容器"><a href="#进入mongo容器" class="headerlink" title="进入mongo容器"></a>进入<code>mongo</code>容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mymongo /bin/bash</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/03/14/DZOC8ImKc2T59G3.png" alt="image"></p><p>注意：这里的mymongo是容器的名字，不是镜像的名字。（忘记容器名字，可使用docker ps -a 查看容器名）<br><img src="https://s2.loli.net/2025/03/14/V7NiL5AWElx16va.png" alt="image"><br>2.3.2.进入<code>mongosh</code>中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入mongo shell</span></span><br><span class="line">mongosh</span><br></pre></td></tr></table></figure><p>注：<code>mongosh 6.0</code>版本之后使用，<code>mongo 6.0</code>版本之前使用，博主就是在这里出问题的，博主安装最新<code>mongodb</code>版本，但是使用的是 <code>mongo</code> 所以一直出现问题：<code>bash: mongo: command not found</code><br><img src="https://s2.loli.net/2025/03/14/9VQ3fFU5I4BJXe8.png" alt="image"></p><p><img src="https://s2.loli.net/2025/03/14/FPByZHwLNp7dRUv.png" alt="image"><br>2.3.3.进入<code>admin</code>数据库</p><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> admin</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/03/14/McbuCipRfOx1e3o.png" alt="image"><br>2.3.4 创建一个用户，<code>mongodb</code>默认没有用户</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.这里创建用户名为root，密码为mongo2023，角色（该用户的权限）为root，数据库为admin（你们按照你们自己的设置）</span></span><br><span class="line"><span class="comment"># 用户名：root，密码：mongo2023，角色：root，数据库：admin</span></span><br><span class="line"></span><br><span class="line">db.createUser(&#123;user:<span class="string">&#x27;root&#x27;</span>,<span class="built_in">pwd</span>:<span class="string">&#x27;mongo2023&#x27;</span>,roles:[&#123;role:<span class="string">&#x27;root&#x27;</span>,db:<span class="string">&#x27;admin&#x27;</span>&#125;]&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.认证登录db.auth(&#x27;用户名&#x27;,&#x27;密码&#x27;)，打印1则代表认证通过</span></span><br><span class="line">db.auth(<span class="string">&#x27;root&#x27;</span>,<span class="string">&#x27;mongo2023&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/03/14/KWStwbdhveoZOYU.png" alt="image"><br>到这里就完成了创建用户和设置密码，如果要退出 Ctrl+D 或者 exit 退出mongodb</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Docker Volume 数据持久化方案：&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://kanoc.gitee.io/categories/Docker/"/>
    
    <category term="mongodb" scheme="https://kanoc.gitee.io/categories/Docker/mongodb/"/>
    
    
    <category term="数据库" scheme="https://kanoc.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="持久化" scheme="https://kanoc.gitee.io/tags/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Docker部署Mongodb_错误收集</title>
    <link href="https://kanoc.gitee.io/2025/03/14/Docker%E9%83%A8%E7%BD%B2Mongodb_%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/"/>
    <id>https://kanoc.gitee.io/2025/03/14/Docker%E9%83%A8%E7%BD%B2Mongodb_%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/</id>
    <published>2025-03-13T23:02:39.000Z</published>
    <updated>2025-03-14T04:52:13.259Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong><strong>Docker部署Mongodb_错误收集</strong></strong></font></p><span id="more"></span><h3 id="WiredTiger-存储引擎无法正常访问数据文件"><a href="#WiredTiger-存储引擎无法正常访问数据文件" class="headerlink" title="WiredTiger 存储引擎无法正常访问数据文件"></a><strong>WiredTiger 存储引擎无法正常访问数据文件</strong></h3><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h3><h4 id="1-彻底清理残留数据文件"><a href="#1-彻底清理残留数据文件" class="headerlink" title="1. 彻底清理残留数据文件"></a>1. 彻底清理残留数据文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止并删除旧容器</span></span><br><span class="line">docker stop mongo &amp;&amp; docker <span class="built_in">rm</span> mongo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除宿主机映射目录中的所有文件（谨慎操作！先备份重要数据）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /path/to/your/mongodb_data/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写创建文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> /path/to/your/mongodb_data</span><br></pre></td></tr></table></figure><h4 id="2-确保目录权限正确（MacOS-特殊配置）"><a href="#2-确保目录权限正确（MacOS-特殊配置）" class="headerlink" title="2. 确保目录权限正确（MacOS 特殊配置）"></a>2. 确保目录权限正确（MacOS 特殊配置）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 授予容器用户（UID 999）写权限（MacOS需通过 ACL 配置）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> -R 777 /path/to/your/mongodb_data</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R $(<span class="built_in">whoami</span>) /path/to/your/mongodb_data</span><br></pre></td></tr></table></figure><h4 id="3-调整-Docker-运行命令（关键参数优化）"><a href="#3-调整-Docker-运行命令（关键参数优化）" class="headerlink" title="3. 调整 Docker 运行命令（关键参数优化）"></a>3. 调整 Docker 运行命令（关键参数优化）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mongo \</span><br><span class="line">  -p 27017:27017 \</span><br><span class="line">  -v /path/to/your/mongodb_data:/data/db \</span><br><span class="line">  -e MONGO_INITDB_ROOT_USERNAME=admin \</span><br><span class="line">  -e MONGO_INITDB_ROOT_PASSWORD=admin \</span><br><span class="line">  --user 1000:50 \  <span class="comment"># MacOS Docker 特殊 UID 配置</span></span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  mongo:latest \</span><br><span class="line">  --wiredTigerCacheSizeGB 1  <span class="comment"># 限制缓存大小适配小内存环境</span></span><br></pre></td></tr></table></figure><h4 id="4-验证容器日志"><a href="#4-验证容器日志" class="headerlink" title="4. 验证容器日志"></a>4. 验证容器日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs -f mongo</span><br></pre></td></tr></table></figure><p>预期看到：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;t&quot;:&#123;&quot;$date&quot;:&quot;2025-03-14T05:XX:XX.XXXZ&quot;&#125;,&quot;s&quot;:&quot;I&quot;,&quot;c&quot;:&quot;STORAGE&quot;,&quot;id&quot;:22430,&quot;ctx&quot;:&quot;initandlisten&quot;,&quot;msg&quot;:&quot;WiredTiger message&quot;,&quot;attr&quot;:&#123;&quot;message&quot;:&quot;WT_SESSION.create...&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="关键配置解析"><a href="#关键配置解析" class="headerlink" title="关键配置解析"></a><strong>关键配置解析</strong></h3><table><thead><tr><th align="left"><strong>参数</strong></th><th align="left"><strong>作用说明</strong></th></tr></thead><tbody><tr><td align="left"><code>--user 1000:50</code></td><td align="left">强制容器以 MacOS 当前用户（UID 1000）和 Docker 默认组（GID 50）运行</td></tr><tr><td align="left"><code>--wiredTigerCacheSizeGB 1</code></td><td align="left">显式限制 WiredTiger 缓存为 1GB，避免内存不足导致崩溃</td></tr><tr><td align="left"><code>chmod 777</code></td><td align="left">临时赋予完全权限（生产环境不推荐，开发环境可用）</td></tr><tr><td align="left"><code>rm -rf</code></td><td align="left">清除可能存在的损坏文件或权限冲突文件</td></tr></tbody></table><hr><h3 id="故障深度分析"><a href="#故障深度分析" class="headerlink" title="故障深度分析"></a><strong>故障深度分析</strong></h3><h4 id="错误日志解读"><a href="#错误日志解读" class="headerlink" title="错误日志解读"></a><strong>错误日志解读</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;msg&quot;:&quot;__posix_open_file:924:/data/db/WiredTiger.wt: handle-open: open&quot;,&quot;error_str&quot;:&quot;Operation not permitted&quot;</span><br></pre></td></tr></table></figure><p>表明 MongoDB 进程对 <code>/data/db/WiredTiger.wt</code> 文件 <strong>没有写权限</strong> 或 <strong>文件已被锁定</strong>。</p><h4 id="MacOS-特殊限制"><a href="#MacOS-特殊限制" class="headerlink" title="MacOS 特殊限制"></a><strong>MacOS 特殊限制</strong></h4><ul><li>Docker Desktop 使用虚拟机挂载文件系统（gRPC-FUSE），存在权限映射问题</li><li>MacOS 原生文件系统（APFS）与 Linux 容器权限模型不兼容</li></ul><hr><h3 id="高级方案（生产环境推荐）"><a href="#高级方案（生产环境推荐）" class="headerlink" title="高级方案（生产环境推荐）"></a><strong>高级方案（生产环境推荐）</strong></h3><h4 id="使用-Docker-Volume-代替直接挂载"><a href="#使用-Docker-Volume-代替直接挂载" class="headerlink" title="使用 Docker Volume 代替直接挂载"></a>使用 Docker Volume 代替直接挂载</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建 volume</span></span><br><span class="line">docker volume create mongo_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">docker run -d \</span><br><span class="line">  -v mongo_data:/data/db \</span><br><span class="line">  mongo:latest</span><br></pre></td></tr></table></figure><h4 id="查看-Volume-物理路径（MacOS）"><a href="#查看-Volume-物理路径（MacOS）" class="headerlink" title="查看 Volume 物理路径（MacOS）"></a>查看 Volume 物理路径（MacOS）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume inspect mongo_data</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-03-14T05:XX:XXZ&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Mountpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/mongo_data/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mongo_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>实际数据存储在 Docker 虚拟机中，避免直接操作宿主机文件系统。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol><li><strong>开发环境</strong>：使用 <code>chmod 777</code> 快速修复权限，清理残留文件</li><li><strong>生产环境</strong>：<ul><li>使用 Docker Volume 避免路径映射问题</li><li>通过 <code>docker exec</code> 进入容器检查文件权限</li><li>定期备份 Volume 数据 (<code>docker cp</code> 或专用备份工具)</li></ul></li></ol><p>通过以上方案，可彻底解决因文件权限导致的 MongoDB 启动失败问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;&lt;strong&gt;Docker部署Mongodb_错误收集&lt;/strong&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://kanoc.gitee.io/categories/Docker/"/>
    
    <category term="数据库" scheme="https://kanoc.gitee.io/categories/Docker/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="mongodb" scheme="https://kanoc.gitee.io/tags/mongodb/"/>
    
    <category term="数据库" scheme="https://kanoc.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>正在运行的-Docker-容器打包镜像方法</title>
    <link href="https://kanoc.gitee.io/2025/02/28/%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84-Docker-%E5%AE%B9%E5%99%A8%E6%89%93%E5%8C%85%E9%95%9C%E5%83%8F%E6%96%B9%E6%B3%95/"/>
    <id>https://kanoc.gitee.io/2025/02/28/%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84-Docker-%E5%AE%B9%E5%99%A8%E6%89%93%E5%8C%85%E9%95%9C%E5%83%8F%E6%96%B9%E6%B3%95/</id>
    <published>2025-02-27T17:16:05.000Z</published>
    <updated>2025-02-27T17:21:41.905Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>正在运行的-Docker-容器打包镜像方法</strong></font></p><span id="more"></span><h4 id="‌1-使用-docker-commit-命令直接打包‌"><a href="#‌1-使用-docker-commit-命令直接打包‌" class="headerlink" title="‌1. 使用 docker commit 命令直接打包‌"></a>‌<strong>1. 使用 <code>docker commit</code> 命令直接打包</strong>‌</h4><p>‌<strong>适用场景</strong>‌：快速保存当前容器的运行状态为镜像，适合临时调试或快速迁移。<br>‌<strong>步骤</strong>‌：</p><ol><li><p>‌<strong>获取容器 ID</strong>‌</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps  <span class="comment"># 查看正在运行的容器，记录目标容器的 ID ‌:ml-citation&#123;ref=&quot;1,3&quot; data=&quot;citationList&quot;&#125;  </span></span><br></pre></td></tr></table></figure></li><li><p>‌<strong>提交容器为新镜像</strong>‌</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit &lt;容器ID&gt; &lt;新镜像名&gt;:&lt;标签&gt;  <span class="comment"># 例如：docker commit abc123 my-app:v1 ‌:ml-citation&#123;ref=&quot;1,2&quot; data=&quot;citationList&quot;&#125;  </span></span><br></pre></td></tr></table></figure></li><li><p>‌<strong>验证镜像是否生成</strong>‌</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images  <span class="comment"># 检查列表中是否包含新镜像 :ml-citation&#123;ref=&quot;2,3&quot; data=&quot;citationList&quot;&#125;  </span></span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="‌2-导出镜像为可迁移文件‌"><a href="#‌2-导出镜像为可迁移文件‌" class="headerlink" title="‌2. 导出镜像为可迁移文件‌"></a>‌<strong>2. 导出镜像为可迁移文件</strong>‌</h4><p>‌<strong>适用场景</strong>‌：将镜像保存为 <code>.tar</code> 文件，便于传输或备份。<br>‌<strong>步骤</strong>‌：</p><ol><li><p>‌<strong>导出镜像为 <code>.tar</code> 文件</strong>‌</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o &lt;文件名&gt;.tar &lt;镜像名&gt;:&lt;标签&gt;  <span class="comment"># 例如：docker save -o my-app.tar my-app:v1 ‌:ml-citation&#123;ref=&quot;4,5&quot; data=&quot;citationList&quot;&#125;  </span></span><br></pre></td></tr></table></figure></li><li><p>‌<strong>在目标服务器导入镜像</strong>‌</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i &lt;文件名&gt;.tar  <span class="comment"># 从 `.tar` 文件恢复镜像 :ml-citation&#123;ref=&quot;4,5&quot; data=&quot;citationList&quot;&#125;  </span></span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="‌3-其他注意事项‌"><a href="#‌3-其他注意事项‌" class="headerlink" title="‌3. 其他注意事项‌"></a>‌<strong>3. 其他注意事项</strong>‌</h4><ul><li><p>‌**<code>docker commit</code> 的局限性**‌</p><ul><li>此方法生成的镜像缺乏构建过程的透明性，难以追溯修改历史，不推荐用于生产环境 ‌23。</li><li>推荐使用 <code>Dockerfile</code> 构建标准化镜像，确保可重复性和版本控制 ‌23。</li></ul></li><li><p>‌<strong>多镜像打包</strong>‌</p><ul><li><p>若需打包多个镜像到单个文件，可使用 <code>docker save</code> 同时指定多个镜像名：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o all-images.tar image1:v1 image2:v2  <span class="comment"># 合并导出多个镜像 :ml-citation&#123;ref=&quot;7&quot; data=&quot;citationList&quot;&#125;  </span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="‌操作流程示意图‌"><a href="#‌操作流程示意图‌" class="headerlink" title="‌操作流程示意图‌"></a>‌<strong>操作流程示意图</strong>‌</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">运行中容器 → `docker commit` → 新镜像 → `docker save` → .tar 文件 → 传输 → `docker load` → 目标环境  </span><br></pre></td></tr></table></figure><p>通过上述步骤，可快速完成运行中容器的镜像打包与迁移。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;正在运行的-Docker-容器打包镜像方法&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://kanoc.gitee.io/categories/Docker/"/>
    
    <category term="打包" scheme="https://kanoc.gitee.io/categories/Docker/%E6%89%93%E5%8C%85/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="镜像" scheme="https://kanoc.gitee.io/tags/%E9%95%9C%E5%83%8F/"/>
    
    <category term="打包" scheme="https://kanoc.gitee.io/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>docker安装buildx插件</title>
    <link href="https://kanoc.gitee.io/2025/02/27/docker%E5%AE%89%E8%A3%85buildx%E6%8F%92%E4%BB%B6/"/>
    <id>https://kanoc.gitee.io/2025/02/27/docker%E5%AE%89%E8%A3%85buildx%E6%8F%92%E4%BB%B6/</id>
    <published>2025-02-26T19:38:58.000Z</published>
    <updated>2025-02-26T19:43:39.980Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>docker安装buildx插件，交叉打包</strong></font></p><span id="more"></span><p>错误：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; docker buildx build --platform linux/amd64,linux/arm64 -t xxxx/xxxxx:latest --push .</span><br><span class="line"><span class="comment"># 错误输出：</span></span><br><span class="line">unknown flag: --platform</span><br><span class="line">See <span class="string">&#x27;docker --help&#x27;</span>.</span><br></pre></td></tr></table></figure><p>提示无效参数：–platform</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install docker-buildx   <span class="comment"># 安装 buildx</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.docker/cli-plugins     <span class="comment"># 创建插件目录</span></span><br><span class="line"><span class="built_in">ln</span> -sfn $(<span class="built_in">which</span> docker-buildx) ~/.docker/cli-plugins/docker-buildx    <span class="comment"># 创建软连接到插件目录下</span></span><br><span class="line">docker buildx install    <span class="comment"># 安装插件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;docker安装buildx插件，交叉打包&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://kanoc.gitee.io/categories/Docker/"/>
    
    <category term="错误" scheme="https://kanoc.gitee.io/categories/Docker/%E9%94%99%E8%AF%AF/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="打包" scheme="https://kanoc.gitee.io/tags/%E6%89%93%E5%8C%85/"/>
    
    <category term="buildx" scheme="https://kanoc.gitee.io/tags/buildx/"/>
    
  </entry>
  
  <entry>
    <title>破解cloudflare拦截神器_puppeteer</title>
    <link href="https://kanoc.gitee.io/2025/02/25/%E7%A0%B4%E8%A7%A3cloudflare%E6%8B%A6%E6%88%AA%E7%A5%9E%E5%99%A8-puppeteer/"/>
    <id>https://kanoc.gitee.io/2025/02/25/%E7%A0%B4%E8%A7%A3cloudflare%E6%8B%A6%E6%88%AA%E7%A5%9E%E5%99%A8-puppeteer/</id>
    <published>2025-02-24T18:52:13.000Z</published>
    <updated>2025-02-24T19:13:32.762Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>破解cloudflare拦截神器_puppeteer</strong></font></p><span id="more"></span><h3 id="安装番外：安装node-js环境"><a href="#安装番外：安装node-js环境" class="headerlink" title="安装番外：安装node.js环境"></a>安装番外：安装node.js环境</h3><h4 id="安装nvm管理器"><a href="#安装nvm管理器" class="headerlink" title="安装nvm管理器"></a>安装<code>nvm</code>管理器</h4><ul><li>第1步：mac 安装：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install nvm</span><br></pre></td></tr></table></figure><ul><li>第2_1步：命令安装：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</span><br><span class="line">或</span><br><span class="line">$ wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</span><br></pre></td></tr></table></figure><ul><li>第2_2步：国内安装</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</span><br><span class="line">或</span><br><span class="line">$ wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</span><br></pre></td></tr></table></figure><ul><li>第3步：添加环境</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、这是本地不存在配置文件的时候提示需要添加的配置</span></span><br><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/.nvm&quot;</span></span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span>  <span class="comment"># This loads nvm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、这是本地存在配置文件的时候提示需要添加的配置（推荐）</span></span><br><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/.nvm&quot;</span></span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/bash_completion&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/bash_completion&quot;</span>  <span class="comment"># This loads nvm bash_completion</span></span><br></pre></td></tr></table></figure><ul><li>第4步：加载环境：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><ul><li>第5步：测试安装是否成功</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nvm -v</span><br><span class="line">或</span><br><span class="line">$ nvm use system</span><br></pre></td></tr></table></figure><ul><li>第6步：<code>nvm</code>相关命令</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm install stable</span><br><span class="line">nvm install &lt;version&gt;     <span class="comment"># 安装指定版本 node</span></span><br><span class="line">nvm uninstall &lt;version&gt;   <span class="comment"># 删除指定版本 node</span></span><br><span class="line"></span><br><span class="line">nvm use &lt;version&gt;         <span class="comment"># 切换使用指定的版本 node</span></span><br><span class="line">nvm <span class="built_in">alias</span> default &lt;version&gt;   <span class="comment"># 永久版本 - 所有窗口生效指定版本</span></span><br><span class="line"></span><br><span class="line">nvm <span class="built_in">ls</span>    <span class="comment"># 列出所有安装的版本</span></span><br><span class="line">nvm ls-remote   <span class="comment"># 列出所有远程服务器的版本（官方 node version list）</span></span><br><span class="line">nvm current   <span class="comment"># 显示当前的版本</span></span><br><span class="line">nvm <span class="built_in">alias</span> &lt;name&gt; &lt;version&gt;   <span class="comment"># 给不同的版本号添加别名</span></span><br><span class="line">nvm <span class="built_in">unalias</span> &lt;name&gt;   <span class="comment"># 删除已定义的别名</span></span><br><span class="line"></span><br><span class="line">nvm reinstall-packages &lt;version&gt;     <span class="comment"># 在当前版本 node 环境下，重新全局安装指定版本号的 npm 包</span></span><br></pre></td></tr></table></figure><h3 id="第一步：安装puppeteer"><a href="#第一步：安装puppeteer" class="headerlink" title="第一步：安装puppeteer"></a>第一步：安装puppeteer</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i puppeteer</span><br></pre></td></tr></table></figure><h3 id="第二步：-安装插件-puppeteer-extra、puppeteer-extra-plugin-stealth"><a href="#第二步：-安装插件-puppeteer-extra、puppeteer-extra-plugin-stealth" class="headerlink" title="第二步： 安装插件 puppeteer-extra、puppeteer-extra-plugin-stealth"></a>第二步： 安装插件 puppeteer-extra、puppeteer-extra-plugin-stealth</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install puppeteer-extra puppeteer-extra-plugin-stealth express</span><br></pre></td></tr></table></figure><h3 id="第三步：使用nodejs获取数据："><a href="#第三步：使用nodejs获取数据：" class="headerlink" title="第三步：使用nodejs获取数据："></a>第三步：使用nodejs获取数据：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer-extra&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">StealthPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer-extra-plugin-stealth&#x27;</span>)</span><br><span class="line">puppeteer.<span class="title function_">use</span>(<span class="title class_">StealthPlugin</span>())</span><br><span class="line"><span class="keyword">const</span> &#123;executablePath&#125; = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puppeteer.<span class="title function_">launch</span>(&#123; <span class="attr">headless</span>: <span class="literal">false</span>, <span class="attr">executablePath</span>: <span class="title function_">executablePath</span>() &#125;).<span class="title function_">then</span>(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>()</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://xxx.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Promise 来等待</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">2000</span>))  <span class="comment">// 等待 2 秒</span></span><br><span class="line">    <span class="comment">// 获取页面的文本内容</span></span><br><span class="line">    <span class="keyword">const</span> pageContent = <span class="keyword">await</span> page.<span class="title function_">evaluate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span>;  <span class="comment">// 获取页面的所有文本</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印页面文本内容</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(pageContent);</span><br><span class="line">    <span class="keyword">await</span> page.<span class="title function_">screenshot</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;cointracker_home.png&#x27;</span>, <span class="attr">fullPage</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="keyword">await</span> browser.<span class="title function_">close</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="第四步：当然你也可以把他写成接口"><a href="#第四步：当然你也可以把他写成接口" class="headerlink" title="第四步：当然你也可以把他写成接口"></a>第四步：当然你也可以把他写成接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.....</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;破解cloudflare拦截神器_puppeteer&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="逆向" scheme="https://kanoc.gitee.io/categories/%E9%80%86%E5%90%91/"/>
    
    <category term="反爬" scheme="https://kanoc.gitee.io/categories/%E9%80%86%E5%90%91/%E5%8F%8D%E7%88%AC/"/>
    
    
    <category term="逆向" scheme="https://kanoc.gitee.io/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="nodejs" scheme="https://kanoc.gitee.io/tags/nodejs/"/>
    
    <category term="后端" scheme="https://kanoc.gitee.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="puppeteer" scheme="https://kanoc.gitee.io/tags/puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>mongodb数据库的备份与恢复</title>
    <link href="https://kanoc.gitee.io/2025/02/23/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>https://kanoc.gitee.io/2025/02/23/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</id>
    <published>2025-02-22T19:37:49.000Z</published>
    <updated>2025-02-24T18:53:46.281Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Docker下：mongodb数据库的备份与恢复</strong></font></p><span id="more"></span><h2 id="备份篇："><a href="#备份篇：" class="headerlink" title="备份篇："></a>备份篇：</h2><ul><li>备份数据库名称：<code>ttd</code></li><li>本地备份容器：<code>126bf65cd37f</code></li></ul><h3 id="1、进入容器："><a href="#1、进入容器：" class="headerlink" title="1、进入容器："></a>1、进入容器：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps   <span class="comment"># 查看正在运行的docker 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 126bf65cd37f /bin/bash   <span class="comment"># 进入ID：126bf65cd37f 的容器</span></span><br><span class="line">mongodump --uri=<span class="string">&quot;mongodb://username:password@localhost:27017/ttd&quot;</span> --out /path/to/backup/    <span class="comment"># 将数据库备份到/path/to/backup/ 文件夹下</span></span><br></pre></td></tr></table></figure><h3 id="2、打包备份文件"><a href="#2、打包备份文件" class="headerlink" title="2、打包备份文件"></a>2、打包备份文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -cvf /path/to/ttd.tar /path/to/backup/      <span class="comment"># 将/path/to/backup/ 文件夹下的备份数据库  打包到 /path/to/ttd.tar</span></span><br></pre></td></tr></table></figure><h3 id="3、复制备份打包文件到宿主机器"><a href="#3、复制备份打包文件到宿主机器" class="headerlink" title="3、复制备份打包文件到宿主机器"></a>3、复制备份打包文件到宿主机器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将备份的文件复制到宿主机</span></span><br><span class="line">docker <span class="built_in">cp</span> 126bf65cd37f:/path/to/ttd.tar /home/mycp/DataBases   <span class="comment"># 将打包文件 复制到宿主的/home/mycp/DataBases下</span></span><br></pre></td></tr></table></figure><h2 id="恢复篇："><a href="#恢复篇：" class="headerlink" title="恢复篇："></a>恢复篇：</h2><ul><li>恢复数据库名称：<code>ttd</code></li><li>本地备份容器：<code>126bf65cd37f</code></li></ul><h3 id="1、上传压缩包到恢复的宿主机器"><a href="#1、上传压缩包到恢复的宿主机器" class="headerlink" title="1、上传压缩包到恢复的宿主机器"></a>1、上传压缩包到恢复的宿主机器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里就不讲怎么恢复了！</span><br></pre></td></tr></table></figure><h3 id="2、传入docker-机器-上传后的路径：-home-cdd-DataBases-ttd-tar"><a href="#2、传入docker-机器-上传后的路径：-home-cdd-DataBases-ttd-tar" class="headerlink" title="2、传入docker 机器(上传后的路径：/home/cdd/DataBases/ttd.tar)"></a>2、传入docker 机器(上传后的路径：<code>/home/cdd/DataBases/ttd.tar</code>)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /DBFiles   <span class="comment"># 创建路径，不然可能报错</span></span><br><span class="line">docker <span class="built_in">cp</span> /home/cdd/DataBases/ttd.tar 8ba9426d45e3:/DBFiles   <span class="comment"># 复制到docker机器</span></span><br></pre></td></tr></table></figure><h3 id="3、解压缩"><a href="#3、解压缩" class="headerlink" title="3、解压缩"></a>3、解压缩</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf ttd.tar    <span class="comment"># 解压完成会出现一个新的文件夹：ttd</span></span><br></pre></td></tr></table></figure><h3 id="4、恢复"><a href="#4、恢复" class="headerlink" title="4、恢复"></a>4、恢复</h3><ul><li>避坑1：备份的文件夹中存在 <code>.json</code>文件，如果直接用文件夹恢复命令是会报错的</li><li>避坑2：必须要指定<code>--authenticationDatabase admin</code> 否则会提示权限</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongorestore -h 127.0.0.1:27017 --authenticationDatabase admin -u &lt;username&gt; -p &lt;password&gt; -d &lt;database&gt; /home/cdd/DataBases/ttd/Images.bson</span><br><span class="line"><span class="comment"># 如果没有 .json 文件 可以用下面的命令恢复</span></span><br><span class="line">mongorestore --uri=<span class="string">&quot;mongodb://username:password@localhost:27017&quot;</span> /home/cdd/DataBases/ttd</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Docker下：mongodb数据库的备份与恢复&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/categories/docker/"/>
    
    <category term="数据库" scheme="https://kanoc.gitee.io/categories/docker/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="mongoldb" scheme="https://kanoc.gitee.io/tags/mongoldb/"/>
    
    <category term="备份与恢复" scheme="https://kanoc.gitee.io/tags/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>一套JS可逆加密算法，基于crypto-js</title>
    <link href="https://kanoc.gitee.io/2025/02/21/%E4%B8%80%E5%A5%97JS%E5%8F%AF%E9%80%86%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9F%BA%E4%BA%8Ecrypto-js/"/>
    <id>https://kanoc.gitee.io/2025/02/21/%E4%B8%80%E5%A5%97JS%E5%8F%AF%E9%80%86%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9F%BA%E4%BA%8Ecrypto-js/</id>
    <published>2025-02-21T15:16:43.000Z</published>
    <updated>2025-02-21T15:19:50.975Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>一套JS可逆加密算法，基于crypto-js</strong></font></p><span id="more"></span><p>在JavaScript中，你可以使用多种方法来实现可逆加密。<br>这里是一个简单的例子，使用的是<code>crypto-js</code>库的<code>AES</code>加密方法。</p><p>首先，你需要安装<code>crypto-js</code>库。你可以通过<code>npm</code>来安装：</p><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install crypto-js</span><br></pre></td></tr></table></figure><p>然后，你可以使用以下代码来实现AES加密和解密：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">encrypt</span>(<span class="params">text, secretKey</span>) &#123;  </span><br><span class="line">    <span class="keyword">const</span> key = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(secretKey);  </span><br><span class="line">    <span class="keyword">const</span> iv = <span class="title class_">CryptoJS</span>.<span class="property">lib</span>.<span class="property">WordArray</span>.<span class="title function_">create</span>(<span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>));  </span><br><span class="line">    <span class="keyword">const</span> encrypted = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(<span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(text), key, &#123; <span class="attr">iv</span>: iv &#125;);  </span><br><span class="line">    <span class="keyword">return</span> encrypted.<span class="title function_">toString</span>();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">decrypt</span>(<span class="params">ciphertext, secretKey</span>) &#123;  </span><br><span class="line">    <span class="keyword">const</span> key = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(secretKey);  </span><br><span class="line">    <span class="keyword">const</span> iv = <span class="title class_">CryptoJS</span>.<span class="property">lib</span>.<span class="property">WordArray</span>.<span class="title function_">create</span>(<span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>));  </span><br><span class="line">    <span class="keyword">const</span> decrypted = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">decrypt</span>(ciphertext, key, &#123; <span class="attr">iv</span>: iv &#125;);  </span><br><span class="line">    <span class="keyword">return</span> decrypted.<span class="title function_">toString</span>(<span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 测试代码  </span></span><br><span class="line"><span class="keyword">const</span> secretKey = <span class="string">&#x27;mySecretKey&#x27;</span>;  </span><br><span class="line"><span class="keyword">const</span> text = <span class="string">&#x27;Hello, World!&#x27;</span>;  </span><br><span class="line"><span class="keyword">const</span> encryptedText = <span class="title function_">encrypt</span>(text, secretKey);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Encrypted: &#x27;</span> + encryptedText);  </span><br><span class="line"><span class="keyword">const</span> decryptedText = <span class="title function_">decrypt</span>(encryptedText, secretKey);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Decrypted: &#x27;</span> + decryptedText);</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先导入了<code>crypto-js</code>库。然后，我们定义了两个函数：<code>encrypt</code>和<code>decrypt</code>。<br><code>encrypt</code>函数接收一个文本和一个密钥作为参数，并返回加密后的文本。<br><code>decrypt</code>函数接收一个密文和一个密钥作为参数，并返回解密后的文本。</p><p>注意，这个例子使用了<code>AES</code>加密算法，并且使用了相同的密钥进行加密和解密。<br>在实际应用中，你应该使用一个安全的密钥管理方法来存储和传输密钥。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;一套JS可逆加密算法，基于crypto-js&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="逆向" scheme="https://kanoc.gitee.io/categories/%E9%80%86%E5%90%91/"/>
    
    <category term="JavaScript" scheme="https://kanoc.gitee.io/categories/%E9%80%86%E5%90%91/JavaScript/"/>
    
    
    <category term="python" scheme="https://kanoc.gitee.io/tags/python/"/>
    
    <category term="逆向" scheme="https://kanoc.gitee.io/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="JavaScript" scheme="https://kanoc.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu-设置swap交换空间</title>
    <link href="https://kanoc.gitee.io/2025/02/17/ubuntu-%E8%AE%BE%E7%BD%AEswap%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4/"/>
    <id>https://kanoc.gitee.io/2025/02/17/ubuntu-%E8%AE%BE%E7%BD%AEswap%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4/</id>
    <published>2025-02-17T01:23:10.000Z</published>
    <updated>2025-02-17T01:29:15.060Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong><code>ubuntu</code> 设置<code>swap</code>交换空间</strong></font></p><span id="more"></span><p>在 <code>Ubuntu</code> 上设置交换空间（<code>Swap Space</code>）可以帮助系统在物理内存不足时使用硬盘空间来存储临时数据。以下是设置交换空间的步骤：</p><h3 id="步骤-1-检查当前交换空间"><a href="#步骤-1-检查当前交换空间" class="headerlink" title="步骤 1: 检查当前交换空间"></a>步骤 1: 检查当前交换空间</h3><p>首先，检查当前的交换空间是否已启用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo swapon --show</span><br></pre></td></tr></table></figure><p>如果没有输出，表示当前没有启用的交换空间。</p><h3 id="步骤-2-创建交换文件"><a href="#步骤-2-创建交换文件" class="headerlink" title="步骤 2: 创建交换文件"></a>步骤 2: 创建交换文件</h3><ol><li>选择交换文件的大小：决定你想要创建的交换文件的大小。例如，假设你想创建一个 <code>2GB</code> 的交换文件。</li><li>创建交换文件：使用 <code>fallocate</code> 命令创建交换文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo fallocate -l 2G /swapfile</span><br></pre></td></tr></table></figure><p>如果 fallocate 不可用，可以使用 <code>dd</code> 命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dd if=/dev/zero of=/swapfile bs=1G count=2  </span><br></pre></td></tr></table></figure><h3 id="步骤-3-设置交换文件权限"><a href="#步骤-3-设置交换文件权限" class="headerlink" title="步骤 3: 设置交换文件权限"></a>步骤 3: 设置交换文件权限</h3><p>为了安全起见，设置交换文件的权限，使其只能由 <code>root</code> 用户访问：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 600 /swapfile</span><br></pre></td></tr></table></figure><h3 id="步骤-4-将文件设置为交换空间"><a href="#步骤-4-将文件设置为交换空间" class="headerlink" title="步骤 4: 将文件设置为交换空间"></a>步骤 4: 将文件设置为交换空间</h3><p>使用以下命令将文件设置为交换空间：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkswap /swapfile</span><br></pre></td></tr></table></figure><h3 id="步骤-5-启用交换空间"><a href="#步骤-5-启用交换空间" class="headerlink" title="步骤 5: 启用交换空间"></a>步骤 5: 启用交换空间</h3><p>启用交换空间：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo swapon /swapfile</span><br></pre></td></tr></table></figure><h3 id="步骤-6-验证交换空间"><a href="#步骤-6-验证交换空间" class="headerlink" title="步骤 6: 验证交换空间"></a>步骤 6: 验证交换空间</h3><p>再次检查交换空间是否已启用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo swapon --show</span><br></pre></td></tr></table></figure><p>你应该能看到 <code>/swapfile</code> 列在输出中。</p><h3 id="步骤-7-设置开机自动挂载"><a href="#步骤-7-设置开机自动挂载" class="headerlink" title="步骤 7: 设置开机自动挂载"></a>步骤 7: 设置开机自动挂载</h3><p>为了在系统重启后自动启用交换空间，需要将其添加到 <code>/etc/fstab</code> 文件中：</p><ol><li>打开 <code>/etc/fstab</code> 文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/fstab</span><br></pre></td></tr></table></figure><ol start="2"><li>在文件末尾添加以下行：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/swapfile none swap sw 0 0</span><br></pre></td></tr></table></figure><p>保存并退出编辑器（在 <code>nano</code> 中，按 <code>CTRL + X</code>，然后按 <code>Y</code> 确认保存）。</p><h3 id="步骤-8-调整交换空间使用策略（可选）"><a href="#步骤-8-调整交换空间使用策略（可选）" class="headerlink" title="步骤 8: 调整交换空间使用策略（可选）"></a>步骤 8: 调整交换空间使用策略（可选）</h3><p>你可以调整系统使用交换空间的策略。默认情况下，<code>Linux</code> 系统会在物理内存使用到一定程度后才会使用交换空间。你可以通过调整<code> vm.swappiness</code> 参数来改变这一行为：</p><p>查看当前的 <code>swappiness</code> 值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/vm/swappiness</span><br></pre></td></tr></table></figure><p>临时设置 <code>swappiness</code> 值（范围 <code>0-100</code>，值越低，越不倾向于使用交换空间）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sysctl vm.swappiness=10</span><br></pre></td></tr></table></figure><p>要永久更改 <code>swappiness</code> 值，可以编辑 <code>/etc/sysctl.conf</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>在文件中添加或修改以下行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vm.swappiness=10</span><br></pre></td></tr></table></figure><p>保存并退出编辑器。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上步骤，你可以在 <code>Ubuntu</code> 上成功设置和启用交换空间。这将有助于在物理内存不足时提高系统的稳定性和性能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;&lt;code&gt;ubuntu&lt;/code&gt; 设置&lt;code&gt;swap&lt;/code&gt;交换空间&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="系统" scheme="https://kanoc.gitee.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="ubuntu" scheme="https://kanoc.gitee.io/categories/%E7%B3%BB%E7%BB%9F/ubuntu/"/>
    
    
    <category term="ubuntu" scheme="https://kanoc.gitee.io/tags/ubuntu/"/>
    
    <category term="swap" scheme="https://kanoc.gitee.io/tags/swap/"/>
    
    <category term="交换空间" scheme="https://kanoc.gitee.io/tags/%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>docker-push到harbor错误解决方案</title>
    <link href="https://kanoc.gitee.io/2025/02/17/docker-push%E5%88%B0harbor%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://kanoc.gitee.io/2025/02/17/docker-push%E5%88%B0harbor%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2025-02-16T21:50:52.000Z</published>
    <updated>2025-02-16T22:08:19.756Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>docker push到<code>harbor</code>错误解决方案</strong></font></p><span id="more"></span><p>系统信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU信息: Apple M1</span><br><span class="line">内存信息: 8 GB, </span><br><span class="line">系统版本: 14.3.1</span><br><span class="line"></span><br><span class="line">Docker version 27.5.1, build 9f9e405801</span><br><span class="line">colima version 0.8.1</span><br><span class="line">runtime: docker</span><br><span class="line">arch: aarch64</span><br><span class="line">client: v27.5.1</span><br><span class="line">server: v27.4.0</span><br></pre></td></tr></table></figure><h2 id="错误1："><a href="#错误1：" class="headerlink" title="错误1："></a>错误1：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The push refers to repository [192.168.31.7:7315/ka/ppds]</span><br><span class="line">Get <span class="string">&quot;https://192.168.31.7:7315/ka/ppds/v2/&quot;</span>: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ul><li>第1步：设置不安全的注册表</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑colima默认信息</span></span><br><span class="line">colima start --edit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在打开的栏中找到 docker配置</span></span><br><span class="line">docker:</span><br><span class="line">  insecure-registries:</span><br><span class="line">    - harbor.jakehu.me:31104</span><br><span class="line">  registry-mirrors:</span><br><span class="line">    - docker.registry.huwenxi.com</span><br></pre></td></tr></table></figure><ul><li>第2步：开始重启 <code>colima</code></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Colima列表</span></span><br><span class="line">colima list</span><br><span class="line"><span class="comment"># 启动Colima</span></span><br><span class="line">colima start</span><br><span class="line"><span class="comment"># 停止Colima</span></span><br><span class="line">colima stop</span><br><span class="line"><span class="comment"># 显示Colima状态信息</span></span><br><span class="line">colima status</span><br><span class="line"><span class="comment"># 通过SSH连接到Colima</span></span><br><span class="line">colima ssh</span><br></pre></td></tr></table></figure><ul><li>第3步：查看是否添加成功了</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker system info   <span class="comment"># 终端输出的内容中包含 docker.registry.huwenxi.com 那么就是成功的</span></span><br></pre></td></tr></table></figure><ul><li>第4步：验证登录</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login docker.registry.huwenxi.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 出现下列内容 则添加完成了</span></span><br><span class="line"><span class="comment"># Username: xxx</span></span><br><span class="line"><span class="comment"># Password: </span></span><br><span class="line"><span class="comment"># Login Succeeded</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;docker push到&lt;code&gt;harbor&lt;/code&gt;错误解决方案&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/categories/docker/"/>
    
    <category term="harbor" scheme="https://kanoc.gitee.io/categories/docker/harbor/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="错误" scheme="https://kanoc.gitee.io/tags/%E9%94%99%E8%AF%AF/"/>
    
    <category term="私有仓库" scheme="https://kanoc.gitee.io/tags/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你搭建Docker私有仓库Harbor</title>
    <link href="https://kanoc.gitee.io/2025/02/16/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BADocker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93Harbor/"/>
    <id>https://kanoc.gitee.io/2025/02/16/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BADocker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93Harbor/</id>
    <published>2025-02-16T11:37:35.000Z</published>
    <updated>2025-02-16T11:42:22.262Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>手把手教你搭建Docker私有仓库Harbor</strong></font></p><p>本文搬运自：<a href="https://www.cnblogs.com/sowler/p/18242819">手把手教你搭建Docker私有仓库Harbor - sowler - 博客园</a></p><span id="more"></span><h4 id="1、什么是Docker私有仓库"><a href="#1、什么是Docker私有仓库" class="headerlink" title="1、什么是Docker私有仓库"></a>1、什么是Docker私有仓库</h4><p>Docker私有仓库是用于存储和管理Docker镜像的私有存储库。Docker默认会有一个公共的仓库Docker Hub，而与Docker Hub不同，私有仓库是受限访问的，只有授权用户才能够上传、下载和管理其中的镜像。这种私有仓库可以部署在本地云环境中，用于组织内部开发、测试和生产环境中的容器镜像管理。保证数据安全性。</p><h4 id="2、Docker有哪些私有仓库"><a href="#2、Docker有哪些私有仓库" class="headerlink" title="2、Docker有哪些私有仓库"></a>2、Docker有哪些私有仓库</h4><p><strong>以下是一些常见的Docker私有仓库：</strong></p><ul><li><strong>Harbor</strong>：作为一个企业级的Docker Registry服务，Harbor提供了安全、可信赖的镜像存储和管理功能。它支持RBAC权限控制、镜像复制、镜像签名、漏洞扫描等功能。</li><li><strong>Docker Trusted Registry (DTR)</strong>：由Docker官方推出的企业级Docker私有仓库服务，与Docker Engine紧密集成，支持高度的安全性和可靠性。</li><li><strong>Portus</strong>：一个开源的Docker镜像管理和认证服务，提供用户管理、团队管理、镜像审核等功能，与Docker Registry兼容。</li><li><strong>Nexus Repository Manager</strong>：虽然主要是用于构建和管理Java组件，但也可以用作Docker私有仓库。它具有强大的存储管理和权限控制功能。</li><li><strong>GitLab Container Registry</strong>：GitLab集成了容器注册表功能，允许您存储、管理和分发Docker镜像。这是GitLab自带的功能，无需额外部署。</li><li><strong>AWS Elastic Container Registry (ECR)</strong>：如果使用AWS云服务，可以考虑使用AWS ECR作为私有仓库。它与AWS的其他服务集成紧密，对AWS用户来说是一个方便的选择。</li></ul><p>本篇使用Harbor搭建Docker私有仓库。</p><h4 id="3、Harbor简介"><a href="#3、Harbor简介" class="headerlink" title="3、Harbor简介"></a>3、Harbor简介</h4><p>Harbor是一个开源的企业级Docker Registry服务，它提供了一个安全、可信赖的仓库来存储和管理Docker镜像。Harbor翻译为中文名称为”庇护；居住;”。可以理解为是Docker镜像的”居住环境”或者是镜像的”庇护所”。Harbor最初由VMware公司开发，旨在解决企业级Docker镜像管理的安全和可信任性问题。VMware于2016年发布，在2017年，VMware将Harbor开源，这使得更广泛的社区和组织可以自由地使用和贡献代码。Harbor是一个成熟、功能丰富且安全可靠的企业级Docker Registry服务，为企业容器化应用的部署和管理提供了强大的支持。</p><p>Harbor官网地址：<a href="https://goharbor.io/">Harbor (goharbor.io)</a></p><p>Github开源地址：<a href="https://github.com/goharbor/harbor">https://github.com/goharbor/harbor</a></p><h4 id="4、Harbor下载"><a href="#4、Harbor下载" class="headerlink" title="4、Harbor下载"></a>4、Harbor下载</h4><h5 id="4-1、通过Linux命令下载"><a href="#4-1、通过Linux命令下载" class="headerlink" title="4.1、通过Linux命令下载"></a>4.1、通过Linux命令下载</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://github.com/goharbor/harbor/releases/download/v2.10.0/harbor-offline-installer-v2.10.0.tgz</span><br></pre></td></tr></table></figure><h5 id="4-2、GitHub下载"><a href="#4-2、GitHub下载" class="headerlink" title="4.2、GitHub下载"></a>4.2、GitHub下载</h5><p>下载地址：<a href="https://github.com/goharbor/harbor/releases">https://github.com/goharbor/harbor/releases</a> 下载离线版本</p><p><img src="https://s2.loli.net/2025/02/16/meHfNQrXgctVMnx.png" alt="img"></p><p>下载成功后，把包通过 <code>xftp</code> 上传到服务器。</p><h5 id="4-3、解压"><a href="#4-3、解压" class="headerlink" title="4.3、解压"></a>4.3、解压</h5><p>解压文件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf harbor-offline-installer-v2.10.0.tgz </span><br></pre></td></tr></table></figure><h4 id="5、启动Harbor"><a href="#5、启动Harbor" class="headerlink" title="5、启动Harbor"></a>5、启动Harbor</h4><h5 id="5-1、修改配置文件"><a href="#5-1、修改配置文件" class="headerlink" title="5.1、修改配置文件"></a>5.1、修改配置文件</h5><p>复制<code>harbor.yml.tmpl</code> 文件并重命名为<code>harbor.yml</code>修改此配置文件，需要设置hostname、端口、数据库密码等。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> harbor.yml.tmpl harbor.yml <span class="comment">#拷贝</span></span><br><span class="line"></span><br><span class="line">vim harbor.yml</span><br></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改hostname的值，如果没有域名就使用本机IP地址</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="number">192.168</span><span class="number">.42</span><span class="number">.133</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置启动端口号</span></span><br><span class="line"><span class="comment"># http related config </span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="comment"># port for http, default is 80. If https enabled, this port will redirect to https port</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有申请证书，需要隐藏https</span></span><br><span class="line"><span class="comment">#https:</span></span><br><span class="line">  <span class="comment"># https port for harbor, default is 443</span></span><br><span class="line"><span class="comment">#  port: 443</span></span><br><span class="line">  <span class="comment"># The path of cert and key files for nginx</span></span><br><span class="line"><span class="comment">#  certificate: /your/certificate/path</span></span><br><span class="line"><span class="comment">#  private_key: /your/private/key/path</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动成功后，admin用户登录密码</span></span><br><span class="line"><span class="comment"># Remember Change the admin password from UI after launching Harbor.</span></span><br><span class="line"><span class="attr">harbor_admin_password:</span> <span class="string">AdminHarbor12345</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/02/16/uflyIABjz3amckh.png" alt="img"></p><h5 id="5-2、启动"><a href="#5-2、启动" class="headerlink" title="5.2、启动"></a>5.2、启动</h5><p>配置文件修改成功后，执行 <code>install.sh</code> 脚本进行安装harbor</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./install.sh </span><br></pre></td></tr></table></figure><p>启动报错：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Step 0]: checking if docker is installed ...</span><br><span class="line"></span><br><span class="line">Note: docker version: 26.1.3</span><br><span class="line"></span><br><span class="line">[Step 1]: checking docker-compose is installed ...</span><br><span class="line">/opt/harbor/common.sh: line 119: docker-compose: command not found</span><br><span class="line">✖ Failed to parse docker-compose version.</span><br></pre></td></tr></table></figure><p>可以看到，该服务器安装的 <code>docker</code> 没有安装 <code>docker-compose</code> 插件</p><h5 id="5-3、安装docker-compose"><a href="#5-3、安装docker-compose" class="headerlink" title="5.3、安装docker-compose"></a>5.3、安装docker-compose</h5><p>进入<code>docker-compose</code> 官网下载执行文件，地址： <a href="https://github.com/docker/compose">https://github.com/docker/compose</a> 下载成功后，把可执行文件加入<code>Linux</code> 系统命令目录</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> docker-compose-linux-x86_64 /usr/local/bin/</span><br></pre></td></tr></table></figure><p>重命名：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> docker-compose-linux-x86_64 docker-compose</span><br></pre></td></tr></table></figure><p>授权：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>执行命令查看是否安装成功：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><p>如果需要卸载，直接删除即可：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><h5 id="5-4、再次启动"><a href="#5-4、再次启动" class="headerlink" title="5.4、再次启动"></a>5.4、再次启动</h5><p>再次执行 <code>./install.sh</code></p><p><img src="https://s2.loli.net/2025/02/16/ilOpYecKCy7wGTZ.png" alt="img"></p><p>提示安装成功。接下来就可以访问Harbor了。访问IP+端口：<a href="http://192.168.42.133:5000/">http://192.168.42.133:5000</a><br><img src="https://s2.loli.net/2025/02/16/FrRKhnkacDUV8lG.png" alt="img"></p><p>访问成功，由于Harbor是通过docker管理的，所以启动非常方便。如果首页访问成功说明Docker私有仓库已经部署成功了。</p><h4 id="6、Harbor-Web页面操作说明"><a href="#6、Harbor-Web页面操作说明" class="headerlink" title="6、Harbor Web页面操作说明"></a>6、Harbor Web页面操作说明</h4><p>默认用户名是admin，密码是启动时设置的密码：<code>AdminHarbor12345</code></p><p><img src="https://s2.loli.net/2025/02/16/9SnuUoJsKBzCFpA.png" alt="img"></p><p>登录成功进入主页面了。从系统首页可以看到系统分为三个菜单：项目、日志、系统管理。</p><h5 id="6-1、项目"><a href="#6-1、项目" class="headerlink" title="6.1、项目"></a>6.1、项目</h5><p>项目管理顾名思义就是用来管理项目的。可以为每一个开发项目创建一个私有项目库，然后把Docker镜像存储到指定的项目中，为每个项目实现项目镜像隔离。创建项目的时候，Harbor提供了公开库（public repository）和私有库（private repository）两种类型的镜像存储空间。</p><p><img src="https://s2.loli.net/2025/02/16/F34W9pclPBSkQHa.png" alt="img"></p><p>通过详情信息可以看到：<strong>公开库中的镜像是对所有用户可见和可访问的，任何人都可以查看和拉取其中的镜像。而私有库中的镜像则需要登录才能访问控制，只有被授权的用户或团队才能够查看、拉取和推送镜像。</strong> 可以根据需要创建相关的项目。</p><p><img src="https://s2.loli.net/2025/02/16/l1pfKPiZngO9sXW.png" alt="img"></p><p>项目创建成功后，可以点击进入项目。在里面可以为每个项目单独设置不同的配置信息。可以为每一个项目添加成员信息。</p><p><img src="https://s2.loli.net/2025/02/16/yBMfu4NG6PHYxdX.png" alt="img"></p><p>角色权限说明：</p><ul><li>**项目管理员（Project Administrator）：**拥有项目的最高权限，可以对项目进行全面管理，包括创建和删除项目、管理项目成员和权限、配置项目属性、查看项目日志等。</li><li>**维护人员（Maintainer）：**类似于项目管理员，但权限稍低，通常用于协助管理项目，可以进行项目的部分管理操作，如添加和删除镜像、配置镜像的复制和同步规则等。</li><li>**开发者（Developer）：**具有对项目中镜像仓库的读写权限，可以拉取、推送和删除镜像，以及管理部分项目配置，但不能进行项目管理操作。</li><li>**访客（Guest）：**只具有对项目中镜像仓库的只读权限，可以查看镜像和元数据，但无法对镜像进行修改或删除操作。通常用于分享项目或镜像给外部团队或用户。</li><li>**受限访客（Restricted Guest）：**是一种更加受限的访客角色，通常用于提供给外部用户或系统，具有对项目中镜像仓库的只读权限，但可能会限制访问的部分内容或功能。</li></ul><p>在右上角显示推送命令，可以通过提示命令进行docker镜像推送。</p><p><img src="https://s2.loli.net/2025/02/16/RFEucUsbXL2jYyG.png" alt="img"></p><h5 id="6-2、日志"><a href="#6-2、日志" class="headerlink" title="6.2、日志"></a>6.2、日志</h5><p>日志菜单就是记录用户操作日志信息的。</p><p><img src="https://s2.loli.net/2025/02/16/B7HKfokDjcG4yNE.png" alt="img"></p><h5 id="6-3、系统管理"><a href="#6-3、系统管理" class="headerlink" title="6.3、系统管理"></a>6.3、系统管理</h5><p>系统管理主要用来管理Harbor用户人员信息、镜像仓库的各种配置、权限和系统设置。</p><p><img src="https://s2.loli.net/2025/02/16/KfL2ViA7z8JyWvT.png" alt="img"></p><h4 id="7、Docker命令使用私有仓库"><a href="#7、Docker命令使用私有仓库" class="headerlink" title="7、Docker命令使用私有仓库"></a>7、Docker命令使用私有仓库</h4><h5 id="7-1、登录"><a href="#7-1、登录" class="headerlink" title="7.1、登录"></a>7.1、登录</h5><p>首先登录私有仓库地址：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker login  -u admin -p AdminHarbor12345 http://192.168.42.133:5000</span><br></pre></td></tr></table></figure><p>会报错：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">Error response from daemon: Get <span class="string">&quot;https://192.168.42.133:5000/v2/&quot;</span>: proxyconnect tcp: dial tcp 192.168.65.7:3128: connect: connection refused</span><br></pre></td></tr></table></figure><p>docker认为这个地址是不安全的，所以需要在docker守护进程配置文件中把该地址加入安全范围。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://ejes884z.mirror.aliyuncs.com&quot;</span>],</span><br><span class="line">  <span class="string">&quot;log-driver&quot;</span>:<span class="string">&quot;json-file&quot;</span>,</span><br><span class="line">  <span class="string">&quot;log-opts&quot;</span>: &#123;<span class="string">&quot;max-size&quot;</span>:<span class="string">&quot;1g&quot;</span>, <span class="string">&quot;max-file&quot;</span>:<span class="string">&quot;3&quot;</span>&#125;,</span><br><span class="line">  <span class="string">&quot;live-restore&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;192.168.42.133:5000&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># insecure-registries 不安全的注册表配置一些不安全的地址信息，让Docker认为是安全的。多个地址使用 &quot;,&quot; 分割</span></span><br></pre></td></tr></table></figure><p>加入配置成功后，再次登录。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">WARNING! Your password will be stored unencrypted <span class="keyword">in</span> /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><p>通过输出发现登录成功。认证信息存储在 <code>~/.docker/config.json</code> 文件中，只要登录信息存在，登录会一直生效不需要每次推送拉取之前都登录。</p><h5 id="7-2、推送"><a href="#7-2、推送" class="headerlink" title="7.2、推送"></a>7.2、推送</h5><p>重新命名镜像名称</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker tag 94543a6c1aef 192.168.42.133:5000/blog_project/nginx:1.26.0</span><br></pre></td></tr></table></figure><p>推送</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker push 192.168.42.133:5000/blog_project/nginx:1.26.0</span><br></pre></td></tr></table></figure><p>查看Harbor仓库，推送成功。</p><p><img src="https://s2.loli.net/2025/02/16/rejyKzPso7aNGOw.png" alt="img"></p><h5 id="7-3、拉取"><a href="#7-3、拉取" class="headerlink" title="7.3、拉取"></a>7.3、拉取</h5><p>通过另一台服务器，使用 <code>docker pull</code>拉取镜像从私有仓库拉取镜像：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull 192.168.42.133:5000/blog_project/nginx:1.26.0</span><br></pre></td></tr></table></figure><p>拉取成功</p><p><img src="https://s2.loli.net/2025/02/16/VQRZWvfTwSmdIbj.png" alt="img"></p><p>查看下载数，发现已经更新了。</p><p><img src="https://s2.loli.net/2025/02/16/kmbMnuydhpYTw5a.png" alt="img"></p><h4 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h4><p>关于使用Harbor搭建Docker私有仓库就介绍完毕了，如果大家有兴趣可以查看一下其他搭建方式，然后在它们之间进行对比一下看看那种方式更适合。本篇为入门级Harbor的基础使用，其他功能可以自行研究。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;手把手教你搭建Docker私有仓库Harbor&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;本文搬运自：&lt;a href=&quot;https://www.cnblogs.com/sowler/p/18242819&quot;&gt;手把手教你搭建Docker私有仓库Harbor - sowler - 博客园&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/categories/docker/"/>
    
    <category term="部署" scheme="https://kanoc.gitee.io/categories/docker/%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="Harbor" scheme="https://kanoc.gitee.io/tags/Harbor/"/>
    
  </entry>
  
  <entry>
    <title>docker使用-docker-compose.yml动态传递变量</title>
    <link href="https://kanoc.gitee.io/2025/02/15/docker%E4%BD%BF%E7%94%A8-docker-compose-yml%E5%8A%A8%E6%80%81%E4%BC%A0%E9%80%92%E5%8F%98%E9%87%8F/"/>
    <id>https://kanoc.gitee.io/2025/02/15/docker%E4%BD%BF%E7%94%A8-docker-compose-yml%E5%8A%A8%E6%80%81%E4%BC%A0%E9%80%92%E5%8F%98%E9%87%8F/</id>
    <published>2025-02-15T08:54:49.000Z</published>
    <updated>2025-02-15T09:02:13.374Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>docker使用-docker-compose.yml动态传递变量</strong></font></p><span id="more"></span><h3 id="1-在-docker-compose-yml-中使用环境变量"><a href="#1-在-docker-compose-yml-中使用环境变量" class="headerlink" title="1. 在 docker-compose.yml 中使用环境变量"></a>1. 在 <code>docker-compose.yml</code> 中使用环境变量</h3><p>首先，在 <code>docker-compose.yml</code> 文件中，将 <code>/Users/c33/app/_static</code> 替换为一个环境变量。例如：</p><p>yaml</p><p>复制</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    image: your-image</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="variable">$&#123;STATIC_PATH&#125;</span>:/app/_static  <span class="comment"># 宿主机$&#123;STATIC_PATH&#125;  docker机器/app/_static</span></span><br><span class="line">    environment:</span><br><span class="line">      - STATIC_PATH=<span class="variable">$&#123;STATIC_PATH&#125;</span>  <span class="comment"># 这里定义了一个环境变量 STATIC_PATH，它的值是从外部（宿主机或 .env 文件）传递进来的 $&#123;STATIC_PATH&#125;。</span></span><br></pre></td></tr></table></figure><h3 id="2-在-env-文件中定义环境变量"><a href="#2-在-env-文件中定义环境变量" class="headerlink" title="2. 在 .env 文件中定义环境变量"></a>2. 在 <code>.env</code> 文件中定义环境变量</h3><p>在 <code>docker-compose.yml</code> 文件所在的目录中创建一个 <code>.env</code> 文件，并在其中定义 <code>STATIC_PATH</code> 变量：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">STATIC_PATH=/Users/c33/app/_static</span><br></pre></td></tr></table></figure><h3 id="3-运行-docker-compose-up-时传递环境变量"><a href="#3-运行-docker-compose-up-时传递环境变量" class="headerlink" title="3. 运行 docker-compose up 时传递环境变量"></a>3. 运行 <code>docker-compose up</code> 时传递环境变量</h3><p>当你运行 <code>docker-compose up</code> 时，Docker Compose 会自动读取 <code>.env</code> 文件中的环境变量。如果你想在运行时动态传递不同的路径，可以在命令行中覆盖 <code>.env</code> 文件中的值：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">STATIC_PATH=/path/to/your/static docker-compose up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果直接使用docker run</span></span><br><span class="line">docker run \</span><br><span class="line">  -e STATIC_PATH=/path/to/your/static \</span><br><span class="line">  -v /path/to/your/static:/app/_static \</span><br><span class="line">  your-image</span><br></pre></td></tr></table></figure><h3 id="4-使用-docker-compose-override-yml（可选）"><a href="#4-使用-docker-compose-override-yml（可选）" class="headerlink" title="4. 使用 docker-compose.override.yml（可选）"></a>4. 使用 <code>docker-compose.override.yml</code>（可选）</h3><p>如果你有多个环境或配置，可以使用 <code>docker-compose.override.yml</code> 文件来覆盖默认的 <code>docker-compose.yml</code> 配置。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="variable">$&#123;STATIC_PATH&#125;</span>:/app/_static</span><br></pre></td></tr></table></figure><p>然后在运行 <code>docker-compose up</code> 时传递不同的 <code>STATIC_PATH</code> 值。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过使用环境变量，你可以轻松地在运行 <code>docker-compose up</code> 时动态传递 <code>/Users/c33/app/_static</code> 这样的路径。这种方法不仅灵活，而且便于管理不同环境下的配置。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;docker使用-docker-compose.yml动态传递变量&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://kanoc.gitee.io/categories/Docker/"/>
    
    
    <category term="工具" scheme="https://kanoc.gitee.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="教程" scheme="https://kanoc.gitee.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="build" scheme="https://kanoc.gitee.io/tags/build/"/>
    
  </entry>
  
  <entry>
    <title>docker打包Django项目教程</title>
    <link href="https://kanoc.gitee.io/2025/02/15/docker%E6%89%93%E5%8C%85Django%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/"/>
    <id>https://kanoc.gitee.io/2025/02/15/docker%E6%89%93%E5%8C%85Django%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/</id>
    <published>2025-02-15T06:24:28.000Z</published>
    <updated>2025-02-15T08:57:48.012Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>docker打包Django项目教程</strong></font></p><span id="more"></span><p>要将 Django 项目打包为 Docker 镜像，你需要创建一个 Dockerfile，并配置相关的文件和设置。以下是一个基本的步骤指南，帮助你将 Django 项目打包为 Docker 镜像。</p><h3 id="1-创建-Django-项目"><a href="#1-创建-Django-项目" class="headerlink" title="1. 创建 Django 项目"></a>1. 创建 Django 项目</h3><p>如果你还没有 Django 项目，可以使用以下命令创建一个新的 Django 项目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">django-admin startproject myproject</span><br><span class="line"><span class="built_in">cd</span> myproject</span><br></pre></td></tr></table></figure><h3 id="2-创建-Dockerfile"><a href="#2-创建-Dockerfile" class="headerlink" title="2. 创建 Dockerfile"></a>2. 创建 Dockerfile</h3><p>在 Django 项目的根目录下创建一个名为 Dockerfile 的文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用官方 Python 镜像作为基础镜像</span></span><br><span class="line">FROM python:3.9-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 requirements.txt 文件到容器中</span></span><br><span class="line">COPY requirements.txt .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖  # 这里的 ENVIRONMENT 是个变量，通过启动命令传递， 如果是mac走第一条</span></span><br><span class="line">pip install --no-cache-dir -r requirements.txt</span><br><span class="line"><span class="comment"># 复制项目文件到容器中</span></span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">EXPOSE 8000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 Django 开发服务器</span></span><br><span class="line">CMD [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;manage.py&quot;</span>, <span class="string">&quot;runserver&quot;</span>, <span class="string">&quot;0.0.0.0:8000&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="3-创建-requirements-txt"><a href="#3-创建-requirements-txt" class="headerlink" title="3. 创建 requirements.txt"></a>3. 创建 requirements.txt</h3><p>确保在项目根目录下有一个 requirements.txt 文件，列出所有的依赖项。你可以使用以下命令生成 requirements.txt：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><h3 id="4-创建-dockerignore-文件"><a href="#4-创建-dockerignore-文件" class="headerlink" title="4. 创建 .dockerignore 文件"></a>4. 创建 .dockerignore 文件</h3><p>为了避免将不必要的文件复制到 Docker 镜像中，可以创建一个 .dockerignore 文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">__pycache__</span><br><span class="line">*.pyc</span><br><span class="line">*.pyo</span><br><span class="line">*.pyd</span><br><span class="line">*.db</span><br><span class="line">*.sqlite3</span><br><span class="line">*.<span class="built_in">log</span></span><br><span class="line">*.<span class="built_in">env</span></span><br></pre></td></tr></table></figure><h3 id="5-构建-Docker-镜像"><a href="#5-构建-Docker-镜像" class="headerlink" title="5. 构建 Docker 镜像"></a>5. 构建 Docker 镜像</h3><p>在项目根目录下，使用以下命令构建 Docker 镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t mydjangoapp .</span><br></pre></td></tr></table></figure><h3 id="6-运行-Docker-容器"><a href="#6-运行-Docker-容器" class="headerlink" title="6. 运行 Docker 容器"></a>6. 运行 Docker 容器</h3><p>构建完成后，可以使用以下命令运行 Docker 容器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 8000:8000 mydjangoapp</span><br></pre></td></tr></table></figure><p>这将把容器的 8000 端口映射到主机的 8000 端口。</p><h3 id="7-访问-Django-应用"><a href="#7-访问-Django-应用" class="headerlink" title="7. 访问 Django 应用"></a>7. 访问 Django 应用</h3><p>在浏览器中访问 <a href="http://localhost:8000，你应该能够看到">http://localhost:8000，你应该能够看到</a> Django 的欢迎页面。</p><h3 id="8-数据库配置（可选）"><a href="#8-数据库配置（可选）" class="headerlink" title="8. 数据库配置（可选）"></a>8. 数据库配置（可选）</h3><p>如果你的 Django 项目使用数据库（如 PostgreSQL、MySQL 等），你需要在 Dockerfile 中添加数据库的相关配置，并确保数据库服务在容器中运行。你可以使用 Docker Compose 来管理多个服务。</p><h3 id="9-使用-Docker-Compose（可选）"><a href="#9-使用-Docker-Compose（可选）" class="headerlink" title="9. 使用 Docker Compose（可选）"></a>9. 使用 Docker Compose（可选）</h3><p>如果你希望使用 Docker Compose 来管理 Django 和数据库服务，可以创建一个 docker-compose.yml 文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: kamali:latest</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - /Users/c33/app/_static:/app/_static  <span class="comment"># 挂载路径</span></span><br><span class="line">    <span class="built_in">command</span>: python manage.py runserver 0.0.0.0:8000</span><br><span class="line">    depends_on:  <span class="comment"># 删除这一行 可以不用配置数据库</span></span><br><span class="line">      - mysql</span><br><span class="line"></span><br><span class="line">  mysql: <span class="comment"># 数据库配置 mysql 可以不要</span></span><br><span class="line">    image: mysql:8.0</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: securepassword</span><br><span class="line">      MYSQL_DATABASE: myproject</span><br><span class="line">    volumes:</span><br><span class="line">      - mysql_data:/var/lib/mysql</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mysql_data:</span><br></pre></td></tr></table></figure><p>然后使用以下命令启动服务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up   <span class="comment"># 此命令是控制台运行</span></span><br><span class="line">docker-compose up -d   <span class="comment"># 此命令是后台运行</span></span><br></pre></td></tr></table></figure><h3 id="10-直接以命令运行挂载目录或者文件"><a href="#10-直接以命令运行挂载目录或者文件" class="headerlink" title="10. 直接以命令运行挂载目录或者文件"></a>10. 直接以命令运行挂载目录或者文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t mydjangoapp .</span><br><span class="line">docker run -p 8000:8000 -v /root/settings.json:/app/settings.json mydjangoapp</span><br><span class="line"><span class="comment"># /root/settings.json 宿主机的文件路径</span></span><br><span class="line"><span class="comment"># /app/settings.json   docker环境路径</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;docker打包Django项目教程&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://kanoc.gitee.io/categories/Docker/"/>
    
    
    <category term="工具" scheme="https://kanoc.gitee.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="教程" scheme="https://kanoc.gitee.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="build" scheme="https://kanoc.gitee.io/tags/build/"/>
    
  </entry>
  
  <entry>
    <title>docker-打包python项目时标签说明</title>
    <link href="https://kanoc.gitee.io/2025/02/15/docker-%E6%89%93%E5%8C%85python%E9%A1%B9%E7%9B%AE%E6%97%B6%E6%A0%87%E7%AD%BE%E8%AF%B4%E6%98%8E/"/>
    <id>https://kanoc.gitee.io/2025/02/15/docker-%E6%89%93%E5%8C%85python%E9%A1%B9%E7%9B%AE%E6%97%B6%E6%A0%87%E7%AD%BE%E8%AF%B4%E6%98%8E/</id>
    <published>2025-02-15T06:22:23.000Z</published>
    <updated>2025-02-15T06:36:50.523Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong><code>docker</code> 打包<code>python</code>项目时标签说明</strong></font></p><span id="more"></span><h3 id="在-Docker-中一些常见的-Python-镜像标签及其含义："><a href="#在-Docker-中一些常见的-Python-镜像标签及其含义：" class="headerlink" title="在 Docker 中一些常见的 Python 镜像标签及其含义："></a>在 Docker 中一些常见的 Python 镜像标签及其含义：</h3><blockquote><h4 id="1、slim"><a href="#1、slim" class="headerlink" title="1、slim"></a>1、slim</h4><blockquote><p>描述：精简版镜像，去掉了一些不必要的文件和工具，体积较小，适合用于生产环境。</p><p>示例：python:3.12-slim</p></blockquote><h4 id="2、alpine"><a href="#2、alpine" class="headerlink" title="2、alpine"></a>2、alpine</h4><blockquote><p>描述：基于 Alpine Linux 的镜像，体积非常小，适合需要极小镜像的场景。由于 Alpine 使用 musl libc 而不是 glibc，某些 Python 库可能需要额外的配置。</p><p>示例：python:3.12-alpine</p></blockquote><h4 id="3-buster-bullseye"><a href="#3-buster-bullseye" class="headerlink" title="3. buster &#x2F; bullseye"></a>3. buster &#x2F; bullseye</h4><blockquote><p>描述：基于 Debian 的镜像，buster 是 Debian 10 的代号，bullseye 是 Debian 11 的代号。这些镜像包含了更多的工具和库，适合需要完整 Debian 环境的应用。</p><p>示例：python:3.12-buster 或 python:3.12-bullseye</p></blockquote><h4 id="4-stretch"><a href="#4-stretch" class="headerlink" title="4. stretch"></a>4. stretch</h4><blockquote><p>描述：基于 Debian Stretch（Debian 9）的镜像，适合需要较旧版本库的应用。</p><p>示例：python:3.12-stretch</p></blockquote><h4 id="5-windows"><a href="#5-windows" class="headerlink" title="5. windows"></a>5. windows</h4><blockquote><p>描述：用于 Windows 容器的 Python 镜像，适合在 Windows Server 上运行的应用。</p><p>示例：python:3.12-windows</p></blockquote><h4 id="6-latest"><a href="#6-latest" class="headerlink" title="6. latest"></a>6. latest</h4><blockquote><p>描述：指向最新版本的 Python 镜像，通常是最新的稳定版本。使用时要注意，可能会导致不兼容问题。</p><p>示例：python:latest</p></blockquote><h4 id="7-buster-bullseye-变体"><a href="#7-buster-bullseye-变体" class="headerlink" title="7. buster &#x2F; bullseye 变体"></a>7. buster &#x2F; bullseye 变体</h4><blockquote><p>描述：除了 slim 和 alpine，你还可以找到其他变体，例如 python:3.12-buster 和 python:3.12-bullseye，这些镜像包含了完整的 Debian 系统，适合需要更多依赖的应用。</p></blockquote><h4 id="8-ubuntu"><a href="#8-ubuntu" class="headerlink" title="8. ubuntu"></a>8. ubuntu</h4><blockquote><p>描述：基于 Ubuntu 的镜像，通常是最新的 LTS（长期支持）版本。这个镜像包含了完整的 Ubuntu 环境，适合需要 Ubuntu 特性和库的应用。</p><p>示例：python:3.12-ubuntu</p></blockquote><h4 id="9-focal"><a href="#9-focal" class="headerlink" title="9. focal"></a>9. focal</h4><blockquote><p>描述：基于 Ubuntu 20.04 LTS（Focal Fossa）的镜像。适合需要 Ubuntu 20.04 环境的应用。</p><p>示例：python:3.12-focal</p></blockquote><h4 id="10-jammy"><a href="#10-jammy" class="headerlink" title="10. jammy"></a>10. jammy</h4><blockquote><p>描述：基于 Ubuntu 22.04 LTS（Jammy Jellyfish）的镜像。适合需要 Ubuntu 22.04 环境的应用。</p><p>示例：python:3.12-jammy</p></blockquote><h4 id="11-bionic"><a href="#11-bionic" class="headerlink" title="11. bionic"></a>11. bionic</h4><blockquote><p>描述：基于 Ubuntu 18.04 LTS（Bionic Beaver）的镜像。适合需要较旧版本 Ubuntu 的应用。</p><p>示例：python:3.12-bionic</p></blockquote><h4 id="12-具体版本"><a href="#12-具体版本" class="headerlink" title="12. 具体版本"></a>12. 具体版本</h4><blockquote><p>描述：你可以指定具体的 Python 版本，例如 python:3.12.1，这将确保你使用的是特定的 Python 版本。</p><p>示例：python:3.12.1</p></blockquote></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>根据你的需求，可以选择不同的标签来构建 Docker 镜像。slim 和 alpine 适合需要小镜像的场景，而 buster 和 bullseye 则适合需要完整 Debian 环境的应用。选择合适的基础镜像可以帮助你优化应用的性能和体积。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;&lt;code&gt;docker&lt;/code&gt; 打包&lt;code&gt;python&lt;/code&gt;项目时标签说明&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="打包" scheme="https://kanoc.gitee.io/tags/%E6%89%93%E5%8C%85/"/>
    
    <category term="标签" scheme="https://kanoc.gitee.io/tags/%E6%A0%87%E7%AD%BE/"/>
    
    <category term="说明" scheme="https://kanoc.gitee.io/tags/%E8%AF%B4%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu-强制修改密码为简单密码</title>
    <link href="https://kanoc.gitee.io/2025/02/15/ubuntu-%E5%BC%BA%E5%88%B6%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E4%B8%BA%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81/"/>
    <id>https://kanoc.gitee.io/2025/02/15/ubuntu-%E5%BC%BA%E5%88%B6%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E4%B8%BA%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81/</id>
    <published>2025-02-14T23:49:19.000Z</published>
    <updated>2025-02-14T23:55:46.215Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>ubuntu 强制修改密码为简单密码</strong></font></p><span id="more"></span><p>在 <code>Ubuntu</code> 中，出于安全考虑，系统通常会强制要求密码满足一定的复杂性和长度要求。默认情况下，root 密码必须至少包含 8 个字符。但是我们本地测试环境，不需要那么复杂的密码。越简单的密码越容易使用。</p><p>这个时候我们可以 使用 临时禁用密码复杂性检查来修改</p><h3 id="1-修改-PAM-配置"><a href="#1-修改-PAM-配置" class="headerlink" title="1. 修改 PAM 配置"></a>1. 修改 PAM 配置</h3><ol><li>打开终端。</li><li>编辑 PAM 密码策略配置：</li></ol><p>使用以下命令打开 common-password 文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/pam.d/common-password</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># passwordrequisitepam_pwquality.so retry=3  此为修改前的内容</span></span><br><span class="line">password requisite pam_unix.so nullok obscure min=0 max=8  <span class="comment"># 此为修改后的内容</span></span><br><span class="line">password[success=2 default=ignore]pam_unix.so obscure use_authtok try_first_pass yescrypt</span><br><span class="line">passwordsufficientpam_sss.so use_authtok</span><br><span class="line">passwordrequisitepam_deny.so</span><br><span class="line">passwordrequiredpam_permit.so</span><br><span class="line">passwordoptionalpam_gnome_keyring.so </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;ubuntu 强制修改密码为简单密码&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="系统" scheme="https://kanoc.gitee.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="ubuntu" scheme="https://kanoc.gitee.io/categories/%E7%B3%BB%E7%BB%9F/ubuntu/"/>
    
    
    <category term="root" scheme="https://kanoc.gitee.io/tags/root/"/>
    
    <category term="密码" scheme="https://kanoc.gitee.io/tags/%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu安装配置docker</title>
    <link href="https://kanoc.gitee.io/2025/02/15/ubuntu%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEdocker/"/>
    <id>https://kanoc.gitee.io/2025/02/15/ubuntu%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEdocker/</id>
    <published>2025-02-14T23:18:23.000Z</published>
    <updated>2025-02-15T06:53:26.095Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>ubuntu安装配置docker</strong></font></p><span id="more"></span><h3 id="1-更新系统"><a href="#1-更新系统" class="headerlink" title="1. 更新系统"></a>1. 更新系统</h3><p>在 Ubuntu 中打开终端，更新系统：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt upgrade</span><br></pre></td></tr></table></figure><h3 id="2-安装-Snap"><a href="#2-安装-Snap" class="headerlink" title="2.  安装 Snap"></a>2.  安装 Snap</h3><p>如果你的系统尚未安装 Snap，可以使用以下命令安装：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install snapd</span><br></pre></td></tr></table></figure><h3 id="3-使用-Snap-安装-Docker"><a href="#3-使用-Snap-安装-Docker" class="headerlink" title="3. 使用 Snap 安装 Docker"></a>3. 使用 Snap 安装 Docker</h3><p>使用以下命令通过 Snap 安装 Docker：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> snap install docker</span><br></pre></td></tr></table></figure><h3 id="4-启动-Docker-服务"><a href="#4-启动-Docker-服务" class="headerlink" title="4. 启动 Docker 服务"></a>4. 启动 Docker 服务</h3><p>安装完成后，Docker 服务应该会自动启动。你可以使用以下命令检查 Docker 服务的状态：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl status snap.docker.dockerd</span><br></pre></td></tr></table></figure><p>如果服务没有运行，可以使用以下命令启动它：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start snap.docker.dockerd</span><br></pre></td></tr></table></figure><h3 id="4-配置国内镜像加速器-国外服务器忽略"><a href="#4-配置国内镜像加速器-国外服务器忽略" class="headerlink" title="4. 配置国内镜像加速器(国外服务器忽略)"></a>4. 配置国内镜像加速器(国外服务器忽略)</h3><ul><li><code>vim /etc/docker/daemon.json</code></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line"><span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://docker.mirrors.tuna.tsinghua.edu.cn&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://www.daocloud.io/mirror&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://mirror.ccs.tencentyun.com&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://hub-mirror.c.163.com&quot;</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-重启-docker服务"><a href="#5-重启-docker服务" class="headerlink" title="5. 重启 docker服务"></a>5. 重启 docker服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="6-验证-Docker-安装"><a href="#6-验证-Docker-安装" class="headerlink" title="6. 验证 Docker 安装"></a>6. 验证 Docker 安装</h3><p>运行以下命令以验证 Docker 是否安装成功：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker --version</span><br></pre></td></tr></table></figure><h3 id="7-运行-Docker-Hello-World-示例"><a href="#7-运行-Docker-Hello-World-示例" class="headerlink" title="7. 运行 Docker Hello World 示例"></a>7. 运行 Docker Hello World 示例</h3><p>为了确保 Docker 正常工作，可以运行一个简单的 Hello World 容器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run hello-world</span><br></pre></td></tr></table></figure><p>如果一切正常，你将看到一条消息，表明 Docker 已成功安装并运行。</p><h3 id="8-（可选）将用户添加到-Docker-组"><a href="#8-（可选）将用户添加到-Docker-组" class="headerlink" title="8. （可选）将用户添加到 Docker 组"></a>8. （可选）将用户添加到 Docker 组</h3><p>如果你希望在不使用 sudo 的情况下运行 Docker 命令，可以将你的用户添加到 Docker 组：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p>添加后，注销并重新登录，或者重启系统以使更改生效。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过 Snap 安装 Docker 是一种简单的方法，适合在 Ubuntu 上快速部署 Docker。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;ubuntu安装配置docker&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="系统" scheme="https://kanoc.gitee.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="ubuntu" scheme="https://kanoc.gitee.io/categories/%E7%B3%BB%E7%BB%9F/ubuntu/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="安装" scheme="https://kanoc.gitee.io/tags/%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu-共享文件夹_samba</title>
    <link href="https://kanoc.gitee.io/2025/02/15/ubuntu-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9-samba/"/>
    <id>https://kanoc.gitee.io/2025/02/15/ubuntu-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9-samba/</id>
    <published>2025-02-14T23:08:39.000Z</published>
    <updated>2025-02-15T04:21:15.963Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>ubuntu 共享文件夹 For samba</strong></font></p><span id="more"></span><p>在 Ubuntu 中共享文件夹可以通过多种方式实现，最常见的方法是使用 Samba（适用于 Windows 和 Linux 之间的共享）或 NFS（适用于 Linux 之间的共享）。以下是这两种方法的详细步骤。</p><h3 id="方法-1：使用-Samba-共享文件夹"><a href="#方法-1：使用-Samba-共享文件夹" class="headerlink" title="方法 1：使用 Samba 共享文件夹"></a>方法 1：使用 Samba 共享文件夹</h3><h4 id="1-安装-Samba"><a href="#1-安装-Samba" class="headerlink" title="1. 安装 Samba"></a>1. 安装 Samba</h4><p>首先，确保你的系统已安装 Samba。打开终端并运行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install samba</span><br></pre></td></tr></table></figure><h4 id="2-创建共享文件夹"><a href="#2-创建共享文件夹" class="headerlink" title="2. 创建共享文件夹"></a>2. 创建共享文件夹</h4><p>选择一个目录作为共享文件夹，或者创建一个新的文件夹。例如，创建一个名为 shared 的文件夹：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/shared</span><br></pre></td></tr></table></figure><h4 id="3-配置-Samba"><a href="#3-配置-Samba" class="headerlink" title="3. 配置 Samba"></a>3. 配置 Samba</h4><p>编辑 Samba 配置文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/samba/smb.conf</span><br></pre></td></tr></table></figure><p>在文件的末尾添加以下内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 [global] 部分中，添加或修改以下设置：  开启全速</span></span><br><span class="line"> [global]</span><br><span class="line">   max connections = 100  <span class="comment"># 增加并发性能</span></span><br><span class="line">   max open files = 10000  <span class="comment"># 增加并发性能</span></span><br><span class="line">   <span class="comment"># 性能优化设置</span></span><br><span class="line">   socket options = TCP_NODELAY SO_RCVBUF=8192 SO_SNDBUF=8192</span><br><span class="line">   max protocol = SMB3</span><br><span class="line">   min protocol = SMB2</span><br><span class="line">   </span><br><span class="line">[MyFiles]</span><br><span class="line">   path = /home/kate/SambaFiles</span><br><span class="line">   available = <span class="built_in">yes</span></span><br><span class="line">   valid <span class="built_in">users</span> = root</span><br><span class="line">   <span class="built_in">read</span> only = no</span><br><span class="line">   browsable = <span class="built_in">yes</span></span><br><span class="line">   public = <span class="built_in">yes</span></span><br><span class="line">   writable = <span class="built_in">yes</span></span><br><span class="line">   create mask = 0755</span><br><span class="line">   directory mask = 0755</span><br></pre></td></tr></table></figure><p>请将 your_username 替换为你的实际用户名。</p><h4 id="4-设置-Samba-用户"><a href="#4-设置-Samba-用户" class="headerlink" title="4. 设置 Samba 用户"></a>4. 设置 Samba 用户</h4><p>为 Samba 设置用户密码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> smbpasswd -a your_username</span><br></pre></td></tr></table></figure><h4 id="5-重启-Samba-服务"><a href="#5-重启-Samba-服务" class="headerlink" title="5. 重启 Samba 服务"></a>5. 重启 Samba 服务</h4><p>重启 Samba 服务以使更改生效：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart smbd</span><br></pre></td></tr></table></figure><h4 id="6-访问共享文件夹"><a href="#6-访问共享文件夹" class="headerlink" title="6. 访问共享文件夹"></a>6. 访问共享文件夹</h4><p>在 Windows 系统中，你可以通过以下方式访问共享文件夹：</p><ol><li>打开文件资源管理器。</li></ol><p>在地址栏中输入 \your_ubuntu_ip\SharedFolder，将 your_ubuntu_ip 替换为 Ubuntu 机器的 IP 地址。</p><p>输入 Samba 用户名和密码进行访问。</p><h3 id="方法-2：使用-NFS-共享文件夹"><a href="#方法-2：使用-NFS-共享文件夹" class="headerlink" title="方法 2：使用 NFS 共享文件夹"></a>方法 2：使用 NFS 共享文件夹</h3><p>NFS（网络文件系统）适用于 Linux 之间的共享。</p><h4 id="1-安装-NFS"><a href="#1-安装-NFS" class="headerlink" title="1. 安装 NFS"></a>1. 安装 NFS</h4><p>首先，确保你的系统已安装 NFS：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install nfs-kernel-server</span><br></pre></td></tr></table></figure><h4 id="2-创建共享文件夹-1"><a href="#2-创建共享文件夹-1" class="headerlink" title="2. 创建共享文件夹"></a>2. 创建共享文件夹</h4><p>选择一个目录作为共享文件夹，或者创建一个新的文件夹。例如，创建一个名为 shared 的文件夹：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/shared</span><br></pre></td></tr></table></figure><h4 id="3-配置-NFS"><a href="#3-配置-NFS" class="headerlink" title="3. 配置 NFS"></a>3. 配置 NFS</h4><p>编辑 NFS 配置文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/exports</span><br></pre></td></tr></table></figure><p>在文件中添加以下行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/your_username/shared *(rw,<span class="built_in">sync</span>,no_subtree_check)</span><br></pre></td></tr></table></figure><p>请将 your_username 替换为你的实际用户名。</p><h4 id="4-重启-NFS-服务"><a href="#4-重启-NFS-服务" class="headerlink" title="4. 重启 NFS 服务"></a>4. 重启 NFS 服务</h4><p>重启 NFS 服务以使更改生效：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> exportfs -a</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart nfs-kernel-server</span><br></pre></td></tr></table></figure><h4 id="5-访问共享文件夹"><a href="#5-访问共享文件夹" class="headerlink" title="5. 访问共享文件夹"></a>5. 访问共享文件夹</h4><p>在另一台 Linux 机器上，你可以通过以下命令挂载 NFS 共享：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mount your_ubuntu_ip:/home/your_username/shared /mnt</span><br></pre></td></tr></table></figure><p>将 your_ubuntu_ip 替换为 Ubuntu 机器的 IP 地址，&#x2F;mnt 是你希望挂载的本地目录。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上步骤，你可以在 Ubuntu 中共享文件夹。选择 Samba 或 NFS 取决于你的需求和网络环境。如果在配置或使用过程中遇到任何问题，请提供具体的错误信息，以便进一步排查。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;ubuntu 共享文件夹 For samba&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="系统" scheme="https://kanoc.gitee.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="ubuntu" scheme="https://kanoc.gitee.io/categories/%E7%B3%BB%E7%BB%9F/ubuntu/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="挂载" scheme="https://kanoc.gitee.io/tags/%E6%8C%82%E8%BD%BD/"/>
    
    <category term="文件夹共享" scheme="https://kanoc.gitee.io/tags/%E6%96%87%E4%BB%B6%E5%A4%B9%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose部署dockerc程序</title>
    <link href="https://kanoc.gitee.io/2025/02/07/docker-compose%E9%83%A8%E7%BD%B2dockerc%E7%A8%8B%E5%BA%8F/"/>
    <id>https://kanoc.gitee.io/2025/02/07/docker-compose%E9%83%A8%E7%BD%B2dockerc%E7%A8%8B%E5%BA%8F/</id>
    <published>2025-02-06T16:30:05.000Z</published>
    <updated>2025-02-12T10:24:40.822Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong><code>docker-compose</code> 部署 <code>dockerc</code>程序</strong></font></p><p>要在 Docker 中安装 MySQL，并配置为开机自动启动、断线自动重启，并设置日志大小限制为 5MB，你可以按照以下步骤进行操作：</p><span id="more"></span><h3 id="1-创建-Docker-Compose-文件"><a href="#1-创建-Docker-Compose-文件" class="headerlink" title="1. 创建 Docker Compose 文件"></a>1. 创建 Docker Compose 文件</h3><p>使用 <code>Docker Compose</code> 可以更方便地管理容器的配置。首先，确保你已经安装了 <code>Docker</code> 和 <code>Docker Compose</code>。</p><p>创建一个名为<code>docker-compose.yml</code>的文件，并添加以下内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span>  <span class="comment"># 设置容器在退出时自动重启</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">your_root_password</span>  <span class="comment"># 设置 MySQL root 用户的密码</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">your_database_name</span>        <span class="comment"># 创建一个默认数据库</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">your_username</span>                  <span class="comment"># 创建一个用户</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">your_user_password</span>         <span class="comment"># 设置用户密码</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span>  <span class="comment"># 映射 MySQL 端口</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span>  <span class="comment"># 持久化数据</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql_logs:/var/log/mysql</span>  <span class="comment"># 持久化日志</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_data:</span></span><br></pre></td></tr></table></figure><h3 id="2-配置日志大小"><a href="#2-配置日志大小" class="headerlink" title="2. 配置日志大小"></a>2. 配置日志大小</h3><p>要限制 <code>MySQL</code> 日志的大小为 <code>5MB</code>，你可以在 <code>MySQL</code> 配置中添加相关设置。创建一个名为 <code>my.cnf</code> 的配置文件，并添加以下内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">*# 设置日志文件大小限制*</span><br><span class="line"></span><br><span class="line">max_binlog_size = 5M</span><br></pre></td></tr></table></figure><h3 id="3-更新-Docker-Compose-文件以使用自定义配置"><a href="#3-更新-Docker-Compose-文件以使用自定义配置" class="headerlink" title="3. 更新 Docker Compose 文件以使用自定义配置"></a>3. 更新 <code>Docker Compose</code> 文件以使用自定义配置</h3><p>更新 <code>docker-compose.yml</code> 文件以使用自定义的 <code>MySQL</code> 配置文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span>  <span class="comment"># 设置容器在退出时自动重启</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">your_root_password</span>  <span class="comment"># 设置 MySQL root 用户的密码</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">your_database_name</span>        <span class="comment"># 创建一个默认数据库</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">your_username</span>                  <span class="comment"># 创建一个用户</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">your_user_password</span>         <span class="comment"># 设置用户密码</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span>  <span class="comment"># 映射 MySQL 端口</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span>  <span class="comment"># 持久化数据</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql_logs:/var/log/mysql</span>  <span class="comment"># 持久化日志</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./my.cnf:/etc/mysql/conf.d/my.cnf</span>  <span class="comment"># 使用自定义配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_data:</span></span><br></pre></td></tr></table></figure><h3 id="4-启动-MySQL-容器"><a href="#4-启动-MySQL-容器" class="headerlink" title="4. 启动 MySQL 容器"></a>4. 启动 <code>MySQL</code> 容器</h3><p>在包含 <code>docker-compose.yml</code> 和 <code>my.cnf</code> 文件的目录中，运行以下命令以启动 <code>MySQL</code> 容器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h3 id="5-验证-MySQL-容器状态"><a href="#5-验证-MySQL-容器状态" class="headerlink" title="5. 验证 MySQL 容器状态"></a>5. 验证 MySQL 容器状态</h3><p>你可以使用以下命令检查 <code>MySQL</code> 容器的状态：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><h3 id="6-查看日志"><a href="#6-查看日志" class="headerlink" title="6. 查看日志"></a>6. 查看日志</h3><p>要查看 <code>MySQL</code> 容器的日志，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs &lt;container_id_or_name&gt;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上步骤，你应该能够成功在 <code>Docker</code> 中安装 <code>MySQL</code>，并配置为开机自动启动、断线自动重启，并设置日志大小限制为 <code>5MB</code>。如果你有其他问题或需要进一步的帮助，请告诉我！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;&lt;code&gt;docker-compose&lt;/code&gt; 部署 &lt;code&gt;dockerc&lt;/code&gt;程序&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;要在 Docker 中安装 MySQL，并配置为开机自动启动、断线自动重启，并设置日志大小限制为 5MB，你可以按照以下步骤进行操作：&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://kanoc.gitee.io/categories/Docker/"/>
    
    
    <category term="工具" scheme="https://kanoc.gitee.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="数据库" scheme="https://kanoc.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>在苹果Silicon芯片（M1/M2/M3）Mac电脑上使用Docker</title>
    <link href="https://kanoc.gitee.io/2025/02/06/%E5%9C%A8%E8%8B%B9%E6%9E%9CSilicon%E8%8A%AF%E7%89%87%EF%BC%88M1-M2-M3%EF%BC%89Mac%E7%94%B5%E8%84%91%E4%B8%8A%E4%BD%BF%E7%94%A8Docker/"/>
    <id>https://kanoc.gitee.io/2025/02/06/%E5%9C%A8%E8%8B%B9%E6%9E%9CSilicon%E8%8A%AF%E7%89%87%EF%BC%88M1-M2-M3%EF%BC%89Mac%E7%94%B5%E8%84%91%E4%B8%8A%E4%BD%BF%E7%94%A8Docker/</id>
    <published>2025-02-05T20:10:02.000Z</published>
    <updated>2025-02-05T20:15:17.355Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>在苹果Silicon芯片（M1&#x2F;M2&#x2F;M3）Mac电脑上使用Docker</strong></font></p><h6 id="本文搬运自在苹果Silicon芯片（M1-M2-M3）Mac电脑上使用Docker-教程-Tinkink"><a href="#本文搬运自在苹果Silicon芯片（M1-M2-M3）Mac电脑上使用Docker-教程-Tinkink" class="headerlink" title="本文搬运自在苹果Silicon芯片（M1&#x2F;M2&#x2F;M3）Mac电脑上使用Docker | 教程 | Tinkink"></a>本文搬运自<a href="https://tutorials.tinkink.net/zh-hans/mac/how-to-use-docker-on-m1-mac.html">在苹果Silicon芯片（M1&#x2F;M2&#x2F;M3）Mac电脑上使用Docker | 教程 | Tinkink</a></h6><span id="more"></span><h2 id="背景和困难"><a href="#背景和困难" class="headerlink" title="背景和困难"></a>背景和困难</h2><p>苹果于 2020 年正式发布了搭载自研芯片 Apple Silicon 的电脑，随电脑发布的第一款芯片型号为 M1 。这款芯片的架构由经典的 x86 改为了 ARM 架构。</p><p>为了解决 CPU 架构变更带来的软件不兼容问题，苹果在 MacOS 中附带了用了转译 APP 代码的 Rosetta 2 。这个软件可以在运行时将 x86 架构的代码转译为 ARM 架构的代码，从而使得大部分软件无缝地运行在搭载新芯片的 MacOS 上。</p><p>尽管大部分的软件已经可以在 Apple Silicon （M1&#x2F;M2&#x2F;M3）芯片上正常运行，但有一类特殊的软件却一直无法很顺利地运行——虚拟化软件。这包括虚拟机和 Docker 之类的软件。</p><p>经典的虚拟机软件如 VirtualBox 明确表示没有支持计划。而 Parallels Desktop 虽然支持，但价格让人望而生畏。</p><p>因为 Docker 在非 Linux 系统中实际上也依赖于一个虚拟化的 Linux 作为 Host，因此在虚拟机没有完善的解决方法时，Docker 也是没有办法顺畅运行的。</p><h2 id="官方方案"><a href="#官方方案" class="headerlink" title="官方方案"></a>官方方案</h2><p>Docker Desktop For Mac 提供了可以在 Apple Silicon 芯片上运行的版本，它使用了 QEMU 来处理不同架构的虚拟化问题。但是它对有一定规模的公司不再免费。因此如果你在一个稍具规模的公司，可能不会选择使用 Docker Desktop For Mac。如果你是个人使用，那么 Docker Desktop For Mac 仍然是一个非常不错的解决方案。</p><h2 id="Lima"><a href="#Lima" class="headerlink" title="Lima"></a>Lima</h2><p><a href="https://github.com/lima-vm/lima">Lima</a> 是一个免费的开源软件，同样使用 QEMU 来处理不同架构的虚拟化问题。和 Docker Desktop For Mac 不同的是，它的容器软件使用的是 Containerd 而不是 Docker。</p><blockquote><p>在容器的发展历史中，一开始只有 Docker ，但随后社区希望容器可以标准化，因此诞生了 CRI 标准。Containerd 是一个这个标准的一种实现，Docker 也同样遵守这个标准。因此 Containerd 与 Docker 在使用时几乎可以兼容。</p></blockquote><p>按照官方教程，使用 Homebrew 安装 lima 之后就可以使用了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">brew install lima</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">limactl start</span><br></pre></td></tr></table></figure><p>此时就可以使用<code>nerdctl</code>来进行 Containerd 的各种操作。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lima nerdctl run -d --name nginx -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure><p>可以看到，<code>lima nerdctl</code>的使用与<code>docker</code>几乎一模一样。使用完成后除了将容器关掉外，还可以将虚拟化环境也关闭，以节约内存：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">limactl stop</span><br></pre></td></tr></table></figure><p>lima 还可以设置非常多虚拟化的细节，也可以设置多个虚拟环境。更多使用细节可查看官方文档：&lt;(<a href="https://github.com/lima-vm/lima%3E">https://github.com/lima-vm/lima&gt;</a></p><h2 id="Colima"><a href="#Colima" class="headerlink" title="Colima"></a>Colima</h2><p><a href="https://github.com/abiosoft/colima">Colima</a> 是一个基于 Lima 的封装，同样是免费的开源软件，但是它的容器软件使用的是 Docker。</p><p>Colima 的安装使用也非常简单：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果你没有安装过 docker 客户端，需要先安装</span></span><br><span class="line">brew install docker</span><br><span class="line"><span class="comment"># 安装 colima</span></span><br><span class="line">brew install colima</span><br></pre></td></tr></table></figure><p>使用时，只需要使用 <code>colima</code> 命令即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colima start</span><br></pre></td></tr></table></figure><p>待启动完成后，就可以正常使用<code>docker</code>命令了，不需要额外进行其它的设置。</p><p>使用完成后同样可以将虚拟化环境关闭：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colima stop</span><br></pre></td></tr></table></figure><h2 id="OrbStack"><a href="#OrbStack" class="headerlink" title="OrbStack"></a>OrbStack</h2><p>“OrbStack 是在 macOS 上运行 Docker 容器和 Linux 机器的快速、轻量、简单的方式。您可以将其视为超级 WSL 和 Docker Desktop 的 macOS 版本，所有这些都在一个易于使用的应用程序中。”（来自官方网站。）</p><p>OrbStack 提供了一个 GUI 界面来管理 macOS 上的 Docker 容器和 Linux 机器。以及一个命令行界面。</p><p>您可以从官方网站下载：<a href="https://orbstack.dev/%EF%BC%8C%E6%88%96%E4%BD%BF%E7%94%A8">https://orbstack.dev/，或使用</a> Homebrew 安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install --cask orbstack</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Running `brew update --auto-update`...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">==&gt; Caveats</span><br><span class="line">Open the OrbStack app to finish setup.</span><br><span class="line"></span><br><span class="line">==&gt; Downloading https://cdn-updates.orbstack.dev/arm64/OrbStack_v0.5.1_985_arm64.dmg</span><br><span class="line"><span class="comment">######################################################################## 100.0%</span></span><br><span class="line">==&gt; Installing Cask orbstack</span><br><span class="line">==&gt; Moving App <span class="string">&#x27;OrbStack.app&#x27;</span> to <span class="string">&#x27;/Applications/OrbStack.app&#x27;</span></span><br><span class="line">🍺  orbstack was successfully installed!</span><br></pre></td></tr></table></figure><p>只需启动 OrbStack，您现在就可以使用 Docker 了。</p><p><img src="https://tutorials.tinkink.net/assets/01.screenshot-orbstack.a5020e54.png" alt="OrbStack 的截图"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>Apple Silicon 芯片的 Mac 设备使用 Docker 不是很容易</li><li>Docker Desktop For Mac 可用，但是对大中型公司收费</li><li>Lima &amp; Colima 是免费开源的解决方案</li><li>OrbStack 是一个 GUI 解决方案</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;在苹果Silicon芯片（M1&amp;#x2F;M2&amp;#x2F;M3）Mac电脑上使用Docker&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;h6 id=&quot;本文搬运自在苹果Silicon芯片（M1-M2-M3）Mac电脑上使用Docker-教程-Tinkink&quot;&gt;&lt;a href=&quot;#本文搬运自在苹果Silicon芯片（M1-M2-M3）Mac电脑上使用Docker-教程-Tinkink&quot; class=&quot;headerlink&quot; title=&quot;本文搬运自在苹果Silicon芯片（M1&amp;#x2F;M2&amp;#x2F;M3）Mac电脑上使用Docker | 教程 | Tinkink&quot;&gt;&lt;/a&gt;本文搬运自&lt;a href=&quot;https://tutorials.tinkink.net/zh-hans/mac/how-to-use-docker-on-m1-mac.html&quot;&gt;在苹果Silicon芯片（M1&amp;#x2F;M2&amp;#x2F;M3）Mac电脑上使用Docker | 教程 | Tinkink&lt;/a&gt;&lt;/h6&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://kanoc.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="mongodb" scheme="https://kanoc.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/"/>
    
    
    <category term="python" scheme="https://kanoc.gitee.io/tags/python/"/>
    
    <category term="mongodb" scheme="https://kanoc.gitee.io/tags/mongodb/"/>
    
    <category term="django" scheme="https://kanoc.gitee.io/tags/django/"/>
    
    <category term="Centos7" scheme="https://kanoc.gitee.io/tags/Centos7/"/>
    
    <category term="数据库" scheme="https://kanoc.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>nodejs部署后端项目教程</title>
    <link href="https://kanoc.gitee.io/2024/12/13/nodejs%E9%83%A8%E7%BD%B2%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/"/>
    <id>https://kanoc.gitee.io/2024/12/13/nodejs%E9%83%A8%E7%BD%B2%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/</id>
    <published>2024-12-13T09:28:45.000Z</published>
    <updated>2024-12-13T09:32:28.678Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>nodejs部署后端项目教程(以部署图片压缩接口为例)</strong></font></p><span id="more"></span><p>这里我们将使用 Node.js 和 Express 框架来构建后端，并使用 <code>sharp</code> 库来进行图片压缩。</p><p>首先，确保你已经安装了 Node.js 和 npm。然后，创建一个新的项目目录，并初始化一个新的 Node.js 项目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> image-compressor-backend</span><br><span class="line"><span class="built_in">cd</span> image-compressor-backend</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>接下来，安装所需的依赖项：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install express sharp multer</span><br></pre></td></tr></table></figure><p>然后，创建一个 <code>server.js</code> 文件，并添加以下代码来构建后端服务：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> sharp = <span class="built_in">require</span>(<span class="string">&#x27;sharp&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">&#x27;multer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3001</span>; <span class="comment">// 确保与前端通信的端口不同</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置 multer 存储配置</span></span><br><span class="line"><span class="keyword">const</span> storage = multer.<span class="title function_">memoryStorage</span>();</span><br><span class="line"><span class="keyword">const</span> upload = <span class="title function_">multer</span>(&#123; <span class="attr">storage</span>: storage &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 处理图片压缩请求</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/compress&#x27;</span>, upload.<span class="title function_">single</span>(<span class="string">&#x27;image&#x27;</span>), <span class="title function_">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> file = req.<span class="property">file</span>;</span><br><span class="line">  <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">send</span>(<span class="string">&#x27;No file uploaded.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">const</span> quality = <span class="built_in">parseInt</span>(req.<span class="property">body</span>.<span class="property">quality</span>, <span class="number">10</span>) || <span class="number">80</span>; <span class="comment">// 默认质量为80%</span></span><br><span class="line">  <span class="keyword">const</span> maxWidth = <span class="built_in">parseInt</span>(req.<span class="property">body</span>.<span class="property">maxWidth</span>, <span class="number">10</span>) || <span class="number">2000</span>;</span><br><span class="line">  <span class="keyword">const</span> maxHeight = <span class="built_in">parseInt</span>(req.<span class="property">body</span>.<span class="property">maxHeight</span>, <span class="number">10</span>) || <span class="number">2000</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 sharp 进行图片压缩</span></span><br><span class="line">    <span class="keyword">const</span> compressedBuffer = <span class="keyword">await</span> <span class="title function_">sharp</span>(file.<span class="property">buffer</span>)</span><br><span class="line">      .<span class="title function_">resize</span>(&#123; <span class="attr">width</span>: maxWidth, <span class="attr">height</span>: maxHeight, <span class="attr">fit</span>: <span class="string">&#x27;inside&#x27;</span>, <span class="attr">withoutEnlargement</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">      .<span class="title function_">jpeg</span>(&#123; <span class="attr">quality</span>: quality &#125;)</span><br><span class="line">      .<span class="title function_">toBuffer</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置响应头并发送压缩后的图片</span></span><br><span class="line">    res.<span class="title function_">set</span>(&#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;image/jpeg&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Content-Length&#x27;</span>: compressedBuffer.<span class="property">length</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    res.<span class="title function_">send</span>(compressedBuffer);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error compressing image:&#x27;</span>, error);</span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;Error compressing image.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server is running at http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个后端服务监听在端口 3001 上，并提供了一个 <code>/compress</code> 路由来处理图片压缩请求。它使用 <code>multer</code> 中间件来处理文件上传，并使用 <code>sharp</code> 库来进行图片压缩。</p><p>前端代码需要稍作修改以与这个后端服务配合。特别是，<code>compressFile</code> 函数需要发送一个请求到后端来压缩图片。这里是一个修改后的 <code>compressFile</code> 函数示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设你有一个字典来存储文件名和对应的文件对象</span></span><br><span class="line">files = &#123;</span><br><span class="line">    <span class="string">&#x27;example.jpg&#x27;</span>: <span class="built_in">open</span>(<span class="string">&#x27;path/to/example.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compress_file</span>(<span class="params">file_name</span>):</span><br><span class="line">    file_data = files.get(file_name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> file_data:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取质量值（这里假设是从某个地方获取的，比如用户输入）</span></span><br><span class="line">    quality = <span class="number">80</span>  <span class="comment"># 示例值，你可以从UI或其他地方获取这个值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置最大宽度和高度</span></span><br><span class="line">    max_width = <span class="number">2000</span></span><br><span class="line">    max_height = <span class="number">2000</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建表单数据</span></span><br><span class="line">    form_data = &#123;</span><br><span class="line">        <span class="string">&#x27;image&#x27;</span>: file_data,</span><br><span class="line">        <span class="string">&#x27;quality&#x27;</span>: quality,</span><br><span class="line">        <span class="string">&#x27;maxWidth&#x27;</span>: max_width,</span><br><span class="line">        <span class="string">&#x27;maxHeight&#x27;</span>: max_height</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 发送POST请求</span></span><br><span class="line">        response = requests.post(<span class="string">&#x27;http://localhost:3001/compress&#x27;</span>, files=form_data)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查响应状态码</span></span><br><span class="line">        <span class="keyword">if</span> response.status_code != <span class="number">200</span>:</span><br><span class="line">            response.raise_for_status()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取压缩后的图像数据</span></span><br><span class="line">        compressed_image_data = response.content</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将图像数据保存为文件</span></span><br><span class="line">        compressed_file_name = <span class="string">&#x27;compressed-&#x27;</span> + file_name</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(compressed_file_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> compressed_file:</span><br><span class="line">            compressed_file.write(compressed_image_data)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新文件字典（如果需要）</span></span><br><span class="line">        files[file_name] = &#123;</span><br><span class="line">            <span class="string">&#x27;original&#x27;</span>: file_data,</span><br><span class="line">            <span class="string">&#x27;compressed&#x27;</span>: <span class="built_in">open</span>(compressed_file_name, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新文件列表（这个函数需要你根据实际需求实现）</span></span><br><span class="line">        update_file_list()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> requests.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;压缩 <span class="subst">&#123;file_name&#125;</span> 失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例调用</span></span><br><span class="line">compress_file(<span class="string">&#x27;example.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：这个函数需要在适当的地方被调用，并且需要确保文件路径和服务器地址是正确的。</span></span><br></pre></td></tr></table></figure><p>请注意，这个示例假设前端和后端运行在同一个域下，或者你已经配置了 CORS（跨源资源共享）来允许前端与后端通信。如果你遇到跨域问题，你可能需要在后端添加适当的 CORS 头。</p><p>现在，当你运行后端服务器并使用前端页面上传和压缩图片时，前端会将图片发送到后端的 <code>/compress</code> 路由，后端会使用 <code>sharp</code> 库进行压缩，并将压缩后的图片发送回前端。前端然后会显示压缩后的图片，并提供下载选项。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;nodejs部署后端项目教程(以部署图片压缩接口为例)&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://kanoc.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="nodejs" scheme="https://kanoc.gitee.io/categories/%E5%90%8E%E7%AB%AF/nodejs/"/>
    
    
    <category term="教程" scheme="https://kanoc.gitee.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="服务器" scheme="https://kanoc.gitee.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="nodejs" scheme="https://kanoc.gitee.io/tags/nodejs/"/>
    
    <category term="后端" scheme="https://kanoc.gitee.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>alibaba3 使用Python管理器pyenv安装python3.13</title>
    <link href="https://kanoc.gitee.io/2024/12/09/alibaba3%E5%AE%89%E8%A3%85python3-13/"/>
    <id>https://kanoc.gitee.io/2024/12/09/alibaba3%E5%AE%89%E8%A3%85python3-13/</id>
    <published>2024-12-08T22:08:52.000Z</published>
    <updated>2024-12-08T23:52:40.983Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong></strong></font></p><span id="more"></span><p><font color=#f26522 size=4 face=宋体><strong></strong></font></p><p><font color=#b0171f size=2 face=宋体><strong></strong></font></p><ul><li><p>使用 <code>pyenv</code> 安装 Python 3.12 是一个灵活且方便的方法，它允许你在同一个系统上管理多个 Python 版本。以下是使用 <code>pyenv</code> 安装 Python 3.12 的详细步骤：</p><h3 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h3><p>首先，你需要安装一些依赖项，这些依赖项在编译 Python 源代码时是必需的。在 CentOS 7 上，你可以使用 <code>yum</code> 来安装这些依赖项：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y gcc zlib-devel bzip2-devel libffi-devel readline-devel sqlite-devel openssl-devel tk-devel xz-devel libffi-devel</span><br></pre></td></tr></table></figure><h3 id="2-安装-pyenv"><a href="#2-安装-pyenv" class="headerlink" title="2. 安装 pyenv"></a>2. 安装 pyenv</h3><p>接下来，你需要安装 <code>pyenv</code>。<code>pyenv</code> 是一个用 Bash 编写的脚本，它允许你轻松切换和管理多个 Python 版本。你可以通过以下步骤安装 <code>pyenv</code>：</p><ul><li>使用 <code>git</code> 克隆 <code>pyenv</code> 的仓库到你的主目录下（或任何你偏好的位置）：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pyenv/pyenv.git ~/.pyenv</span><br></pre></td></tr></table></figure><ul><li>将 <code>pyenv</code> 初始化脚本添加到你的 shell 配置文件中（如 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code>）。这将允许你在每个新的 shell 会话中自动加载 <code>pyenv</code>：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;eval &quot;$(pyenv init --path)&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;eval &quot;$(pyenv init -)&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="3-安装-Python-3-13"><a href="#3-安装-Python-3-13" class="headerlink" title="3. 安装 Python 3.13"></a>3. 安装 Python 3.13</h3><p>现在，你可以使用 <code>pyenv</code> 来安装 Python 3.13 了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv install 3.13.x  <span class="comment"># x 表示小版本号，你可以根据需要安装具体的版本，如 3.13.0</span></span><br></pre></td></tr></table></figure><p>这个命令会从互联网上下载 Python 3.13 的源代码，并在你的系统上编译和安装它。这可能需要一些时间，具体取决于你的网络连接和计算机性能。</p><h3 id="4-设置全局或本地-Python-版本"><a href="#4-设置全局或本地-Python-版本" class="headerlink" title="4. 设置全局或本地 Python 版本"></a>4. 设置全局或本地 Python 版本</h3><p>安装完成后，你可以使用以下命令之一来设置全局或本地 Python 版本：</p><ul><li>设置全局 Python 版本：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv global 3.13.x</span><br></pre></td></tr></table></figure><p>这将使 Python 3.12 成为你系统上的默认 Python 版本。</p><ul><li>设置当前目录下的 Python 版本（本地版本）：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv <span class="built_in">local</span> 3.13.x</span><br></pre></td></tr></table></figure><p>这将在当前目录及其子目录中设置 Python 3.13 为默认版本。当你进入这些目录时，<code>pyenv</code> 会自动切换到指定的 Python 版本。</p><h3 id="5-验证安装"><a href="#5-验证安装" class="headerlink" title="5. 验证安装"></a>5. 验证安装</h3><p>最后，你可以通过以下命令来验证 Python 3.13 是否已成功安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure><p>或者，如果你想要确保你正在使用的是通过 <code>pyenv</code> 安装的 Python 3.13，你可以使用 <code>pyenv</code> 的 <code>which</code> 命令来找到 Python 解释器的路径：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv <span class="built_in">which</span> python</span><br></pre></td></tr></table></figure><p>如果一切设置正确，这些命令应该会显示 Python 3.13 的版本号或解释器的路径。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在使用 <code>pyenv</code> 安装 Python 版本时，确保你的系统已经安装了编译该版本所需的依赖项。</li><li><code>pyenv</code> 会在你的主目录下创建一个 <code>.pyenv</code> 目录来存储不同版本的 Python。这不会干扰系统默认的 Python 版本。</li><li>如果你在使用 <code>pyenv</code> 时遇到任何问题，可以查阅 <code>pyenv</code> 的官方文档或在互联网上搜索相关的解决方案。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="主分类" scheme="https://kanoc.gitee.io/categories/%E4%B8%BB%E5%88%86%E7%B1%BB/"/>
    
    <category term="二级分类" scheme="https://kanoc.gitee.io/categories/%E4%B8%BB%E5%88%86%E7%B1%BB/%E4%BA%8C%E7%BA%A7%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
    <category term="赚钱" scheme="https://kanoc.gitee.io/tags/%E8%B5%9A%E9%92%B1/"/>
    
    <category term="标签1" scheme="https://kanoc.gitee.io/tags/%E6%A0%87%E7%AD%BE1/"/>
    
  </entry>
  
</feed>
