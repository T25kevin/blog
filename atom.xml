<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://kanoc.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://kanoc.gitee.io/"/>
  <updated>2025-08-05T06:47:56.637Z</updated>
  <id>https://kanoc.gitee.io/</id>
  
  <author>
    <name>Kanoc Ge</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django-DRF-分层架构</title>
    <link href="https://kanoc.gitee.io/2025/08/05/Django-DRF-%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84/"/>
    <id>https://kanoc.gitee.io/2025/08/05/Django-DRF-%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84/</id>
    <published>2025-08-05T06:37:47.000Z</published>
    <updated>2025-08-05T06:47:56.637Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Django DRF 分层架构最佳实践</strong></font></p><span id="more"></span><h1 id="Django-DRF-分层架构最佳实践（ViewSet-Service-统一Response格式）"><a href="#Django-DRF-分层架构最佳实践（ViewSet-Service-统一Response格式）" class="headerlink" title="Django DRF 分层架构最佳实践（ViewSet + Service + 统一Response格式）"></a>Django DRF 分层架构最佳实践（ViewSet + Service + 统一Response格式）</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apps/article/</span><br><span class="line">├── views.py               # 接口层（ViewSet）</span><br><span class="line">├── services.py            # 业务逻辑层</span><br><span class="line">├── serializers.py         # 序列化器</span><br><span class="line">├── response.py            # 统一返回格式封装</span><br><span class="line">├── urls.py                # URL注册</span><br><span class="line">├── models.py              # 模型（假定已存在）</span><br></pre></td></tr></table></figure><h2 id="response-py-—-统一Response返回格式"><a href="#response-py-—-统一Response返回格式" class="headerlink" title="response.py — 统一Response返回格式"></a>response.py — 统一Response返回格式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response  <span class="comment"># 导入DRF的Response对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统一返回格式类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">success</span>(<span class="params">data=<span class="literal">None</span>, msg=<span class="string">&#x27;success&#x27;</span>, code=<span class="number">200</span></span>):  <span class="comment"># 成功响应</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;  <span class="comment"># 返回格式化Response</span></span><br><span class="line">            <span class="string">&#x27;code&#x27;</span>: code,  <span class="comment"># 状态码</span></span><br><span class="line">            <span class="string">&#x27;msg&#x27;</span>: msg,    <span class="comment"># 提示信息</span></span><br><span class="line">            <span class="string">&#x27;data&#x27;</span>: data   <span class="comment"># 返回数据</span></span><br><span class="line">        &#125;, status=<span class="number">200</span>)  <span class="comment"># HTTP 200状态</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fail</span>(<span class="params">msg=<span class="string">&#x27;error&#x27;</span>, code=<span class="number">400</span>, data=<span class="literal">None</span></span>):  <span class="comment"># 失败响应</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;  <span class="comment"># 返回格式化Response</span></span><br><span class="line">            <span class="string">&#x27;code&#x27;</span>: code,  <span class="comment"># 状态码</span></span><br><span class="line">            <span class="string">&#x27;msg&#x27;</span>: msg,    <span class="comment"># 错误信息</span></span><br><span class="line">            <span class="string">&#x27;data&#x27;</span>: data   <span class="comment"># 错误数据</span></span><br><span class="line">        &#125;, status=<span class="number">400</span>)  <span class="comment"># HTTP 400状态</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">paginate</span>(<span class="params">paginator</span>):  <span class="comment"># 分页数据封装</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;count&#x27;</span>: paginator.paginator.count,  <span class="comment"># 总条数</span></span><br><span class="line">            <span class="string">&#x27;page&#x27;</span>: paginator.number,            <span class="comment"># 当前页</span></span><br><span class="line">            <span class="string">&#x27;page_size&#x27;</span>: paginator.paginator.per_page,  <span class="comment"># 每页数量</span></span><br><span class="line">            <span class="string">&#x27;results&#x27;</span>: <span class="built_in">list</span>(paginator)           <span class="comment"># 当前页数据列表</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="services-py-—-业务逻辑层"><a href="#services-py-—-业务逻辑层" class="headerlink" title="services.py — 业务逻辑层"></a>services.py — 业务逻辑层</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Article, Income, Advertisement, Category, ArticleBlock  <span class="comment"># 导入模型</span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q  <span class="comment"># 导入Q表达式用于复杂查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章业务逻辑服务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArticleService</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_filtered_articles</span>(<span class="params">params</span>):  <span class="comment"># 获取筛选后的文章列表</span></span><br><span class="line">        queryset = Article.objects.select_related(<span class="string">&#x27;category&#x27;</span>)  <span class="comment"># 查询文章并关联分类</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> params.get(<span class="string">&#x27;category&#x27;</span>):  <span class="comment"># 分类筛选</span></span><br><span class="line">            queryset = queryset.<span class="built_in">filter</span>(category_id=params[<span class="string">&#x27;category&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> params.get(<span class="string">&#x27;search&#x27;</span>):  <span class="comment"># 搜索关键词筛选</span></span><br><span class="line">            search = params[<span class="string">&#x27;search&#x27;</span>]  <span class="comment"># 获取search参数</span></span><br><span class="line">            queryset = queryset.<span class="built_in">filter</span>(  <span class="comment"># 多字段模糊搜索</span></span><br><span class="line">                Q(title__icontains=search) |  <span class="comment"># 标题包含关键词</span></span><br><span class="line">                Q(description__icontains=search)  <span class="comment"># 描述包含关键词</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        tag = params.get(<span class="string">&#x27;tag&#x27;</span>)  <span class="comment"># 获取tag参数</span></span><br><span class="line">        <span class="keyword">if</span> tag == <span class="string">&#x27;free&#x27;</span>:  <span class="comment"># 免费筛选</span></span><br><span class="line">            queryset = queryset.<span class="built_in">filter</span>(is_free=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">elif</span> tag == <span class="string">&#x27;vip_free&#x27;</span>:  <span class="comment"># VIP免费筛选</span></span><br><span class="line">            queryset = queryset.<span class="built_in">filter</span>(is_vip_free=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">elif</span> tag == <span class="string">&#x27;m_series&#x27;</span>:  <span class="comment"># 支持M系列筛选</span></span><br><span class="line">            queryset = queryset.<span class="built_in">filter</span>(support_m_series=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queryset.order_by(<span class="string">&#x27;-created_at&#x27;</span>)  <span class="comment"># 按创建时间倒序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 收入业务逻辑服务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IncomeService</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_user_incomes</span>(<span class="params">user, income_type=<span class="literal">None</span></span>):  <span class="comment"># 获取用户收入记录</span></span><br><span class="line">        queryset = Income.objects.<span class="built_in">filter</span>(user=user)  <span class="comment"># 筛选当前用户收入</span></span><br><span class="line">        <span class="keyword">if</span> income_type:  <span class="comment"># 按收入类型过滤</span></span><br><span class="line">            queryset = queryset.<span class="built_in">filter</span>(income_type=income_type)</span><br><span class="line">        <span class="keyword">return</span> queryset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 广告业务逻辑服务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdvertisementService</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list_ads</span>():  <span class="comment"># 获取广告列表</span></span><br><span class="line">        <span class="keyword">return</span> Advertisement.objects.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类业务逻辑服务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CategoryService</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list_categories</span>():  <span class="comment"># 获取启用分类</span></span><br><span class="line">        <span class="keyword">return</span> Category.objects.<span class="built_in">filter</span>(is_active=<span class="literal">True</span>).order_by(<span class="string">&#x27;order&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章区块业务逻辑服务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArticleBlockService</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list_blocks</span>(<span class="params">article_id=<span class="literal">None</span></span>):  <span class="comment"># 获取文章区块</span></span><br><span class="line">        queryset = ArticleBlock.objects.<span class="built_in">all</span>()  <span class="comment"># 查询所有区块</span></span><br><span class="line">        <span class="keyword">if</span> article_id:  <span class="comment"># 按文章ID过滤</span></span><br><span class="line">            queryset = queryset.<span class="built_in">filter</span>(article_id=article_id)</span><br><span class="line">        <span class="keyword">return</span> queryset.order_by(<span class="string">&#x27;order&#x27;</span>)  <span class="comment"># 按顺序排序</span></span><br></pre></td></tr></table></figure><h2 id="serializers-py-—-序列化器"><a href="#serializers-py-—-序列化器" class="headerlink" title="serializers.py — 序列化器"></a>serializers.py — 序列化器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers  <span class="comment"># 导入DRF序列化器</span></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Article, Income, Advertisement, Category, ArticleBlock  <span class="comment"># 导入模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章列表序列化器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArticleListSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    category_name = serializers.CharField(source=<span class="string">&#x27;category.name&#x27;</span>, read_only=<span class="literal">True</span>)  <span class="comment"># 显示分类名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Article  <span class="comment"># 绑定模型</span></span><br><span class="line">        fields = [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;category_name&#x27;</span>, <span class="string">&#x27;created_at&#x27;</span>]  <span class="comment"># 序列化字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章详情序列化器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArticleSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Article  <span class="comment"># 绑定模型</span></span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span>  <span class="comment"># 全部字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 收入序列化器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IncomeSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Income  <span class="comment"># 绑定模型</span></span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span>  <span class="comment"># 全部字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 广告序列化器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdvertisementSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Advertisement  <span class="comment"># 绑定模型</span></span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类序列化器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CategorySerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Category  <span class="comment"># 绑定模型</span></span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章区块序列化器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArticleBlockSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = ArticleBlock  <span class="comment"># 绑定模型</span></span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="views-py-—-接口层（ViewSet）"><a href="#views-py-—-接口层（ViewSet）" class="headerlink" title="views.py — 接口层（ViewSet）"></a>views.py — 接口层（ViewSet）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> viewsets, permissions  <span class="comment"># 导入DRF视图集与权限</span></span><br><span class="line"><span class="keyword">from</span> django.core.paginator <span class="keyword">import</span> Paginator  <span class="comment"># Django分页器</span></span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> (  <span class="comment"># 导入序列化器</span></span><br><span class="line">    ArticleSerializer, ArticleListSerializer, IncomeSerializer,</span><br><span class="line">    AdvertisementSerializer, CategorySerializer, ArticleBlockSerializer</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> .services <span class="keyword">import</span> (  <span class="comment"># 导入服务层</span></span><br><span class="line">    ArticleService, IncomeService,</span><br><span class="line">    AdvertisementService, CategoryService, ArticleBlockService</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> .response <span class="keyword">import</span> R  <span class="comment"># 导入统一返回格式</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404  <span class="comment"># 获取对象或返回404</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章接口视图集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArticleViewSet</span>(viewsets.ViewSet):</span><br><span class="line">    permission_classes = [permissions.AllowAny]  <span class="comment"># 所有人可访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list</span>(<span class="params">self, request</span>):  <span class="comment"># 文章列表接口</span></span><br><span class="line">        queryset = ArticleService.get_filtered_articles(request.query_params)  <span class="comment"># 调用服务获取数据</span></span><br><span class="line">        page = <span class="built_in">int</span>(request.GET.get(<span class="string">&#x27;page&#x27;</span>, <span class="number">1</span>))  <span class="comment"># 获取页码</span></span><br><span class="line">        size = <span class="built_in">int</span>(request.GET.get(<span class="string">&#x27;page_size&#x27;</span>, <span class="number">10</span>))  <span class="comment"># 获取每页数量</span></span><br><span class="line">        paginator = Paginator(queryset, size)  <span class="comment"># 创建分页器</span></span><br><span class="line">        page_obj = paginator.get_page(page)  <span class="comment"># 获取当前页对象</span></span><br><span class="line"></span><br><span class="line">        serializer = ArticleListSerializer(page_obj, many=<span class="literal">True</span>)  <span class="comment"># 序列化数据</span></span><br><span class="line">        data = R.paginate(page_obj)  <span class="comment"># 格式化分页数据</span></span><br><span class="line">        data[<span class="string">&#x27;results&#x27;</span>] = serializer.data  <span class="comment"># 填充结果集</span></span><br><span class="line">        <span class="keyword">return</span> R.success(data)  <span class="comment"># 返回成功响应</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">retrieve</span>(<span class="params">self, request, pk=<span class="literal">None</span></span>):  <span class="comment"># 文章详情接口</span></span><br><span class="line">        article = get_object_or_404(Article, pk=pk)  <span class="comment"># 获取文章或404</span></span><br><span class="line">        serializer = ArticleSerializer(article)  <span class="comment"># 序列化文章</span></span><br><span class="line">        <span class="keyword">return</span> R.success(serializer.data)  <span class="comment"># 返回成功响应</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 收入接口视图集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IncomeViewSet</span>(viewsets.ViewSet):</span><br><span class="line">    permission_classes = [permissions.IsAuthenticated]  <span class="comment"># 需要登录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list</span>(<span class="params">self, request</span>):  <span class="comment"># 收入列表接口</span></span><br><span class="line">        queryset = IncomeService.get_user_incomes(request.user, request.GET.get(<span class="string">&#x27;income_type&#x27;</span>))  <span class="comment"># 获取收入数据</span></span><br><span class="line">        serializer = IncomeSerializer(queryset, many=<span class="literal">True</span>)  <span class="comment"># 序列化收入</span></span><br><span class="line">        <span class="keyword">return</span> R.success(serializer.data)  <span class="comment"># 返回成功响应</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 广告接口视图集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdvertisementViewSet</span>(viewsets.ViewSet):</span><br><span class="line">    permission_classes = [permissions.AllowAny]  <span class="comment"># 所有人可访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list</span>(<span class="params">self, request</span>):  <span class="comment"># 广告列表接口</span></span><br><span class="line">        queryset = AdvertisementService.list_ads()  <span class="comment"># 获取广告数据</span></span><br><span class="line">        serializer = AdvertisementSerializer(queryset, many=<span class="literal">True</span>)  <span class="comment"># 序列化广告</span></span><br><span class="line">        <span class="keyword">return</span> R.success(serializer.data)  <span class="comment"># 返回成功响应</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类接口视图集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CategoryViewSet</span>(viewsets.ViewSet):</span><br><span class="line">    permission_classes = [permissions.AllowAny]  <span class="comment"># 所有人可访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list</span>(<span class="params">self, request</span>):  <span class="comment"># 分类列表接口</span></span><br><span class="line">        queryset = CategoryService.list_categories()  <span class="comment"># 获取分类数据</span></span><br><span class="line">        serializer = CategorySerializer(queryset, many=<span class="literal">True</span>)  <span class="comment"># 序列化分类</span></span><br><span class="line">        <span class="keyword">return</span> R.success(serializer.data)  <span class="comment"># 返回成功响应</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章区块接口视图集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArticleBlockViewSet</span>(viewsets.ViewSet):</span><br><span class="line">    permission_classes = [permissions.AllowAny]  <span class="comment"># 所有人可访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list</span>(<span class="params">self, request</span>):  <span class="comment"># 文章区块列表接口</span></span><br><span class="line">        queryset = ArticleBlockService.list_blocks(request.GET.get(<span class="string">&#x27;article&#x27;</span>))  <span class="comment"># 获取区块数据</span></span><br><span class="line">        serializer = ArticleBlockSerializer(queryset, many=<span class="literal">True</span>)  <span class="comment"># 序列化区块</span></span><br><span class="line">        <span class="keyword">return</span> R.success(serializer.data)  <span class="comment"># 返回成功响应</span></span><br></pre></td></tr></table></figure><h2 id="urls-py-—-URL路由注册"><a href="#urls-py-—-URL路由注册" class="headerlink" title="urls.py — URL路由注册"></a>urls.py — URL路由注册</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> DefaultRouter  <span class="comment"># 导入DRF路由器</span></span><br><span class="line"><span class="keyword">from</span> .views <span class="keyword">import</span> (  <span class="comment"># 导入所有视图集</span></span><br><span class="line">    ArticleViewSet, IncomeViewSet,</span><br><span class="line">    AdvertisementViewSet, CategoryViewSet, ArticleBlockViewSet</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">router = DefaultRouter()  <span class="comment"># 创建路由器实例</span></span><br><span class="line">router.register(<span class="string">r&#x27;articles&#x27;</span>, ArticleViewSet, basename=<span class="string">&#x27;articles&#x27;</span>)  <span class="comment"># 文章接口</span></span><br><span class="line">router.register(<span class="string">r&#x27;incomes&#x27;</span>, IncomeViewSet, basename=<span class="string">&#x27;incomes&#x27;</span>)  <span class="comment"># 收入接口</span></span><br><span class="line">router.register(<span class="string">r&#x27;advertisements&#x27;</span>, AdvertisementViewSet, basename=<span class="string">&#x27;advertisements&#x27;</span>)  <span class="comment"># 广告接口</span></span><br><span class="line">router.register(<span class="string">r&#x27;categories&#x27;</span>, CategoryViewSet, basename=<span class="string">&#x27;categories&#x27;</span>)  <span class="comment"># 分类接口</span></span><br><span class="line">router.register(<span class="string">r&#x27;article-blocks&#x27;</span>, ArticleBlockViewSet, basename=<span class="string">&#x27;article-blocks&#x27;</span>)  <span class="comment"># 文章区块接口</span></span><br><span class="line"></span><br><span class="line">urlpatterns = router.urls  <span class="comment"># URL列表</span></span><br></pre></td></tr></table></figure><h2 id="API返回示例"><a href="#API返回示例" class="headerlink" title="API返回示例"></a>API返回示例</h2><h3 id="成功返回："><a href="#成功返回：" class="headerlink" title="成功返回："></a>成功返回：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;code&quot;</span>: <span class="number">200</span>,  <span class="comment"># 状态码</span></span><br><span class="line">    <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;success&quot;</span>,  <span class="comment"># 提示信息</span></span><br><span class="line">    <span class="string">&quot;data&quot;</span>: &#123;  <span class="comment"># 返回数据</span></span><br><span class="line">        <span class="string">&quot;count&quot;</span>: <span class="number">100</span>,  <span class="comment"># 总条数</span></span><br><span class="line">        <span class="string">&quot;page&quot;</span>: <span class="number">1</span>,     <span class="comment"># 当前页码</span></span><br><span class="line">        <span class="string">&quot;page_size&quot;</span>: <span class="number">10</span>,  <span class="comment"># 每页数量</span></span><br><span class="line">        <span class="string">&quot;results&quot;</span>: [  <span class="comment"># 数据列表</span></span><br><span class="line">            &#123;<span class="string">&quot;id&quot;</span>: <span class="number">1</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;标题1&quot;</span>, <span class="string">&quot;category_name&quot;</span>: <span class="string">&quot;分类A&quot;</span>, <span class="string">&quot;created_at&quot;</span>: <span class="string">&quot;2025-08-01T00:00:00Z&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;id&quot;</span>: <span class="number">2</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;标题2&quot;</span>, <span class="string">&quot;category_name&quot;</span>: <span class="string">&quot;分类B&quot;</span>, <span class="string">&quot;created_at&quot;</span>: <span class="string">&quot;2025-08-02T00:00:00Z&quot;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="失败返回："><a href="#失败返回：" class="headerlink" title="失败返回："></a>失败返回：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 400,  # 状态码</span><br><span class="line">    &quot;msg&quot;: &quot;Invalid Parameter&quot;,  # 错误信息</span><br><span class="line">    &quot;data&quot;: null  # 返回数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="这个项目架构保证："><a href="#这个项目架构保证：" class="headerlink" title="这个项目架构保证："></a>这个项目架构保证：</h2><ol><li>ViewSet层非常薄，只负责接口请求与响应。</li><li>业务逻辑Service层独立，复杂逻辑全在services.py，代码易维护、可复用。</li><li>统一Response返回格式，所有接口code&#x2F;msg&#x2F;data标准化，便于前后端对接。</li><li>分页逻辑封装好，不用每个接口重复写分页代码。</li><li>URL路由全部由DRF Router自动生成，新增接口只需注册即可。</li></ol><blockquote><p>这是DRF在中大型项目里最推荐的架构方式，简单接口写法不变，复杂业务拆到Service，ViewSet永远不会变屎山。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Django DRF 分层架构最佳实践&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="main" scheme="https://kanoc.gitee.io/categories/main/"/>
    
    <category term="s" scheme="https://kanoc.gitee.io/categories/main/s/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu_Raid5阵列创建</title>
    <link href="https://kanoc.gitee.io/2025/08/01/ubuntu-Raid5%E9%98%B5%E5%88%97%E5%88%9B%E5%BB%BA/"/>
    <id>https://kanoc.gitee.io/2025/08/01/ubuntu-Raid5%E9%98%B5%E5%88%97%E5%88%9B%E5%BB%BA/</id>
    <published>2025-08-01T10:14:18.000Z</published>
    <updated>2025-08-01T10:14:47.253Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>ubuntu_Raid5阵列创建</strong></font></p><p><strong>Ubuntu 下软件 RAID5（mdadm）全流程教程</strong>。</p><span id="more"></span><p> <strong>一句话：3块或以上硬盘，mdadm组 RAID5，挂载、开机自动挂载，安全关盘，简单易恢复。</strong></p><hr><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a><strong>一、准备工作</strong></h2><ol><li><strong>至少3块空硬盘</strong>（&#x2F;dev&#x2F;sdb、&#x2F;dev&#x2F;sdc、&#x2F;dev&#x2F;sdd……，别用系统盘）</li><li><strong>先备份好重要数据</strong>，下面操作会清空全部数据！</li></ol><hr><h2 id="二、安装-RAID-工具"><a href="#二、安装-RAID-工具" class="headerlink" title="二、安装 RAID 工具"></a><strong>二、安装 RAID 工具</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install mdadm</span><br></pre></td></tr></table></figure><hr><h2 id="三、创建-RAID5-阵列"><a href="#三、创建-RAID5-阵列" class="headerlink" title="三、创建 RAID5 阵列"></a><strong>三、创建 RAID5 阵列</strong></h2><blockquote><p>假设用的是 &#x2F;dev&#x2F;sdb &#x2F;dev&#x2F;sdc &#x2F;dev&#x2F;sdd</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">sudo mdadm --create --verbose /dev/md0 --level=5 --raid-devices=3 /dev/sdb /dev/sdc /dev/sdd</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><code>/dev/md0</code>：阵列设备名</li><li><code>--level=5</code>：RAID5</li><li><code>--raid-devices=3</code>：3块盘</li><li>后面跟你的盘名（不要用分区号！直接&#x2F;dev&#x2F;sdb）</li></ul><blockquote><p>等待创建，阵列会在后台慢慢同步（你可以直接用，不影响挂载）。</p></blockquote><hr><h2 id="四、查看阵列状态"><a href="#四、查看阵列状态" class="headerlink" title="四、查看阵列状态"></a><strong>四、查看阵列状态</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">cat /proc/mdstat</span><br></pre></td></tr></table></figure><p>看到 <code>/dev/md0</code> 正在同步，或者已经 [UUU] 就说明好了。</p><hr><h2 id="五、格式化-RAID-阵列为-ext4-文件系统"><a href="#五、格式化-RAID-阵列为-ext4-文件系统" class="headerlink" title="五、格式化 RAID 阵列为 ext4 文件系统"></a><strong>五、格式化 RAID 阵列为 ext4 文件系统</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">sudo mkfs.ext4 /dev/md0</span><br></pre></td></tr></table></figure><hr><h2 id="六、创建挂载目录并挂载"><a href="#六、创建挂载目录并挂载" class="headerlink" title="六、创建挂载目录并挂载"></a><strong>六、创建挂载目录并挂载</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">sudo mkdir -p /data/raid5</span><br><span class="line">sudo mount /dev/md0 /data/raid5</span><br></pre></td></tr></table></figure><hr><h2 id="七、开机自动挂载（加到-fstab）"><a href="#七、开机自动挂载（加到-fstab）" class="headerlink" title="七、开机自动挂载（加到 fstab）"></a><strong>七、开机自动挂载（加到 fstab）</strong></h2><ol><li><p><strong>查 UUID</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">sudo blkid /dev/md0</span><br></pre></td></tr></table></figure><p>会输出类似：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pgsql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">/dev/md0: UUID=&quot;xxxx-xxxx-xxxx-xxxx&quot; TYPE=&quot;ext4&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>编辑 &#x2F;etc&#x2F;fstab</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">sudo nano /etc/fstab</span><br></pre></td></tr></table></figure><p>加一行（替换你的UUID）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ini</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">UUID=xxxx-xxxx-xxxx-xxxx   /data/raid5   ext4   defaults   0 0</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="八、保存-RAID-配置（防止重启找不到阵列）"><a href="#八、保存-RAID-配置（防止重启找不到阵列）" class="headerlink" title="八、保存 RAID 配置（防止重启找不到阵列）"></a><strong>八、保存 RAID 配置（防止重启找不到阵列）</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">sudo mdadm --detail --scan | sudo tee -a /etc/mdadm/mdadm.conf</span><br><span class="line">sudo update-initramfs -u</span><br></pre></td></tr></table></figure><hr><h2 id="九、权限设置（如多人共享或需要最高权限）"><a href="#九、权限设置（如多人共享或需要最高权限）" class="headerlink" title="九、权限设置（如多人共享或需要最高权限）"></a><strong>九、权限设置（如多人共享或需要最高权限）</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">sudo chmod 777 /data/raid5</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">sudo chown 用户名:用户组 /data/raid5</span><br></pre></td></tr></table></figure><hr><h2 id="十、常用管理命令"><a href="#十、常用管理命令" class="headerlink" title="十、常用管理命令"></a><strong>十、常用管理命令</strong></h2><ul><li><p>查看阵列详细状态：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">sudo mdadm --detail /dev/md0</span><br></pre></td></tr></table></figure></li><li><p>停用阵列（卸载后才能stop）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">sudo umount /data/raid5</span><br><span class="line">sudo mdadm --stop /dev/md0</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a><strong>一句话总结</strong></h1><p><strong>Ubuntu下软RAID5组建只用mdadm，组好后记得加fstab、保存配置，挂载就能用，重启不怕丢阵列。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;ubuntu_Raid5阵列创建&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ubuntu 下软件 RAID5（mdadm）全流程教程&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="main" scheme="https://kanoc.gitee.io/categories/main/"/>
    
    <category term="s" scheme="https://kanoc.gitee.io/categories/main/s/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Python-操作-MinIO</title>
    <link href="https://kanoc.gitee.io/2025/07/28/Python-%E6%93%8D%E4%BD%9C-MinIO/"/>
    <id>https://kanoc.gitee.io/2025/07/28/Python-%E6%93%8D%E4%BD%9C-MinIO/</id>
    <published>2025-07-28T01:57:25.000Z</published>
    <updated>2025-07-28T01:58:06.310Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Python 操作 MinIO</strong></font></p><span id="more"></span><p>下面是最常用的 <strong>Python 操作 MinIO</strong> 的代码示例，基于官方推荐的 SDK：<code>minio</code><br> 适用于上传、下载、列出、删除对象等基本操作，<strong>支持中文文件名</strong>。</p><hr><h2 id="✅-1-安装-SDK"><a href="#✅-1-安装-SDK" class="headerlink" title="✅ 1. 安装 SDK"></a>✅ 1. 安装 SDK</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">pip install minio</span><br></pre></td></tr></table></figure><hr><h2 id="✅-2-初始化客户端"><a href="#✅-2-初始化客户端" class="headerlink" title="✅ 2. 初始化客户端"></a>✅ 2. 初始化客户端</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">from minio import Minio</span><br><span class="line"></span><br><span class="line"># 初始化 MinIO 客户端</span><br><span class="line">client = Minio(</span><br><span class="line">    &quot;your-minio-host:9000&quot;,  # 例如：localhost:9000</span><br><span class="line">    access_key=&quot;minioadmin&quot;,</span><br><span class="line">    secret_key=&quot;minioadmin&quot;,</span><br><span class="line">    secure=False  # 如果你用 http 而不是 https</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="✅-3-创建桶（支持中文桶名）"><a href="#✅-3-创建桶（支持中文桶名）" class="headerlink" title="✅ 3. 创建桶（支持中文桶名）"></a>✅ 3. 创建桶（支持中文桶名）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">bucket_name = &quot;测试桶&quot;</span><br><span class="line"></span><br><span class="line">if not client.bucket_exists(bucket_name):</span><br><span class="line">    client.make_bucket(bucket_name)</span><br></pre></td></tr></table></figure><hr><h2 id="✅-4-上传文件（支持中文文件名）"><a href="#✅-4-上传文件（支持中文文件名）" class="headerlink" title="✅ 4. 上传文件（支持中文文件名）"></a>✅ 4. 上传文件（支持中文文件名）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">client.fput_object(</span><br><span class="line">    bucket_name=&quot;测试桶&quot;,</span><br><span class="line">    object_name=&quot;文件_你好.txt&quot;,         # MinIO 中的对象名（可中文）</span><br><span class="line">    file_path=&quot;/path/to/local/file.txt&quot;  # 本地文件路径</span><br><span class="line">)</span><br><span class="line">print(&quot;上传成功&quot;)</span><br></pre></td></tr></table></figure><hr><h2 id="✅-5-列出对象"><a href="#✅-5-列出对象" class="headerlink" title="✅ 5. 列出对象"></a>✅ 5. 列出对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">objects = client.list_objects(&quot;测试桶&quot;, recursive=True)</span><br><span class="line">for obj in objects:</span><br><span class="line">    print(obj.object_name)</span><br></pre></td></tr></table></figure><hr><h2 id="✅-6-下载对象"><a href="#✅-6-下载对象" class="headerlink" title="✅ 6. 下载对象"></a>✅ 6. 下载对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">client.fget_object(</span><br><span class="line">    bucket_name=&quot;测试桶&quot;,</span><br><span class="line">    object_name=&quot;文件_你好.txt&quot;,</span><br><span class="line">    file_path=&quot;/tmp/下载文件.txt&quot;</span><br><span class="line">)</span><br><span class="line">print(&quot;下载成功&quot;)</span><br></pre></td></tr></table></figure><hr><h2 id="✅-7-删除对象"><a href="#✅-7-删除对象" class="headerlink" title="✅ 7. 删除对象"></a>✅ 7. 删除对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">client.remove_object(&quot;测试桶&quot;, &quot;文件_你好.txt&quot;)</span><br></pre></td></tr></table></figure><hr><h2 id="⚠️-注意事项（实话实说）："><a href="#⚠️-注意事项（实话实说）：" class="headerlink" title="⚠️ 注意事项（实话实说）："></a>⚠️ 注意事项（实话实说）：</h2><ol><li><strong>中文桶名和对象名是支持的</strong>，但 URL 操作时 MinIO 会自动进行 URL 编码，确保客户端使用 UTF-8。</li><li>如果你通过浏览器访问对象，链接中中文会变成 <code>%E6%B5%8B...</code>，这是正常行为。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Python 操作 MinIO&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="main" scheme="https://kanoc.gitee.io/categories/main/"/>
    
    <category term="s" scheme="https://kanoc.gitee.io/categories/main/s/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker-迁移root目录</title>
    <link href="https://kanoc.gitee.io/2025/07/28/docker-%E8%BF%81%E7%A7%BBroot%E7%9B%AE%E5%BD%95/"/>
    <id>https://kanoc.gitee.io/2025/07/28/docker-%E8%BF%81%E7%A7%BBroot%E7%9B%AE%E5%BD%95/</id>
    <published>2025-07-27T22:32:09.000Z</published>
    <updated>2025-07-27T22:34:28.521Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>docker-迁移root目录</strong></font></p><p>主机根目录不够大，需要将 dockerRoot根目录指向其他目录</p><span id="more"></span><h3 id="1️⃣-停掉-Docker-服务"><a href="#1️⃣-停掉-Docker-服务" class="headerlink" title="1️⃣ 停掉 Docker 服务"></a>1️⃣ 停掉 Docker 服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop docker</span><br></pre></td></tr></table></figure><h3 id="2️⃣-拷贝数据到新位置（-data-Docker）"><a href="#2️⃣-拷贝数据到新位置（-data-Docker）" class="headerlink" title="2️⃣ 拷贝数据到新位置（&#x2F;data&#x2F;Docker）"></a>2️⃣ 拷贝数据到新位置（&#x2F;data&#x2F;Docker）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> rsync -aP /var/lib/docker/ /data/Docker/</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>-a</code> 保留权限、软链、时间戳等</li><li><code>-P</code> 显示进度并支持断点续传</li></ul><h3 id="3️⃣-备份原路径（可选）"><a href="#3️⃣-备份原路径（可选）" class="headerlink" title="3️⃣ 备份原路径（可选）"></a>3️⃣ 备份原路径（可选）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /var/lib/docker /var/lib/docker.bak</span><br></pre></td></tr></table></figure><h3 id="4️⃣-创建软链接"><a href="#4️⃣-创建软链接" class="headerlink" title="4️⃣ 创建软链接"></a>4️⃣ 创建软链接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /data/Docker /var/lib/docker</span><br></pre></td></tr></table></figure><h3 id="5️⃣-启动-Docker"><a href="#5️⃣-启动-Docker" class="headerlink" title="5️⃣ 启动 Docker"></a>5️⃣ 启动 Docker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="6️⃣-验证是否生效"><a href="#6️⃣-验证是否生效" class="headerlink" title="6️⃣ 验证是否生效"></a>6️⃣ 验证是否生效</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker info | grep <span class="string">&quot;Docker Root Dir&quot;</span></span><br></pre></td></tr></table></figure><p>应显示：<code>/var/lib/docker</code> → 实际指向的是 <code>/data/Docker</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;docker-迁移root目录&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;主机根目录不够大，需要将 dockerRoot根目录指向其他目录&lt;/p&gt;</summary>
    
    
    
    <category term="main" scheme="https://kanoc.gitee.io/categories/main/"/>
    
    <category term="s" scheme="https://kanoc.gitee.io/categories/main/s/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker加速配置</title>
    <link href="https://kanoc.gitee.io/2025/07/27/docker%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/"/>
    <id>https://kanoc.gitee.io/2025/07/27/docker%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/</id>
    <published>2025-07-27T07:50:01.000Z</published>
    <updated>2025-07-27T07:53:27.637Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong></strong></font></p><span id="more"></span><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bogon ~]# <span class="built_in">cat</span> /etc/docker/daemon.json </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://docker.m.daocloud.io&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">[root@bogon ~]# systemctl daemon-reload</span><br><span class="line">[root@bogon ~]# systemctl restart docker</span><br></pre></td></tr></table></figure><p>再给大家分享几个可以替换的，具体能不能用要在测试一下</p><p>前缀替换的 Registry 的规则, 这是人工配置的, 有需求提 Issue.</p><table><thead><tr><th align="center">源站</th><th align="center">替换为</th></tr></thead><tbody><tr><td align="center">cr.l5d.io</td><td align="center">l5d.m.daocloud.io</td></tr><tr><td align="center">docker.elastic.co</td><td align="center">elastic.m.daocloud.io</td></tr><tr><td align="center">docker.io</td><td align="center">docker.m.daocloud.io</td></tr><tr><td align="center">gcr.io</td><td align="center">gcr.m.daocloud.io</td></tr><tr><td align="center">ghcr.io</td><td align="center">ghcr.m.daocloud.io</td></tr><tr><td align="center">k8s.gcr.io</td><td align="center">k8s-gcr.m.daocloud.io</td></tr><tr><td align="center">registry.k8s.io</td><td align="center">k8s.m.daocloud.io</td></tr><tr><td align="center">mcr.microsoft.com</td><td align="center">mcr.m.daocloud.io</td></tr><tr><td align="center">nvcr.io</td><td align="center">nvcr.m.daocloud.io</td></tr><tr><td align="center">quay.io</td><td align="center">quay.m.daocloud.io</td></tr><tr><td align="center">registry.jujucharms.com</td><td align="center">jujucharms.m.daocloud.io</td></tr><tr><td align="center">rocks.canonical.com</td><td align="center">rocks-canonical.m.daocloud.io</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="main" scheme="https://kanoc.gitee.io/categories/main/"/>
    
    <category term="s" scheme="https://kanoc.gitee.io/categories/main/s/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>玩_OEC-Turbo-刷机教程</title>
    <link href="https://kanoc.gitee.io/2025/07/26/%E7%8E%A9-OEC-Turbo-%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/"/>
    <id>https://kanoc.gitee.io/2025/07/26/%E7%8E%A9-OEC-Turbo-%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</id>
    <published>2025-07-26T10:25:21.000Z</published>
    <updated>2025-07-26T11:02:05.765Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>玩_OEC-Turbo-刷机教程</strong></font></p><span id="more"></span><p><a href="https://docs.qq.com/doc/DS25QZ3dGV3JGQ0lB">乌客的视频附件</a></p><h2 id="一、设备介绍"><a href="#一、设备介绍" class="headerlink" title="一、设备介绍"></a>一、设备介绍</h2><p>OEC-Turbo处理器是<strong>RK3566</strong></p><ul><li><strong>架构</strong>：4× ARM Cortex-A55 (64位)</li><li><strong>主频</strong>：最高 <strong>1.8 GHz</strong></li><li><strong>GPU</strong>：ARM Mali-G52 2EE</li><li><strong>解码能力：4K@60fps</strong> H.265&#x2F;H.264&#x2F;VP9</li><li><strong>NPU</strong>：<strong>0.8 TOPS</strong> (INT8)</li></ul><p><img src="https://am.zdmimg.com/202503/24/67e159fc5bd3f9240.jpg_e1080.jpg"></p><h2 id="二、开始拆机"><a href="#二、开始拆机" class="headerlink" title="二、开始拆机"></a>二、开始拆机</h2><h3 id="2-1、打开底盖"><a href="#2-1、打开底盖" class="headerlink" title="2.1、打开底盖"></a>2.1、打开底盖</h3><p><a href="https://post.smzdm.com/p/ak34g93r/pic_3/"><img src="https://am.zdmimg.com/202503/24/67e15ea50d4826222.jpg_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><h3 id="2-2、取出硬盘，卸下4颗螺丝"><a href="#2-2、取出硬盘，卸下4颗螺丝" class="headerlink" title="2.2、取出硬盘，卸下4颗螺丝"></a>2.2、取出硬盘，卸下4颗螺丝</h3><p><a href="https://post.smzdm.com/p/ak34g93r/pic_4/"><img src="https://am.zdmimg.com/202503/24/67e160369260c6463.jpg_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><h3 id="2-3、卸侧面盖板"><a href="#2-3、卸侧面盖板" class="headerlink" title="2.3、卸侧面盖板"></a>2.3、卸侧面盖板</h3><p><a href="https://post.smzdm.com/p/ak34g93r/pic_5/"><img src="https://am.zdmimg.com/202503/24/67e160d2fc6d2721.jpg_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><h3 id="2-4、卸硬盘接口螺丝"><a href="#2-4、卸硬盘接口螺丝" class="headerlink" title="2.4、卸硬盘接口螺丝"></a>2.4、卸硬盘接口螺丝</h3><p><a href="https://post.smzdm.com/p/ak34g93r/pic_6/"><img src="https://am.zdmimg.com/202503/24/67e161a218bb67406.jpg_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><h3 id="2-5、拆硬盘排线"><a href="#2-5、拆硬盘排线" class="headerlink" title="2.5、拆硬盘排线"></a>2.5、拆硬盘排线</h3><p><a href="https://post.smzdm.com/p/ak34g93r/pic_7/"><img src="https://am.zdmimg.com/202503/24/67e164897ff482243.jpg_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><h3 id="2-6、拆硬中间挡板"><a href="#2-6、拆硬中间挡板" class="headerlink" title="2.6、拆硬中间挡板"></a>2.6、拆硬中间挡板</h3><p><a href="https://post.smzdm.com/p/ak34g93r/pic_8/"><img src="https://am.zdmimg.com/202503/24/67e165d60d02b9025.jpg_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><h3 id="2-7、拆完后的效果"><a href="#2-7、拆完后的效果" class="headerlink" title="2.7、拆完后的效果"></a>2.7、拆完后的效果</h3><p><a href="https://post.smzdm.com/p/ak34g93r/pic_9/"><img src="https://am.zdmimg.com/202503/24/67e166323eee93208.jpg_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><h2 id="三、设备刷机准备-写入Armbian固件"><a href="#三、设备刷机准备-写入Armbian固件" class="headerlink" title="三、设备刷机准备+写入Armbian固件"></a>三、设备刷机准备+写入Armbian固件</h2><h3 id="3-1、下载刷机工具包（包含固件）"><a href="#3-1、下载刷机工具包（包含固件）" class="headerlink" title="3.1、下载刷机工具包（包含固件）"></a>3.1、下载刷机工具包（包含固件）</h3><h3 id="3-2、刷机驱动安装"><a href="#3-2、刷机驱动安装" class="headerlink" title="3.2、刷机驱动安装"></a>3.2、刷机驱动安装</h3><p><a href="https://post.smzdm.com/p/ak34g93r/pic_10/"><img src="https://am.zdmimg.com/202503/24/67e16a79d4bd07354.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a><a href="https://post.smzdm.com/p/ak34g93r/pic_11/"><img src="https://am.zdmimg.com/202503/24/67e168f778b216708.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a><a href="https://post.smzdm.com/p/ak34g93r/pic_12/"><img src="https://am.zdmimg.com/202503/24/67e1693a5ca0d2954.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><h3 id="3-3、固件写入工具设置"><a href="#3-3、固件写入工具设置" class="headerlink" title="3.3、固件写入工具设置"></a>3.3、固件写入工具设置</h3><p>双击打开 “ RKDevTool.exe ” 工具。</p><p><a href="https://post.smzdm.com/p/ak34g93r/pic_13/"><img src="https://am.zdmimg.com/202503/24/67e16afab48835336.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a><a href="https://post.smzdm.com/p/ak34g93r/pic_14/"><img src="https://am.zdmimg.com/202503/24/67e16ccf6c6ff2046.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><p>第一列空格处选择刷机工具：MiniLoaderAll.bin</p><p><a href="https://post.smzdm.com/p/ak34g93r/pic_15/"><img src="https://am.zdmimg.com/202503/24/67e16fbfbb4922977.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><p>第二列空格处选择刷机固件：OEC-6.1.75-rk3566.img</p><p><a href="https://post.smzdm.com/p/ak34g93r/pic_16/"><img src="https://am.zdmimg.com/202503/24/67e1712fa4f944202.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><h3 id="3-4、进入刷机模式"><a href="#3-4、进入刷机模式" class="headerlink" title="3.4、进入刷机模式"></a>3.4、进入刷机模式</h3><p>准备一条USB转Type-C<a href="https://www.smzdm.com/fenlei/shujuxian/">数据线</a>，USB端连接电脑，然后按照图下所示用镊子或其他金属工具短接这两个触点，接着把Type-C端接入OEC-Turbo设备端，<strong>设备刷机时无需外接电源</strong>。</p><p><a href="https://post.smzdm.com/p/ak34g93r/pic_17/"><img src="https://am.zdmimg.com/202503/24/67e1758e95e391200.jpg_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><p>当电脑端的瑞芯微开发工具弹出 “ 发现一个MASKROM设备 ” 时，可以松开镊子了，然后点击 “ 执行 ” ，剩下的就是安安静静等待系统写入。</p><p><a href="https://post.smzdm.com/p/ak34g93r/pic_18/"><img src="https://am.zdmimg.com/202503/24/67e17dd38fc6c8886.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a><a href="https://post.smzdm.com/p/ak34g93r/pic_19/"><img src="https://am.zdmimg.com/202503/24/67e17dd91146b7475.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a><a href="https://post.smzdm.com/p/ak34g93r/pic_20/"><img src="https://am.zdmimg.com/202503/24/67e17ea02a1e23814.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><p>当显示100%时，说明刷机已经成功，固件写入阶段正式结束。恭喜你，喜提一个Armbian系统的网心云OEC-Turbo设备！<img src="https://res.smzdm.com/resources/public/img/emoji/small/aru/02-%5B%E9%AB%98%E5%85%B4%5D.png" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></p><h2 id="四、Armbian系统初始设置"><a href="#四、Armbian系统初始设置" class="headerlink" title="四、Armbian系统初始设置"></a>四、Armbian系统初始设置</h2><h3 id="4-1、确认OEC-Turbo设备IP"><a href="#4-1、确认OEC-Turbo设备IP" class="headerlink" title="4.1、确认OEC-Turbo设备IP"></a>4.1、确认OEC-Turbo设备IP</h3><p>将OEC-Turbo设备重新组装完成并装入2.5寸硬盘，接上<a href="https://www.smzdm.com/fenlei/wangxian/">网线</a>+电源线，然后进入<a href="https://www.smzdm.com/fenlei/luyouqi/">路由器</a>后台寻找一个名称为 “ Armbian ” 的设备，确认其内网IP地址（我这里以中兴路由器为例）</p><p><a href="https://post.smzdm.com/p/ak34g93r/pic_21/"><img src="https://am.zdmimg.com/202503/25/67e1855c86c2c8871.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><h3 id="4-2、使用PuTTY登入OEC-Turbo后台"><a href="#4-2、使用PuTTY登入OEC-Turbo后台" class="headerlink" title="4.2、使用PuTTY登入OEC-Turbo后台"></a>4.2、使用PuTTY登入OEC-Turbo后台</h3><p>输入路由器上识别到的设备IP，点击 “ Open ” 。</p><p><a href="https://post.smzdm.com/p/ak34g93r/pic_22/"><img src="https://am.zdmimg.com/202503/25/67e1866b0372e9138.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a><a href="https://post.smzdm.com/p/ak34g93r/pic_23/"><img src="https://am.zdmimg.com/202503/25/67e1871e9a6b6692.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><h3 id="4-3、Armbian系统设置"><a href="#4-3、Armbian系统设置" class="headerlink" title="4.3、Armbian系统设置"></a>4.3、Armbian系统设置</h3><p>输入用户名：root</p><p>输入初始密码：1234**（密码不显示）**</p><p><a href="https://post.smzdm.com/p/ak34g93r/pic_24/"><img src="https://am.zdmimg.com/202503/25/67e187e3472aa7446.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><p>登入后会自动让你修改密码，密码需要输入2次**（输入的密码必须一样）**</p><p><a href="https://post.smzdm.com/p/ak34g93r/pic_25/"><img src="https://am.zdmimg.com/202503/25/67e188490ed7c9377.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><p>修改密码完成后选择：1）bash（直接输入1，然后按回车键即可）</p><p><a href="https://post.smzdm.com/p/ak34g93r/pic_26/"><img src="https://am.zdmimg.com/202503/25/67e188af2c7463257.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a><a href="https://post.smzdm.com/p/ak34g93r/pic_27/"><img src="https://am.zdmimg.com/202503/25/67e1892cdde604199.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><p>接着系统会让你创建常用账号，看自己需求是否需要设置，如无需设置直接按 “ Ctrl+C ” 快捷键取消即可。</p><p><a href="https://post.smzdm.com/p/ak34g93r/pic_28/"><img src="https://am.zdmimg.com/202503/25/67e18959f08023425.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><h3 id="4-4、更换系统软件源（非常重要，不然使用Docker会遇到无法下载的问题）"><a href="#4-4、更换系统软件源（非常重要，不然使用Docker会遇到无法下载的问题）" class="headerlink" title="4.4、更换系统软件源（非常重要，不然使用Docker会遇到无法下载的问题）"></a>4.4、更换系统软件源（<img src="https://res.smzdm.com/resources/public/img/emoji/small/aru/43-%5B%E6%83%B3%E4%B8%80%E6%83%B3%5D.png" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！">非常重要，不然使用Docker会遇到无法下载的问题）</h3><p>代码指令：</p><blockquote><p>bash &lt;(curl -sSL <a href="https://linuxmirrors.cn/main.sh">https://linuxmirrors.cn/main.sh</a>)</p></blockquote><p><a href="https://post.smzdm.com/p/ak34g93r/pic_29/"><img src="https://am.zdmimg.com/202503/25/67e18a8cc3f375868.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><p>选择自己需要的软件源（我这里以阿里云为例），选择 “ 阿里云 ” 按回车键即可。</p><p><a href="https://post.smzdm.com/p/ak34g93r/pic_30/"><img src="https://am.zdmimg.com/202503/25/67e18c0fa904b2481.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p><p>选择默认 “ 是 ” 按回车键。</p><p><a href="https://post.smzdm.com/p/ak34g93r/pic_31/"><img src="https://am.zdmimg.com/202503/25/67e18c61b19d54273.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a><a href="https://post.smzdm.com/p/ak34g93r/pic_32/"><img src="https://am.zdmimg.com/202503/25/67e18da88ccbb6971.png_e1080.jpg" alt="CasaOS保姆级喂饭教程！网心云OEC-Turbo安装CasaOS系统固件！"></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;玩_OEC-Turbo-刷机教程&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_T2-玩" scheme="https://kanoc.gitee.io/categories/T2-%E7%8E%A9/"/>
    
    <category term="OEC刷机" scheme="https://kanoc.gitee.io/categories/T2-%E7%8E%A9/OEC%E5%88%B7%E6%9C%BA/"/>
    
    
    <category term="OEC刷机" scheme="https://kanoc.gitee.io/tags/OEC%E5%88%B7%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>civitai上的模型使用教程</title>
    <link href="https://kanoc.gitee.io/2025/07/24/civitai%E4%B8%8A%E7%9A%84%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://kanoc.gitee.io/2025/07/24/civitai%E4%B8%8A%E7%9A%84%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2025-07-24T09:49:35.000Z</published>
    <updated>2025-07-24T09:56:55.264Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>civitai上的模型使用教程</strong></font></p><span id="more"></span><ul><li><p><strong><code>Civitai</code>上的模型非常多，但是这些模型需要怎么使用呢 ？请根据该文章指导、部署模型</strong></p></li><li><p><strong><code>Civitai</code> 上的模型大多是 <code>Stable Diffusion</code> 兼容模型</strong>，主要分为 <code>Checkpoint</code> <code>（.ckpt/.safetensors）</code>、<code>Lora</code>、<code>VAE</code>、<code>Embedding</code> 等。用法核心就是：<br> <strong>下载模型——放进指定文件夹——用兼容的 <code>WebUI</code> 或工具加载即可。</strong></p></li></ul><p>下面详细讲下<strong>新手实际怎么用</strong>：</p><hr><h2 id="1-准备环境"><a href="#1-准备环境" class="headerlink" title="1. 准备环境"></a>1. <strong>准备环境</strong></h2><p>最常用、最方便的方式就是用**<code>Stable Diffusion WebUI（AUTOMATIC1111</code>）**，支持 <code>Windows</code>、<code>Linux</code>、<code>Mac</code>，支持 <code>Docker</code>。</p><ul><li>推荐新手直接上 <code>AUTOMATIC1111 WebUI</code></li><li>也可以用 <code>ComfyUI</code>、<code>Vlad</code>、<code>InvokeAI</code> 等，但用法类似</li></ul><hr><h2 id="2-下载安装-WebUI"><a href="#2-下载安装-WebUI" class="headerlink" title="2. 下载安装 WebUI"></a>2. <strong>下载安装 WebUI</strong></h2><ul><li>官方地址：<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">https://github.com/AUTOMATIC1111/stable-diffusion-webui</a></li><li>或者直接找别人封装好的整合包</li><li>支持本地运行、<code>Docker</code>、<code>Colab</code></li></ul><hr><h2 id="3-下载-Civitai-上的模型"><a href="#3-下载-Civitai-上的模型" class="headerlink" title="3. 下载 Civitai 上的模型"></a>3. <strong>下载 Civitai 上的模型</strong></h2><ul><li>找到你想用的模型页面（比如 <code>ChilloutMix</code>、<code>Anything</code>、动漫、写实等）</li><li>点 <code>Download</code>，下载 <code>ckpt</code> 或 <code>safetensors</code> 格式的文件（大部分几百 MB 到几 GB）</li></ul><hr><h2 id="4-放到正确的文件夹"><a href="#4-放到正确的文件夹" class="headerlink" title="4. 放到正确的文件夹"></a>4. <strong>放到正确的文件夹</strong></h2><p>假设你用的是 <code>AUTOMATIC1111</code> <code>WebUI</code>，常见文件夹如下：</p><table><thead><tr><th>模型类型</th><th>放到哪个目录</th></tr></thead><tbody><tr><td>主模型（ckpt, safetensors）</td><td><code>models/Stable-diffusion/</code></td></tr><tr><td>LoRA</td><td><code>models/Lora/</code></td></tr><tr><td>VAE</td><td><code>models/VAE/</code></td></tr><tr><td>Embedding</td><td><code>embeddings/</code></td></tr></tbody></table><blockquote><p>文件夹位置就是 <code>WebUI</code> 主目录下的对应文件夹。</p></blockquote><hr><h2 id="5-在-WebUI-中选择模型并使用"><a href="#5-在-WebUI-中选择模型并使用" class="headerlink" title="5. 在 WebUI 中选择模型并使用"></a>5. <strong>在 WebUI 中选择模型并使用</strong></h2><ol><li>启动 WebUI（运行 <code>webui-user.bat</code> 或 <code>python launch.py</code>，或者 docker 启动命令）</li><li>浏览器打开 <code>http://127.0.0.1:7860</code></li><li>在**右上角“Stable Diffusion checkpoint”**下拉菜单选择你刚下的模型</li><li><code>LoRA</code>&#x2F;<code>Embedding</code> 也可以在 <code>prompt</code> 里引用或者侧边栏选择</li><li>输入 <code>prompt</code>，生成图片</li></ol><hr><h2 id="6-LoRA-VAE-Embedding-的用法"><a href="#6-LoRA-VAE-Embedding-的用法" class="headerlink" title="6. LoRA&#x2F;VAE&#x2F;Embedding 的用法"></a>6. <strong>LoRA&#x2F;VAE&#x2F;Embedding 的用法</strong></h2><ul><li><code>LoRA</code>：<code>Prompt</code> 里加 <code>&quot;&lt;lora:模型名:权重&gt;&quot;</code>，比如 <code>&lt;lora:xxx:0.8&gt;</code></li><li><code>VAE</code>：主界面 VAE 下拉选择</li><li><code>Embedding</code>：直接在 <code>prompt</code> 用训练时指定的触发词</li></ul><hr><h2 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项"></a>7. <strong>注意事项</strong></h2><ul><li>部分模型需要特定 <code>VAE</code>，否则容易偏色</li><li>记得看模型页面的说明和推荐参数</li><li>有些新模型只支持 <code>SDXL</code> 或 <code>SD1.5/2.1</code>，版本不要搞错</li></ul><hr><h1 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a><strong>一句话总结</strong></h1><blockquote><p><strong><code>Civitai</code> 上下的模型就是给 <code>Stable Diffusion</code> 用的，下载到指定文件夹，在 <code>WebUI</code> 里选中就能用了。</strong></p></blockquote><hr><h2 id="如果你用-Docker-或-Linux"><a href="#如果你用-Docker-或-Linux" class="headerlink" title="如果你用 Docker 或 Linux"></a>如果你用 <code>Docker</code> 或 <code>Linux</code></h2><p>只要把模型文件放到挂载目录里就行，路径同上。<br> <code>Docker</code> 示例（假设本地有 <code>models</code> 文件夹）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-v /你的模型目录:/stable-diffusion-webui/models/Stable-diffusion</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;civitai上的模型使用教程&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="AI与模型" scheme="https://kanoc.gitee.io/categories/AI%E4%B8%8E%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="模型" scheme="https://kanoc.gitee.io/categories/AI%E4%B8%8E%E6%A8%A1%E5%9E%8B/%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="教程" scheme="https://kanoc.gitee.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="模型" scheme="https://kanoc.gitee.io/tags/%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Go_模块化_命令运行程序_传递参数</title>
    <link href="https://kanoc.gitee.io/2025/07/03/Go_%E6%A8%A1%E5%9D%97%E5%8C%96_%E5%91%BD%E4%BB%A4%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F_%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/"/>
    <id>https://kanoc.gitee.io/2025/07/03/Go_%E6%A8%A1%E5%9D%97%E5%8C%96_%E5%91%BD%E4%BB%A4%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F_%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</id>
    <published>2025-07-03T01:02:35.000Z</published>
    <updated>2025-07-03T01:06:33.472Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Go_模块化_命令运行程序_传递参数</strong></font></p><span id="more"></span><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> filePath,logPath <span class="type">string</span></span><br><span class="line">  flag.StringVar(&amp;filePath, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;指定要判定的JSON文件路径&quot;</span>)</span><br><span class="line">  <span class="comment">// 解析命令行参数</span></span><br><span class="line">flag.Parse()</span><br><span class="line"><span class="comment">// 检查参数是否提供</span></span><br><span class="line"><span class="keyword">if</span> filePath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;请使用 -p 参数指定JSON文件路径&quot;</span>)</span><br><span class="line">flag.Usage()   <span class="comment">// 显示帮助信息</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(filePath)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Go_模块化_命令运行程序_传递参数&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/categories/Golang/"/>
    
    <category term="模块" scheme="https://kanoc.gitee.io/categories/Golang/%E6%A8%A1%E5%9D%97/"/>
    
    <category term="命令行传递参数" scheme="https://kanoc.gitee.io/categories/Golang/%E6%A8%A1%E5%9D%97/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/"/>
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/tags/Golang/"/>
    
    <category term="命令行传递参数" scheme="https://kanoc.gitee.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Go_模块化_日志管理</title>
    <link href="https://kanoc.gitee.io/2025/07/03/Go_%E6%A8%A1%E5%9D%97%E5%8C%96_%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/"/>
    <id>https://kanoc.gitee.io/2025/07/03/Go_%E6%A8%A1%E5%9D%97%E5%8C%96_%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</id>
    <published>2025-07-03T00:09:12.000Z</published>
    <updated>2025-07-03T00:36:39.130Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Go_模块化_日志管理</strong></font></p><span id="more"></span><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LogSet  日志输出</span></span><br><span class="line"><span class="keyword">type</span> LogSet <span class="keyword">struct</span> &#123;</span><br><span class="line">infoLogger    *log.Logger</span><br><span class="line">warningLogger *log.Logger</span><br><span class="line">errorLogger   *log.Logger</span><br><span class="line">logFile       *os.File</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建全局变量</span></span><br><span class="line"><span class="keyword">var</span> eLogs *LogSet</span><br><span class="line"><span class="comment">// 使用init函数 初始化log</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">eLogs = NewLogger(<span class="string">&quot;./logs&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLogger</span><span class="params">(logDir <span class="type">string</span>)</span></span> *LogSet &#123;</span><br><span class="line"><span class="comment">// 创建日志目录</span></span><br><span class="line"><span class="keyword">if</span> err := os.MkdirAll(logDir, <span class="number">0755</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;无法创建日志目录:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建日志文件（按日期命名）</span></span><br><span class="line">logFileName := filepath.Join(logDir, time.Now().Format(<span class="string">&quot;2006-01-02&quot;</span>)+<span class="string">&quot;.log&quot;</span>)</span><br><span class="line">file, err := os.OpenFile(logFileName, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;无法创建日志文件:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同时输出到控制台和文件</span></span><br><span class="line">infoWriter := io.MultiWriter(os.Stdout, file)</span><br><span class="line">warningWriter := io.MultiWriter(os.Stdout, file)</span><br><span class="line">errorWriter := io.MultiWriter(os.Stderr, file)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;LogSet&#123;</span><br><span class="line">infoLogger:    log.New(infoWriter, <span class="string">&quot;INFO: &quot;</span>, log.Ldate|log.Ltime|log.Lshortfile),</span><br><span class="line">warningLogger: log.New(warningWriter, <span class="string">&quot;WARNING: &quot;</span>, log.Ldate|log.Ltime|log.Lshortfile),</span><br><span class="line">errorLogger:   log.New(errorWriter, <span class="string">&quot;ERROR: &quot;</span>, log.Ldate|log.Ltime|log.Lshortfile),</span><br><span class="line">logFile:       file,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 添加关闭方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LogSet)</span></span> Close() &#123;</span><br><span class="line"><span class="keyword">if</span> l.logFile != <span class="literal">nil</span> &#123;</span><br><span class="line">err := l.logFile.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LogSet)</span></span> Info(v ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">l.infoLogger.Println(v...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LogSet)</span></span> Infof(format <span class="type">string</span>, v ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">l.infoLogger.Printf(format, v...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LogSet)</span></span> Warning(v ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">l.warningLogger.Println(v...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LogSet)</span></span> Warningf(format <span class="type">string</span>, v ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">l.warningLogger.Printf(format, v...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LogSet)</span></span> Error(v ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">l.errorLogger.Println(v...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LogSet)</span></span> Errorf(format <span class="type">string</span>, v ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">l.errorLogger.Printf(format, v...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建日志器，指定日志目录</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建日志：</span></span><br><span class="line">    <span class="comment">// 如果没有在 init 中初始化，可以在这里初始化</span></span><br><span class="line">    <span class="keyword">if</span> eLogs == <span class="literal">nil</span> &#123;</span><br><span class="line">    eLogs = NewLogger(<span class="string">&quot;./logs&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> eLogs.Close() <span class="comment">// 确保关闭文件</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 下面正常调用</span></span><br><span class="line">    eLogs.Infof(<span class="string">&quot;应用启动成功&quot;</span>)</span><br><span class="line">    eLogs.Warning(<span class="string">&quot;这是警告信息&quot;</span>)</span><br><span class="line">    eLogs.Error(<span class="string">&quot;这是错误信息&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 其中：Error、Errorf 的区别，主要说明示例</span></span><br><span class="line">  <span class="comment">// 例子：</span></span><br><span class="line">    userID := <span class="number">123</span></span><br><span class="line">    action := <span class="string">&quot;删除&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error 的输出</span></span><br><span class="line">    eLogs.Error(<span class="string">&quot;用户ID:&quot;</span>, userID, <span class="string">&quot;操作:&quot;</span>, action)</span><br><span class="line">    <span class="comment">// 输出: ERROR: 2024/01/15 10:30:45 用户ID: 123 操作: 删除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Errorf 的输出  </span></span><br><span class="line">    eLogs.Errorf(<span class="string">&quot;用户ID: %d, 操作: %s&quot;</span>, userID, action)</span><br><span class="line">    <span class="comment">// 输出: ERROR: 2024/01/15 10:30:45 用户ID: 123, 操作: 删除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更复杂的例子</span></span><br><span class="line">    eLogs.Error(<span class="string">&quot;连接失败&quot;</span>, <span class="string">&quot;重试次数&quot;</span>, <span class="number">3</span>, <span class="string">&quot;错误&quot;</span>, <span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">    <span class="comment">// 输出: ERROR: 2024/01/15 10:30:45 连接失败 重试次数 3 错误 timeout</span></span><br><span class="line"></span><br><span class="line">    eLogs.Errorf(<span class="string">&quot;连接失败，重试次数: %d, 错误: %s&quot;</span>, <span class="number">3</span>, <span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">    <span class="comment">// 输出: ERROR: 2024/01/15 10:30:45 连接失败，重试次数: 3, 错误: timeout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Go_模块化_日志管理&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/categories/Golang/"/>
    
    <category term="模块" scheme="https://kanoc.gitee.io/categories/Golang/%E6%A8%A1%E5%9D%97/"/>
    
    <category term="日志" scheme="https://kanoc.gitee.io/categories/Golang/%E6%A8%A1%E5%9D%97/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/tags/Golang/"/>
    
    <category term="日志管理" scheme="https://kanoc.gitee.io/tags/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Go_指纹认证过cf</title>
    <link href="https://kanoc.gitee.io/2025/06/12/Go-%E6%8C%87%E7%BA%B9%E8%AE%A4%E8%AF%81%E8%BF%87cf/"/>
    <id>https://kanoc.gitee.io/2025/06/12/Go-%E6%8C%87%E7%BA%B9%E8%AE%A4%E8%AF%81%E8%BF%87cf/</id>
    <published>2025-06-11T16:01:28.000Z</published>
    <updated>2025-06-11T16:09:21.354Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Go_指纹认证过cf</strong></font></p><span id="more"></span><h3 id="灵感来自：Go-爬虫：三行代码伪造-JA3-等-TLS-指纹，绕过-Cloudflare-五秒盾和各种防火墙！"><a href="#灵感来自：Go-爬虫：三行代码伪造-JA3-等-TLS-指纹，绕过-Cloudflare-五秒盾和各种防火墙！" class="headerlink" title="灵感来自：Go 爬虫：三行代码伪造 JA3 等 TLS 指纹，绕过 Cloudflare 五秒盾和各种防火墙！"></a>灵感来自：<a href="https://blog.skyju.cc/post/tls-fingerprint-bypass-cloudflare/">Go 爬虫：三行代码伪造 JA3 等 TLS 指纹，绕过 Cloudflare 五秒盾和各种防火墙！</a></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    tlsclient <span class="string">&quot;github.com/bogdanfinn/tls-client&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/bogdanfinn/tls-client/profiles&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/go-resty/resty/v2&quot;</span></span><br><span class="line">    srt <span class="string">&quot;github.com/juzeon/spoofed-round-tripper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create a SpoofedRoundTripper that implements the http.RoundTripper interface</span></span><br><span class="line">    tr, err := srt.NewSpoofedRoundTripper(</span><br><span class="line">       <span class="comment">// Reference for more: https://bogdanfinn.gitbook.io/open-source-oasis/tls-client/client-options</span></span><br><span class="line">       tlsclient.WithRandomTLSExtensionOrder(), <span class="comment">// needed for Chrome 107+</span></span><br><span class="line">       tlsclient.WithClientProfile(profiles.Chrome_133_PSK),</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set as transport. Don&#x27;t forget to set the UA!</span></span><br><span class="line">    client := resty.New().SetTransport(tr)</span><br><span class="line">    client.SetHeader(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &quot;</span>+<span class="string">&quot;AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36&quot;</span>)</span><br><span class="line">    <span class="comment">// Use</span></span><br><span class="line">    resp, err := client.R().Get(<span class="string">&quot;https://tls.peet.ws/api/all&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(resp.Body()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下面是原帖："><a href="#下面是原帖：" class="headerlink" title="下面是原帖："></a>下面是原帖：</h2><h2 id="Go-爬虫：三行代码伪造-JA3-等-TLS-指纹，绕过-Cloudflare-五秒盾和各种防火墙！"><a href="#Go-爬虫：三行代码伪造-JA3-等-TLS-指纹，绕过-Cloudflare-五秒盾和各种防火墙！" class="headerlink" title="Go 爬虫：三行代码伪造 JA3 等 TLS 指纹，绕过 Cloudflare 五秒盾和各种防火墙！"></a><a href="https://blog.skyju.cc/post/tls-fingerprint-bypass-cloudflare/">Go 爬虫：三行代码伪造 JA3 等 TLS 指纹，绕过 Cloudflare 五秒盾和各种防火墙！</a></h2><h3 id="探索如何使用-Go-语言伪造-TLS-指纹，绕过-Cloudflare-五秒盾和其他防火墙。本文详细介绍了-JA3、JA4-等-TLS-指纹技术，分析了互联网上已有解决方案实现都太过繁琐、而且不支持用于第三方-HTTP-请求库的不足，并提供了一个简单有效的解决方案：实现一个自定义的-http-RoundTripper。相关代码已经开源在-GitHub-上。"><a href="#探索如何使用-Go-语言伪造-TLS-指纹，绕过-Cloudflare-五秒盾和其他防火墙。本文详细介绍了-JA3、JA4-等-TLS-指纹技术，分析了互联网上已有解决方案实现都太过繁琐、而且不支持用于第三方-HTTP-请求库的不足，并提供了一个简单有效的解决方案：实现一个自定义的-http-RoundTripper。相关代码已经开源在-GitHub-上。" class="headerlink" title="探索如何使用 Go 语言伪造 TLS 指纹，绕过 Cloudflare 五秒盾和其他防火墙。本文详细介绍了 JA3、JA4+ 等 TLS 指纹技术，分析了互联网上已有解决方案实现都太过繁琐、而且不支持用于第三方 HTTP 请求库的不足，并提供了一个简单有效的解决方案：实现一个自定义的 http.RoundTripper。相关代码已经开源在 GitHub 上。"></a>探索如何使用 Go 语言伪造 TLS 指纹，绕过 Cloudflare 五秒盾和其他防火墙。本文详细介绍了 JA3、JA4+ 等 TLS 指纹技术，分析了互联网上已有解决方案实现都太过繁琐、而且不支持用于第三方 HTTP 请求库的不足，并提供了一个简单有效的解决方案：实现一个自定义的 http.RoundTripper。相关代码已经开源在 GitHub 上。</h3><p>先承认，写这个标题多少有点营销号那味，因为代码里多几个换行就超过三行代码了，而且也不一定能完美绕过所有防火墙及其以后的种种升级版本。但我还是想小小的骄傲一下，本文介绍的方法应该是目前市面上用起来最简单的，并且兼容性最好的（大概）。</p><h1 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h1><p>Cloudflare 的五秒盾大家应该都很熟悉，对于网站主来说，使用它可以有效防止 CC 攻击；对于爬虫来说，解决它也算是一个重要的课题。而对于既当网站主又当爬虫开发者的我来说，就只能对其又爱又恨了……</p><p>要说到爬虫绕过防火墙的其中一个常见方法，应该得属修改 User-Agent。你用 Python、Go 等写的程序，发起 HTTP 请求时，如果不去额外指定，都有自己的 User-Agent。比如在 Go 里使用<a href="https://github.com/go-resty/resty">resty</a>这个库的默认 UA 是<code>go-resty/2.10.0 (https://github.com/go-resty/resty)</code>，巴不得把你在用爬虫访问人家网站的事实昭告天下。因此我们一般会修改这个值，将其改成常见浏览器的 UA，例如 Chrome 的：<code>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36</code>。这在以前就足以对付大部分防火墙了。</p><p>但是从今年开始 Cloudflare 的防火墙增加了一个识别项，也就是 TLS 的 JA3、JA4 等指纹。如果使用 HTTP&#x2F;2 访问，还会再多检测一个 Akamai Fingerprint。这些是啥？拿一个典型的 HTTPS Client Hello 的包举例子：</p><p><img src="https://s2.loli.net/2025/06/12/Bura4gowed3IY8j.png" alt="img"></p><p>看到里面的 Cipher Suites 和 Extensions 这堆东西了吗？尤其是 Cipher Suites 这个 Array，不同浏览器的数量、种类、顺序都是不一样的。于是网络安全的研究者就根据这个计算了一个哈希，把它作为一个 HTTPS 客户端的 TLS 指纹。</p><p>你用 Go 写的爬虫，建立 TLS 握手的时候使用的是 Go 的库，自然也有 Go 自己的 TLS 指纹。那么 Cloudflare 可以直接把 Go 的 TLS 指纹给 ban 掉，只允许真实浏览器访问。甚至来说，实际上 Cloudflare 会把 TLS 指纹和你的 User-Agent 进行比对。人家看到你 User-Agent 宣称是谷歌浏览器的，而 TLS 指纹却是 Go 库的，这不赤裸裸的欺骗吗？绝对要把你 block 之门外了。</p><p>关于 JA3、JA4+ 和 Akamai Fingerprint 可以看下面几个文章：</p><p>介绍 JA3 的：<a href="https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967/">https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967/</a></p><p>介绍 JA4+ 的：<a href="https://blog.foxio.io/ja4-network-fingerprinting-9376fe9ca637">https://blog.foxio.io/ja4-network-fingerprinting-9376fe9ca637</a></p><p>JA4 相当于是 JA3 的升级版。介绍 JA4+ 的这篇文章尤其让我大开眼界。研究者不仅只是算出一个 TLS 指纹而已，还根据不同的因素创造出了多种指纹的变种（因此后面多了个加号）。比如 JA4SSH，就是针对 SSH 协议的。通过对指纹的分析，可以识别加密信道中是否存在恶意流量，本身还是很不错的。</p><p>而 Akamai Fingerprint 就是针对 HTTP&#x2F;2 的，其简单的原理介绍可以看这里：<a href="https://lwthiker.com/networks/2022/06/17/http2-fingerprinting.html">https://lwthiker.com/networks/2022/06/17/http2-fingerprinting.html</a></p><p>可以访问这个网站看到你浏览器的 TLS 指纹：<a href="https://tls.peet.ws/">https://tls.peet.ws/</a></p><p><img src="https://s2.loli.net/2025/06/12/AgvpKFLQ2sNb9Dc.png" alt="img"></p><p>高版本 Chrome 加入了一些随机特性，每次访问 JA3 指纹都不一样。但不管你怎么随机，也就那么几种，都带有 Chrome 的特征。而且经过测试我这边 Chrome 浏览器的 JA4 指纹是不变的。</p><h1 id="已有的解决方案"><a href="#已有的解决方案" class="headerlink" title="已有的解决方案"></a>已有的解决方案</h1><p>互联网上能找到的解决方案也不算少，都主要围绕<a href="https://github.com/refraction-networking/utls">uTLS</a>这个库来使用。uTLS 库提供对 Go 原生 tls 库的替代，重写了 Client Hello 的过程，能够自定义上面说的 Cipher Suites 和 Extensions 字段等等。</p><p>比如我找到的<a href="https://sxyz.blog/bypass-cloudflare-shield/">这篇博文</a>和<a href="https://blog.csdn.net/chenzhuyu/article/details/132217262">这篇博文</a>，都是直接裸用 uTLS 库。前者甚至从底层 DialTCP 开始手搓 TLS 加密信道（这篇文章还是很值得一看的，可以帮助你把整个构造的底层原理弄清楚）。这也无可厚非，uTLS 库的缺点就是过于底层了，用起来比较麻烦。</p><p>于是我找到了<a href="https://github.com/bogdanfinn/tls-client">tls-client</a>这个库，他在 uTLS 上面封装了一个 HTTP Client，可以直接使用其提供的方法发起请求，并且封装了常见主流浏览器的 profile：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">options := []tls_client.HttpClientOption&#123;</span><br><span class="line">tls_client.WithTimeoutSeconds(<span class="number">30</span>),</span><br><span class="line">tls_client.WithClientProfile(profiles.Chrome_120),<span class="comment">// Chrome 120 版本的指纹</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 创建 Request，注意这里创建的 Request 不是 Go 标准库的 http.Request，而是 fhttp.Request，它自己的一个结构</span></span><br><span class="line">req, err := fhttp.NewRequest(http.MethodGet, <span class="string">&quot;https://tls.peet.ws/api/all&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">resp, err := client.Do(req)<span class="comment">// 使用 tls-client 进行请求</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但缺点也是有的，就是提供的接口过于原始了，对于我这样的懒人，早就习惯用<a href="https://github.com/go-resty/resty">resty</a>、<a href="https://github.com/imroc/req">req</a>这样封装完善的第三方库了。</p><h1 id="自定义-RoundTripper"><a href="#自定义-RoundTripper" class="headerlink" title="自定义 RoundTripper"></a>自定义 RoundTripper</h1><p>好在 resty 提供一个 SetTransport 的方法，可以传入一个实现了 http.RoundTripper 的接口。相关的函数签名其实很简单：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> http.RoundTripper <span class="keyword">interface</span> &#123;</span><br><span class="line">RoundTrip(*http.Request) (*http.Response, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无非就是接收到一个 http.Request 对象，然后进行网络请求，最后返回一个 <code>http.Response</code>。注意这里的 Request 和 Response 都是 Go 的 http 标准库中的，而 <code>tls-client</code> 使用了另一套 fhttp.Request 和 fhttp.Response，所以只要进行一下桥接，实现一个自定义 RoundTripper 就行了。</p><p>完整代码已经开源：<a href="https://github.com/juzeon/spoofed-round-tripper">https://github.com/juzeon/spoofed-round-tripper</a></p><p>这样和 resty 一起使用起来就变得很容易：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">tlsclient <span class="string">&quot;github.com/bogdanfinn/tls-client&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/bogdanfinn/tls-client/profiles&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-resty/resty/v2&quot;</span></span><br><span class="line">srt <span class="string">&quot;github.com/juzeon/spoofed-round-tripper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Create a SpoofedRoundTripper that implements the http.RoundTripper interface</span></span><br><span class="line">tr, err := srt.NewSpoofedRoundTripper(</span><br><span class="line">        <span class="comment">// Reference for more: https://bogdanfinn.gitbook.io/open-source-oasis/tls-client/client-options</span></span><br><span class="line">tlsclient.WithRandomTLSExtensionOrder(),<span class="comment">// needed for Chrome 107+</span></span><br><span class="line">tlsclient.WithClientProfile(profiles.Chrome_120),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set as transport. Don&#x27;t forget to set the UA!</span></span><br><span class="line">client := resty.New().SetTransport(tr).</span><br><span class="line">SetHeader(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &quot;</span>+</span><br><span class="line"><span class="string">&quot;AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use</span></span><br><span class="line">resp, err := client.R().Get(<span class="string">&quot;https://tls.peet.ws/api/all&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(resp.Body()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意有一些用法是不行的，毕竟咱们的 RoundTripper 是自己的实现的，不是 Go 自己的 http.Transport。比如设置代理的时候：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Don&#x27;t:</span></span><br><span class="line">tr, err := srt.NewSpoofedRoundTripper(</span><br><span class="line">    tlsclient.WithRandomTLSExtensionOrder(),</span><br><span class="line">tlsclient.WithClientProfile(profiles.Chrome_120),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">client := resty.New().SetTransport(tr).SetProxy(<span class="string">&quot;socks5://127.0.0.1:7890&quot;</span>)</span><br><span class="line"><span class="comment">// ERROR RESTY current transport is not an *http.Transport instance</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Do:</span></span><br><span class="line">tr, err := srt.NewSpoofedRoundTripper(</span><br><span class="line">    tlsclient.WithRandomTLSExtensionOrder(),</span><br><span class="line">tlsclient.WithClientProfile(profiles.Chrome_120),</span><br><span class="line">tlsclient.WithProxyUrl(<span class="string">&quot;socks5://127.0.0.1:7890&quot;</span>),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">client := resty.New().SetTransport(tr)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面第一种尝试会报错的原因是 resty 的 SetProxy 方法会在内部尝试把传入的 <code>http.RoundTripper</code> 转成标准库的 <code>http.Transport</code>，显然咱们穿进去的是个假的，所以会报错。好在 tls-client 本身提供了设置代理的方法，可以直接用。</p><h1 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h1><p>说实话，像 Go 这样能直接撅起底层，自己实现 TLS 握手过程的能力，在其他语言中时很少见的。比如 Python 基本上所有的网络请求库在 TLS 握手的时候都是直接调用底层 C 编写的 <code>openssl</code> 套件，因此完全就不支持自定义。搞了半天，Python 这个被鼓吹为最适合爬虫的语言在写爬虫上居然还不如 Go？</p><p>参考掘金上的这篇文章：<a href="https://juejin.cn/post/7197740114252447781">https://juejin.cn/post/7197740114252447781</a></p><p>嗯…实际上上面介绍的 tls-client 这个库还提供一些其他语言的 binding，不过调用起来相对麻烦，感兴趣的话可以去看看人家的<a href="https://bogdanfinn.gitbook.io/open-source-oasis/shared-library">文档</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Go_指纹认证过cf&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/categories/Golang/"/>
    
    <category term="爬虫" scheme="https://kanoc.gitee.io/categories/Golang/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="过cf墙" scheme="https://kanoc.gitee.io/tags/%E8%BF%87cf%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>Go_后端、前端加密套装</title>
    <link href="https://kanoc.gitee.io/2025/06/11/Go-%E5%90%8E%E7%AB%AF%E3%80%81%E5%89%8D%E7%AB%AF%E5%8A%A0%E5%AF%86%E5%A5%97%E8%A3%85/"/>
    <id>https://kanoc.gitee.io/2025/06/11/Go-%E5%90%8E%E7%AB%AF%E3%80%81%E5%89%8D%E7%AB%AF%E5%8A%A0%E5%AF%86%E5%A5%97%E8%A3%85/</id>
    <published>2025-06-11T14:38:21.000Z</published>
    <updated>2025-06-11T14:42:30.450Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Go_后端、前端加密套装</strong></font></p><span id="more"></span><h3 id="Go-后端加密增强"><a href="#Go-后端加密增强" class="headerlink" title="Go 后端加密增强:"></a>Go 后端加密增强:</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">marshalResponse</span><span class="params">(response JsonResponse)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    jsonData, _ := json.Marshal(response)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用AES加密 (需安装 crypto/aes, crypto/cipher)</span></span><br><span class="line">    encrypted := encryptAES(jsonData, <span class="string">&quot;your-32-byte-secret-key-1234567890abc&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">byte</span>(base64.StdEncoding.EncodeToString(encrypted))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encryptAES</span><span class="params">(data []<span class="type">byte</span>, key <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    block, _ := aes.NewCipher([]<span class="type">byte</span>(key))</span><br><span class="line">    gcm, _ := cipher.NewGCM(block)</span><br><span class="line">    nonce := <span class="built_in">make</span>([]<span class="type">byte</span>, gcm.NonceSize())</span><br><span class="line">    rand.Read(nonce)</span><br><span class="line">    <span class="keyword">return</span> gcm.Seal(nonce, nonce, data, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-解密增强"><a href="#Python-解密增强" class="headerlink" title="Python 解密增强:"></a>Python 解密增强:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Cryptodome.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_encrypted</span>(<span class="params">encrypted_str, key</span>):</span><br><span class="line">    encrypted_data = base64.b64decode(encrypted_str)</span><br><span class="line">    nonce = encrypted_data[:<span class="number">12</span>]</span><br><span class="line">    ciphertext = encrypted_data[<span class="number">12</span>:]</span><br><span class="line">    cipher = AES.new(key.encode(), AES.MODE_GCM, nonce=nonce)</span><br><span class="line">    <span class="keyword">return</span> json.loads(cipher.decrypt(ciphertext).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="JavaScript-解密增强："><a href="#JavaScript-解密增强：" class="headerlink" title="JavaScript 解密增强："></a>JavaScript 解密增强：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">decryptResponse</span>(<span class="params">encryptedStr, key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> encryptedData = <span class="title class_">Uint8Array</span>.<span class="title function_">from</span>(<span class="title function_">atob</span>(encryptedStr), <span class="function"><span class="params">c</span> =&gt;</span> c.<span class="title function_">charCodeAt</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">const</span> iv = encryptedData.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">const</span> ciphertext = encryptedData.<span class="title function_">slice</span>(<span class="number">12</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> cryptoKey = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">importKey</span>(</span><br><span class="line">        <span class="string">&quot;raw&quot;</span>, </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TextEncoder</span>().<span class="title function_">encode</span>(key),</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&quot;AES-GCM&quot;</span> &#125;,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        [<span class="string">&quot;decrypt&quot;</span>]</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> decrypted = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">decrypt</span>(</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&quot;AES-GCM&quot;</span>, iv &#125;,</span><br><span class="line">        cryptoKey,</span><br><span class="line">        ciphertext</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="keyword">new</span> <span class="title class_">TextDecoder</span>().<span class="title function_">decode</span>(decrypted));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>增强方案</strong>：<ul><li>添加 AES-GCM 加密</li><li>需要前后端共享密钥</li><li>适用于需要真正加密保护的场景</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Go_后端、前端加密套装&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/categories/Golang/"/>
    
    <category term="加密、解密" scheme="https://kanoc.gitee.io/categories/Golang/%E5%8A%A0%E5%AF%86%E3%80%81%E8%A7%A3%E5%AF%86/"/>
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/tags/Golang/"/>
    
    <category term="加密、解密" scheme="https://kanoc.gitee.io/tags/%E5%8A%A0%E5%AF%86%E3%80%81%E8%A7%A3%E5%AF%86/"/>
    
    <category term="Python" scheme="https://kanoc.gitee.io/tags/Python/"/>
    
    <category term="JavaScript" scheme="https://kanoc.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Go_发起网络请求模版(基于官方net库)</title>
    <link href="https://kanoc.gitee.io/2025/06/11/Go-%E5%8F%91%E8%B5%B7%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A8%A1%E7%89%88(%E5%9F%BA%E4%BA%8E%E5%AE%98%E6%96%B9net%E5%BA%93)/"/>
    <id>https://kanoc.gitee.io/2025/06/11/Go-%E5%8F%91%E8%B5%B7%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A8%A1%E7%89%88(%E5%9F%BA%E4%BA%8E%E5%AE%98%E6%96%B9net%E5%BA%93)/</id>
    <published>2025-06-11T06:28:01.000Z</published>
    <updated>2025-06-11T06:51:50.173Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Go_发起网络请求模版(基于官方net库)</strong></font></p><span id="more"></span><h2 id="Go-HTTP请求模板封装"><a href="#Go-HTTP请求模板封装" class="headerlink" title="Go HTTP请求模板封装"></a>Go HTTP请求模板封装</h2><h3 id="1、导入包"><a href="#1、导入包" class="headerlink" title="1、导入包"></a>1、导入包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;mime/multipart&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;net/url&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="1-1、GetRequest-发送GET请求"><a href="#1-1、GetRequest-发送GET请求" class="headerlink" title="1.1、GetRequest 发送GET请求"></a>1.1、<em>GetRequest 发送GET请求</em></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GetRequest 发送GET请求</span></span><br><span class="line"><span class="comment">// url: 请求地址</span></span><br><span class="line"><span class="comment">// params: 查询参数(map格式)</span></span><br><span class="line"><span class="comment">// 返回: 响应体字节数组和错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetRequest</span><span class="params">(url <span class="type">string</span>, params <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// 1. 构建带参数的URL</span></span><br><span class="line">query := url.Values&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> params &#123;</span><br><span class="line">query.Add(k, v)</span><br><span class="line">&#125;</span><br><span class="line">fullURL := url</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(params) &gt; <span class="number">0</span> &#123;</span><br><span class="line">fullURL += <span class="string">&quot;?&quot;</span> + query.Encode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 发送GET请求</span></span><br><span class="line">resp, err := http.Get(fullURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 读取响应体</span></span><br><span class="line"><span class="keyword">return</span> io.ReadAll(resp.Body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><p><code>url</code>: 请求的目标地址（不包含查询参数），例如 <code>&quot;https://api.example.com/data&quot;</code></p></li><li><p><code>params: </code>查询参数的键值对映射，例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;page&quot;</span>:  <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;limit&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将生成<code>?page=1&amp;limit=20</code>的查询字符串</p></li></ul><h3 id="1-2、PostJsonRequest-发送JSON格式的POST请求"><a href="#1-2、PostJsonRequest-发送JSON格式的POST请求" class="headerlink" title="1.2、PostJsonRequest 发送JSON格式的POST请求"></a>1.2、<em>PostJsonRequest 发送JSON格式的POST请求</em></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PostJsonRequest 发送JSON格式的POST请求</span></span><br><span class="line"><span class="comment">// url: 请求地址</span></span><br><span class="line"><span class="comment">// data: 要发送的JSON数据(任意结构体)</span></span><br><span class="line"><span class="comment">// 返回: 响应体字节数组和错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostJsonRequest</span><span class="params">(url <span class="type">string</span>, data <span class="keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// 1. 序列化JSON数据</span></span><br><span class="line">jsonData, err := json.Marshal(data)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建请求</span></span><br><span class="line">req, err := http.NewRequest(<span class="string">&quot;POST&quot;</span>, url, bytes.NewBuffer(jsonData))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 发送请求并获取响应</span></span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">resp, err := client.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 读取响应体</span></span><br><span class="line"><span class="keyword">return</span> io.ReadAll(resp.Body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a><strong>参数说明：</strong></h4><ul><li><p><code>url</code>: 请求的目标地址，例如 <code>&quot;https://api.example.com/users&quot;</code></p></li><li><p><code>data</code>：任意可被JSON序列化的Go数据结构，例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用结构体</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Email <span class="type">string</span> <span class="string">`json:&quot;email&quot;`</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    Name:  <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    Email: <span class="string">&quot;alice@example.com&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或使用map</span></span><br><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:  <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="string">&quot;email&quot;</span>: <span class="string">&quot;alice@example.com&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3、PostFormUrlEncodedRequest-发送x-www-form-urlencoded格式的POST请求"><a href="#1-3、PostFormUrlEncodedRequest-发送x-www-form-urlencoded格式的POST请求" class="headerlink" title="1.3、PostFormUrlEncodedRequest 发送x-www-form-urlencoded格式的POST请求"></a>1.3、<em>PostFormUrlEncodedRequest 发送x-www-form-urlencoded格式的POST请求</em></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PostFormUrlEncodedRequest 发送x-www-form-urlencoded格式的POST请求</span></span><br><span class="line"><span class="comment">// url: 请求地址</span></span><br><span class="line"><span class="comment">// formData: 表单数据(map格式)</span></span><br><span class="line"><span class="comment">// 返回: 响应体字节数组和错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostFormUrlEncodedRequest</span><span class="params">(url <span class="type">string</span>, formData <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// 1. 构建表单数据</span></span><br><span class="line">data := url.Values&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> formData &#123;</span><br><span class="line">data.Set(k, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 发送请求</span></span><br><span class="line">resp, err := http.Post(</span><br><span class="line">url,</span><br><span class="line"><span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">strings.NewReader(data.Encode()),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 读取响应体</span></span><br><span class="line"><span class="keyword">return</span> io.ReadAll(resp.Body)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><p><code>url</code>: 请求的目标地址，例如 <code>&quot;https://api.example.com/login&quot;</code></p></li><li><p><code>formData</code>: 表单数据的键值对映射，例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;myp@ssw0rd&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4、PostFormDataRequest-发送multipart-form-data格式的POST请求-支持文件和文本混合"><a href="#1-4、PostFormDataRequest-发送multipart-form-data格式的POST请求-支持文件和文本混合" class="headerlink" title="1.4、PostFormDataRequest 发送multipart&#x2F;form-data格式的POST请求(支持文件和文本混合)"></a>1.4、<em>PostFormDataRequest 发送multipart&#x2F;form-data格式的POST请求(支持文件和文本混合)</em></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PostFormDataRequest 发送multipart/form-data格式的POST请求(支持文件和文本混合)</span></span><br><span class="line"><span class="comment">// url: 请求地址</span></span><br><span class="line"><span class="comment">// formData: 文本表单数据(map格式)</span></span><br><span class="line"><span class="comment">// fileField: 文件字段名</span></span><br><span class="line"><span class="comment">// filePath: 文件路径</span></span><br><span class="line"><span class="comment">// 返回: 响应体字节数组和错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostFormDataRequest</span><span class="params">(url <span class="type">string</span>, formData <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, fileField, filePath <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// 1. 创建multipart写入器</span></span><br><span class="line">body := &amp;bytes.Buffer&#123;&#125;</span><br><span class="line">writer := multipart.NewWriter(body)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 添加文本字段</span></span><br><span class="line"><span class="keyword">for</span> key, val := <span class="keyword">range</span> formData &#123;</span><br><span class="line">_ = writer.WriteField(key, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 添加文件字段(如果提供了文件路径)</span></span><br><span class="line"><span class="keyword">if</span> filePath != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">file, err := os.Open(filePath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">part, err := writer.CreateFormFile(fileField, file.Name())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">_, err = io.Copy(part, file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 关闭写入器(必须)</span></span><br><span class="line">err := writer.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 创建请求</span></span><br><span class="line">req, err := http.NewRequest(<span class="string">&quot;POST&quot;</span>, url, body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, writer.FormDataContentType())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 发送请求</span></span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">resp, err := client.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 读取响应</span></span><br><span class="line"><span class="keyword">return</span> io.ReadAll(resp.Body)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><p><code>url</code>: 请求的目标地址，例如 <code>&quot;https://api.example.com/upload&quot;</code></p></li><li><p><code>formData</code>: 文本字段的键值对映射，例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;用户头像&quot;</span>,</span><br><span class="line">    <span class="string">&quot;category&quot;</span>:    <span class="string">&quot;profile&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>fileField</code>: 服务器用于接收文件的字段名称（表单域名称），例如 <code>&quot;avatar&quot;</code></p></li><li><p><code>filePath</code>: 要上传的文件在本地系统的完整路径，例如 <code>&quot;/tmp/photo.jpg&quot;</code></p></li></ul><blockquote><p><strong>特殊说明</strong>：<code>filePath</code> 参数为空字符串 <code>&quot;&quot;</code> 时，表示不上传文件，只发送文本表单数据</p></blockquote><h3 id="2、请求示例："><a href="#2、请求示例：" class="headerlink" title="2、请求示例："></a>2、请求示例：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ============================</span></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// ============================</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 示例1: GET请求</span></span><br><span class="line">getResp, err := GetRequest(<span class="string">&quot;https://httpbin.org/get&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;param1&quot;</span>: <span class="string">&quot;value1&quot;</span>,</span><br><span class="line"><span class="string">&quot;param2&quot;</span>: <span class="string">&quot;value2&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;GET请求失败:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;GET响应:\n&quot;</span>, <span class="type">string</span>(getResp))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2: POST JSON请求</span></span><br><span class="line">jsonResp, err := PostJsonRequest(<span class="string">&quot;https://httpbin.org/post&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>:  <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line"><span class="string">&quot;email&quot;</span>: <span class="string">&quot;alice@example.com&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;JSON POST失败:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;JSON POST响应:\n&quot;</span>, <span class="type">string</span>(jsonResp))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3: Form-urlencoded请求</span></span><br><span class="line">formResp, err := PostFormUrlEncodedRequest(<span class="string">&quot;https://httpbin.org/post&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;username&quot;</span>: <span class="string">&quot;bob&quot;</span>,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: <span class="string">&quot;secret&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;Form-urlencoded POST失败:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Form-urlencoded响应:\n&quot;</span>, <span class="type">string</span>(formResp))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例4: Form-data请求(含文件)</span></span><br><span class="line"><span class="comment">// formDataResp, err := PostFormDataRequest(</span></span><br><span class="line"><span class="comment">// &quot;https://httpbin.org/post&quot;,</span></span><br><span class="line"><span class="comment">// map[string]string&#123;&quot;textField&quot;: &quot;textValue&quot;&#125;,</span></span><br><span class="line"><span class="comment">// &quot;fileField&quot;,</span></span><br><span class="line"><span class="comment">// &quot;./test.txt&quot;, // 实际文件路径</span></span><br><span class="line"><span class="comment">// )</span></span><br><span class="line"><span class="comment">// if err != nil &#123;</span></span><br><span class="line"><span class="comment">// log.Fatal(&quot;Form-data POST失败:&quot;, err)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// fmt.Println(&quot;Form-data响应:\n&quot;, string(formDataResp))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通用返回说明"><a href="#通用返回说明" class="headerlink" title="通用返回说明"></a>通用返回说明</h4><p>所有函数均返回两个值：</p><ol><li><strong><code>[]byte</code></strong>: 原始响应体内容，需要调用方自行解析（如使用 <code>json.Unmarshal()</code>）</li><li><strong><code>error</code></strong>: 错误对象，请求成功时返回 <code>nil</code>，失败时包含错误详情</li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 典型使用示例</span></span><br><span class="line">respBytes, err := GetRequest(<span class="string">&quot;https://api.example.com/data&quot;</span>, params)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">    log.Fatal(<span class="string">&quot;请求失败:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析JSON响应</span></span><br><span class="line"><span class="keyword">var</span> result ResponseStruct</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(respBytes, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 处理解析错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Go_发起网络请求模版(基于官方net库)&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/categories/Golang/"/>
    
    <category term="网络请求" scheme="https://kanoc.gitee.io/categories/Golang/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/tags/Golang/"/>
    
    <category term="官方http" scheme="https://kanoc.gitee.io/tags/%E5%AE%98%E6%96%B9http/"/>
    
    <category term="网络请求" scheme="https://kanoc.gitee.io/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Go_中传递参数类型的判定与其他用法</title>
    <link href="https://kanoc.gitee.io/2025/06/11/Go-%E4%B8%AD%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E5%AE%9A%E4%B8%8E%E5%85%B6%E4%BB%96%E7%94%A8%E6%B3%95/"/>
    <id>https://kanoc.gitee.io/2025/06/11/Go-%E4%B8%AD%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E5%AE%9A%E4%B8%8E%E5%85%B6%E4%BB%96%E7%94%A8%E6%B3%95/</id>
    <published>2025-06-10T18:30:42.000Z</published>
    <updated>2025-07-24T10:01:01.773Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Go_中<code>传递参数</code>类型的判定与其他用法</strong></font></p><span id="more"></span><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchDB</span><span class="params">(DbModel *gorm.DB, Parms <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, SqlKey <span class="type">string</span>, tableOrModel <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">  <span class="comment">// 特别注意 tableOrModel interface&#123;&#125;  表示可以传递任意值</span></span><br><span class="line">    fmt.Println(tableOrModel)</span><br><span class="line">    <span class="comment">// 验证表名</span></span><br><span class="line">    TableName := <span class="string">&quot;&quot;</span>    <span class="comment">// 初始化变量 为空字符串</span></span><br><span class="line">    <span class="keyword">switch</span> v := tableOrModel.(<span class="keyword">type</span>) &#123;    <span class="comment">//这里  类型开关(type switch)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:  <span class="comment">//如果 v的类型是 string  那么 TableName=v</span></span><br><span class="line">       TableName = v</span><br><span class="line">    <span class="keyword">case</span> *<span class="type">string</span>:                               <span class="comment">// 如果 v 的类型是指针</span></span><br><span class="line">       <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;                            <span class="comment">// 判定 v 是否为空值</span></span><br><span class="line">          <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;表名指针不能为空&quot;</span>)    <span class="comment">// 如果 v 的值是空的，返回错误提示 表名不得为空</span></span><br><span class="line">       &#125;</span><br><span class="line">       TableName = *v                           <span class="comment">// 否则 TableName = v指针指向的值</span></span><br><span class="line">    <span class="keyword">default</span>:             <span class="comment">// 如果以上都不是，默认走的分支</span></span><br><span class="line">       <span class="comment">// 尝试从模型获取表名</span></span><br><span class="line">       <span class="comment">// 这里拆开看 会清晰一点</span></span><br><span class="line">       <span class="comment">// model, ok := v.(interface&#123; TableName() string &#125;)</span></span><br><span class="line">       <span class="comment">// 这里定义返回值：v.(interface&#123; TableName() string &#125;) 其实就是 对 interface&#123; TableName() string &#125; 进行类型的判断</span></span><br><span class="line">       <span class="comment">// .()：类型断言操作符</span></span><br><span class="line">       <span class="comment">// interface&#123; TableName() string &#125;：一个接口类型，要求实现 TableName() string 方法</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// if ok &#123;TableName = model.TableName()&#125;</span></span><br><span class="line">      </span><br><span class="line">       <span class="keyword">if</span> model, ok := v.(<span class="keyword">interface</span>&#123; TableName() <span class="type">string</span> &#125;); ok &#123; <span class="comment">//interface&#123; TableName() string &#125;，检查是否有 func TableName() string 方法</span></span><br><span class="line">          TableName = model.TableName()</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 使用反射获取类型名称 详解见下方总结</span></span><br><span class="line">          t := reflect.TypeOf(v) <span class="comment">// 获取对象的类型</span></span><br><span class="line">          <span class="keyword">if</span> t.Kind() == reflect.Ptr &#123;</span><br><span class="line">             t = t.Elem()</span><br><span class="line">          &#125;</span><br><span class="line">          TableName = t.Name()</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> TableName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;表名不能为空&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据操作类型执行相应操作</span></span><br><span class="line">    <span class="keyword">switch</span> strings.ToLower(SqlKey) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;insert&quot;</span>:</span><br><span class="line">       <span class="keyword">return</span> handleInsert(DbModel, Parms, TableName)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;find&quot;</span>:</span><br><span class="line">       <span class="keyword">return</span> handleFind(DbModel, Parms, TableName)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;update&quot;</span>:</span><br><span class="line">       <span class="keyword">return</span> handleUpdate(DbModel, Parms, TableName)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;无效的操作类型: %s (支持: insert, find, update)&quot;</span>, SqlKey)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>获取类型对象</strong>：<code>reflect.TypeOf(v)</code> → 获取类型信息</li><li><strong>检查指针类型</strong>：<code>t.Kind() == reflect.Ptr</code> → 是否为指针</li><li><strong>解引用指针</strong>：<code>t = t.Elem()</code> → 获取指针指向的实际类型</li><li><strong>获取类型名称</strong>：<code>t.Name()</code> → 类型的字符串名称</li></ol><h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><ul><li><code>Elem()</code> 用于解引用指针，获取其指向的类型</li><li><code>Name()</code> 返回类型的名称，对于命名类型有效</li><li>对于指针类型，需要解引用后才能获取实际类型的名称</li><li>匿名类型和基本类型处理需要特别注意</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Go_中&lt;code&gt;传递参数&lt;/code&gt;类型的判定与其他用法&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/categories/Golang/"/>
    
    <category term="基础" scheme="https://kanoc.gitee.io/categories/Golang/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Go_interface接口可容纳的值</title>
    <link href="https://kanoc.gitee.io/2025/06/11/Go-interface%E6%8E%A5%E5%8F%A3%E5%8F%AF%E5%AE%B9%E7%BA%B3%E7%9A%84%E5%80%BC/"/>
    <id>https://kanoc.gitee.io/2025/06/11/Go-interface%E6%8E%A5%E5%8F%A3%E5%8F%AF%E5%AE%B9%E7%BA%B3%E7%9A%84%E5%80%BC/</id>
    <published>2025-06-10T17:07:33.000Z</published>
    <updated>2025-06-10T17:11:47.499Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong><code>Go</code> <code>[可容纳的值]interface&#123;&#125;</code>接口可容纳的值</strong></font></p><span id="more"></span><h1 id="map-string-interface-的值类型详解"><a href="#map-string-interface-的值类型详解" class="headerlink" title="map[string]interface{} 的值类型详解"></a><code>map[string]interface&#123;&#125;</code> 的值类型详解</h1><p>在 Go 语言中，<code>map[string]interface&#123;&#125;</code> 的值类型可以是<strong>任何类型</strong>，因为 <code>interface&#123;&#125;</code> 是空接口，可以容纳任何值。下面是所有可能的类型分类：</p><h2 id="📊-所有可用类型一览"><a href="#📊-所有可用类型一览" class="headerlink" title="📊 所有可用类型一览"></a>📊 所有可用类型一览</h2><h3 id="1-基础类型"><a href="#1-基础类型" class="headerlink" title="1. 基础类型"></a>1. 基础类型</h3><table><thead><tr><th>类型</th><th>示例值</th><th>说明</th></tr></thead><tbody><tr><td><code>bool</code></td><td><code>true</code></td><td>布尔值</td></tr><tr><td><code>string</code></td><td><code>&quot;hello&quot;</code></td><td>字符串</td></tr><tr><td><code>int</code></td><td><code>42</code></td><td>整数</td></tr><tr><td><code>int8</code></td><td><code>int8(100)</code></td><td>8位整数</td></tr><tr><td><code>int16</code></td><td><code>int16(10000)</code></td><td>16位整数</td></tr><tr><td><code>int32</code></td><td><code>int32(1000000)</code></td><td>32位整数</td></tr><tr><td><code>int64</code></td><td><code>int64(10000000000)</code></td><td>64位整数</td></tr><tr><td><code>uint</code></td><td><code>uint(42)</code></td><td>无符号整数</td></tr><tr><td><code>uint8</code></td><td><code>uint8(200)</code></td><td>8位无符号整数</td></tr><tr><td><code>uint16</code></td><td><code>uint16(50000)</code></td><td>16位无符号整数</td></tr><tr><td><code>uint32</code></td><td><code>uint32(4000000000)</code></td><td>32位无符号整数</td></tr><tr><td><code>uint64</code></td><td><code>uint64(10000000000000000000)</code></td><td>64位无符号整数</td></tr><tr><td><code>byte</code></td><td><code>byte(&#39;A&#39;)</code></td><td><code>uint8</code> 的别名</td></tr><tr><td><code>rune</code></td><td><code>rune(&#39;中&#39;)</code></td><td><code>int32</code> 的别名</td></tr><tr><td><code>float32</code></td><td><code>float32(3.14)</code></td><td>32位浮点数</td></tr><tr><td><code>float64</code></td><td><code>3.1415926535</code></td><td>64位浮点数</td></tr><tr><td><code>complex64</code></td><td><code>complex64(1+2i)</code></td><td>64位复数</td></tr><tr><td><code>complex128</code></td><td><code>2+3i</code></td><td>128位复数</td></tr></tbody></table><h3 id="2-复合类型"><a href="#2-复合类型" class="headerlink" title="2. 复合类型"></a>2. 复合类型</h3><table><thead><tr><th>类型</th><th>示例值</th><th>说明</th></tr></thead><tbody><tr><td><code>map[string]interface&#123;&#125;</code></td><td><code>map[string]interface&#123;&#125;&#123;&quot;key&quot;: &quot;value&quot;&#125;</code></td><td>嵌套映射</td></tr><tr><td><code>[]interface&#123;&#125;</code></td><td><code>[]interface&#123;&#125;&#123;1, &quot;two&quot;, true&#125;</code></td><td>混合类型切片</td></tr><tr><td><code>[]string</code></td><td><code>[]string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</code></td><td>字符串切片</td></tr><tr><td><code>[]int</code></td><td><code>[]int&#123;1, 2, 3&#125;</code></td><td>整数切片</td></tr><tr><td><code>[3]int</code></td><td><code>[3]int&#123;1, 2, 3&#125;</code></td><td>固定长度数组</td></tr><tr><td><code>chan int</code></td><td><code>make(chan int)</code></td><td>整数通道</td></tr><tr><td><code>func()</code></td><td><code>func() &#123; fmt.Println(&quot;hello&quot;) &#125;</code></td><td>函数类型</td></tr></tbody></table><h3 id="3-指针类型"><a href="#3-指针类型" class="headerlink" title="3. 指针类型"></a>3. 指针类型</h3><table><thead><tr><th>类型</th><th>示例值</th><th>说明</th></tr></thead><tbody><tr><td><code>*int</code></td><td><code>new(int)</code></td><td>整数指针</td></tr><tr><td><code>*string</code></td><td><code>strPtr := new(string)</code></td><td>字符串指针</td></tr><tr><td><code>*struct&#123;&#125;</code></td><td><code>&amp;MyStruct&#123;Field: &quot;val&quot;&#125;</code></td><td>结构体指针</td></tr><tr><td><code>unsafe.Pointer</code></td><td><code>unsafe.Pointer(&amp;x)</code></td><td>通用指针类型</td></tr></tbody></table><h3 id="4-接口类型"><a href="#4-接口类型" class="headerlink" title="4. 接口类型"></a>4. 接口类型</h3><table><thead><tr><th>类型</th><th>示例值</th><th>说明</th></tr></thead><tbody><tr><td><code>error</code></td><td><code>errors.New(&quot;error&quot;)</code></td><td>错误接口</td></tr><tr><td><code>io.Reader</code></td><td><code>os.Stdin</code></td><td>读取器接口</td></tr><tr><td>自定义接口</td><td><code>MyInterfaceImpl&#123;&#125;</code></td><td>任何接口实现</td></tr></tbody></table><h3 id="5-结构体类型"><a href="#5-结构体类型" class="headerlink" title="5. 结构体类型"></a>5. 结构体类型</h3><table><thead><tr><th>类型</th><th>示例值</th><th>说明</th></tr></thead><tbody><tr><td><code>time.Time</code></td><td><code>time.Now()</code></td><td>时间结构体</td></tr><tr><td><code>sync.Mutex</code></td><td><code>sync.Mutex&#123;&#125;</code></td><td>互斥锁结构体</td></tr><tr><td>自定义结构体</td><td><code>MyStruct&#123;Field: &quot;value&quot;&#125;</code></td><td>任何自定义结构体</td></tr></tbody></table><h3 id="6-特殊类型"><a href="#6-特殊类型" class="headerlink" title="6. 特殊类型"></a>6. 特殊类型</h3><table><thead><tr><th>类型</th><th>示例值</th><th>说明</th></tr></thead><tbody><tr><td><code>nil</code></td><td><code>nil</code></td><td>空值</td></tr><tr><td><code>reflect.Value</code></td><td><code>reflect.ValueOf(42)</code></td><td>反射值</td></tr><tr><td><code>reflect.Type</code></td><td><code>reflect.TypeOf(&quot;&quot;)</code></td><td>反射类型</td></tr><tr><td><code>big.Int</code></td><td><code>big.NewInt(1000)</code></td><td>大整数</td></tr></tbody></table><h2 id="🧪-使用示例"><a href="#🧪-使用示例" class="headerlink" title="🧪 使用示例"></a>🧪 使用示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/big&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">Method()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInterfaceImpl <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInterfaceImpl)</span></span> Method() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="comment">// 基础类型</span></span><br><span class="line"><span class="string">&quot;bool&quot;</span>:       <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;string&quot;</span>:     <span class="string">&quot;hello&quot;</span>,</span><br><span class="line"><span class="string">&quot;int&quot;</span>:        <span class="number">42</span>,</span><br><span class="line"><span class="string">&quot;float32&quot;</span>:    <span class="type">float32</span>(<span class="number">3.14</span>),</span><br><span class="line"><span class="string">&quot;complex128&quot;</span>: <span class="built_in">complex</span>(<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复合类型</span></span><br><span class="line"><span class="string">&quot;slice&quot;</span>:      []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">1</span>, <span class="string">&quot;two&quot;</span>, <span class="literal">true</span>&#125;,</span><br><span class="line"><span class="string">&quot;map&quot;</span>:        <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>&#125;,</span><br><span class="line"><span class="string">&quot;array&quot;</span>:      [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line"><span class="string">&quot;func&quot;</span>:       <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;I&#x27;m a function&quot;</span>) &#125;,</span><br><span class="line"><span class="string">&quot;chan&quot;</span>:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型</span></span><br><span class="line"><span class="string">&quot;int_ptr&quot;</span>:    <span class="built_in">new</span>(<span class="type">int</span>),</span><br><span class="line"><span class="string">&quot;struct_ptr&quot;</span>: &amp;CustomStruct&#123;Name: <span class="string">&quot;pointer&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;unsafe_ptr&quot;</span>: unsafe.Pointer(&amp;data),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口类型</span></span><br><span class="line"><span class="string">&quot;error&quot;</span>:      fmt.Errorf(<span class="string">&quot;example error&quot;</span>),</span><br><span class="line"><span class="string">&quot;reader&quot;</span>:     os.Stdin, <span class="comment">// 假设 os 已导入</span></span><br><span class="line"><span class="string">&quot;interface&quot;</span>:  MyInterfaceImpl&#123;&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体类型</span></span><br><span class="line"><span class="string">&quot;time&quot;</span>:       time.Now(),</span><br><span class="line"><span class="string">&quot;mutex&quot;</span>:      sync.Mutex&#123;&#125;,</span><br><span class="line"><span class="string">&quot;custom&quot;</span>:     CustomStruct&#123;Name: <span class="string">&quot;value&quot;</span>&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊类型</span></span><br><span class="line"><span class="string">&quot;nil&quot;</span>:        <span class="literal">nil</span>,</span><br><span class="line"><span class="string">&quot;reflect_value&quot;</span>: reflect.ValueOf(<span class="number">42</span>),</span><br><span class="line"><span class="string">&quot;big_int&quot;</span>:    big.NewInt(<span class="number">1000000000000000000</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问不同类型的值</span></span><br><span class="line"><span class="keyword">if</span> f, ok := data[<span class="string">&quot;float32&quot;</span>].(<span class="type">float32</span>); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Float32 value: %.2f\n&quot;</span>, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> m, ok := data[<span class="string">&quot;map&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>); ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Map value:&quot;</span>, m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态类型处理</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> data &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;\nKey: %-15s | Type: %-20T | Value: %v&quot;</span>, key, value, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON 序列化（注意：部分类型不能序列化）</span></span><br><span class="line">jsonData, _ := json.MarshalIndent(data, <span class="string">&quot;&quot;</span>, <span class="string">&quot;  &quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;\n\nJSON representation:&quot;</span>)</span><br><span class="line">fmt.Println(<span class="type">string</span>(jsonData))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⚠️-重要注意事项"><a href="#⚠️-重要注意事项" class="headerlink" title="⚠️ 重要注意事项"></a>⚠️ 重要注意事项</h2><ol><li><p><strong>类型断言</strong>：从 <code>interface&#123;&#125;</code> 获取值时必须进行类型断言</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> str, ok := myMap[<span class="string">&quot;key&quot;</span>].(<span class="type">string</span>); ok &#123;</span><br><span class="line">    <span class="comment">// 正确使用字符串值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>JSON 序列化限制</strong>：</p><ul><li>通道、函数、循环引用的结构体不能序列化为 JSON</li><li>指针类型会序列化为其指向的值</li><li><code>time.Time</code> 会序列化为 RFC3339 格式字符串</li></ul></li><li><p><strong>性能考虑</strong>：</p><ul><li>使用具体类型比 <code>interface&#123;&#125;</code> 更高效</li><li>频繁操作时考虑具体类型或代码生成方案</li></ul></li><li><p><strong>类型安全</strong>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 危险：运行时可能 panic</span></span><br><span class="line">str := myMap[<span class="string">&quot;key&quot;</span>].(<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全：带检查的类型断言</span></span><br><span class="line"><span class="keyword">if</span> str, ok := myMap[<span class="string">&quot;key&quot;</span>].(<span class="type">string</span>); ok &#123;</span><br><span class="line">    <span class="comment">// 安全使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>替代方案</strong>：</p><ul><li><p>通用结构体方案：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> GenericValue <span class="keyword">struct</span> &#123;</span><br><span class="line">    Type  <span class="type">string</span></span><br><span class="line">    Value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码生成方案（如使用 <code>stringer</code> 工具）</p></li><li><p>Protobuf 的 <code>Any</code> 类型</p></li></ul></li></ol><h2 id="💡-最佳实践"><a href="#💡-最佳实践" class="headerlink" title="💡 最佳实践"></a>💡 最佳实践</h2><ol><li><p><strong>优先使用具体类型</strong>：尽可能使用具体类型而非 <code>interface&#123;&#125;</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优于 map[string]interface&#123;&#125;</span></span><br><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure></li><li><p><strong>定义边界清晰的接口</strong>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Storage <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get(key <span class="type">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)</span><br><span class="line">    Set(key <span class="type">string</span>, value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用类型开关处理多种类型</strong>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processValue</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> val := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;String:&quot;</span>, val)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Int:&quot;</span>, val)</span><br><span class="line">    <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>:</span><br><span class="line">        val()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Unhandled type: %T\n&quot;</span>, val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>限制可接受类型</strong>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allowedTypes = <span class="keyword">map</span>[reflect.Kind]<span class="type">bool</span>&#123;</span><br><span class="line">    reflect.String:  <span class="literal">true</span>,</span><br><span class="line">    reflect.Int:     <span class="literal">true</span>,</span><br><span class="line">    reflect.Float64: <span class="literal">true</span>,</span><br><span class="line">    reflect.Bool:    <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidateValue</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    kind := reflect.TypeOf(v).Kind()</span><br><span class="line">    <span class="keyword">return</span> allowedTypes[kind]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>文档化预期类型</strong>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Config holds application configuration</span></span><br><span class="line"><span class="comment">// Possible types per key:</span></span><br><span class="line"><span class="comment">//   &quot;timeout&quot;: int (seconds)</span></span><br><span class="line"><span class="comment">//   &quot;debug&quot;: bool</span></span><br><span class="line"><span class="comment">//   &quot;servers&quot;: []string</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="🌟-总结"><a href="#🌟-总结" class="headerlink" title="🌟 总结"></a>🌟 总结</h2><p><code>map[string]interface&#123;&#125;</code> 的值可以是 Go 语言中的<strong>任何类型</strong>，包括：</p><ol><li>所有基础类型（bool, 数值, 字符串, 复数）</li><li>复合类型（切片、映射、数组、通道、函数）</li><li>指针类型（包括 unsafe 指针）</li><li>接口类型（包括 error 等内置接口）</li><li>结构体类型（内置和自定义）</li><li>特殊类型（nil, 反射对象, 大整数等）</li></ol><p>这种灵活性使其成为处理动态数据、JSON 解析、配置管理和通用存储的理想选择。然而，使用时需要谨慎处理类型安全和性能问题，特别是对于性能敏感的应用程序。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;&lt;code&gt;Go&lt;/code&gt; &lt;code&gt;[可容纳的值]interface&amp;#123;&amp;#125;&lt;/code&gt;接口可容纳的值&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/categories/Golang/"/>
    
    <category term="文档" scheme="https://kanoc.gitee.io/categories/Golang/%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/tags/Golang/"/>
    
    <category term="接口" scheme="https://kanoc.gitee.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Go_ORM_mysql数据库模版</title>
    <link href="https://kanoc.gitee.io/2025/06/10/Go-ORM-mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E7%89%88/"/>
    <id>https://kanoc.gitee.io/2025/06/10/Go-ORM-mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E7%89%88/</id>
    <published>2025-06-10T11:31:46.000Z</published>
    <updated>2025-06-10T12:04:20.236Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Go ORM mysql数据库模版</strong></font></p><span id="more"></span><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">// go get -u gorm.io/driver/mysql  // 安装mysql 驱动</span></span><br><span class="line"><span class="comment">// go get -u gorm.io/gorm</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">    <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">    <span class="string">&quot;gorm.io/gorm/logger&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> v1Table <span class="keyword">struct</span> &#123; <span class="comment">// 需要修改的字段映射</span></span><br><span class="line">    Id           <span class="type">uint32</span> <span class="string">`gorm:&quot;column:id;AUTO_INCREMENT&quot;`</span></span><br><span class="line">    Md5Id        <span class="type">string</span> <span class="string">`gorm:&quot;column:Md5Id&quot;`</span></span><br><span class="line">    Title        <span class="type">string</span> <span class="string">`gorm:&quot;column:title&quot;`</span></span><br><span class="line">  <span class="comment">// 创建时间 - 只在第一次插入时设置</span></span><br><span class="line">    InsertTime time.Time <span class="string">`gorm:&quot;column:InsertTime;autoCreateTime&quot;`</span></span><br><span class="line">    <span class="comment">// 更新时间 - 每次更新时自动更新</span></span><br><span class="line">    UpTime       time.Time <span class="string">`gorm:&quot;column:UpTime;autoUpdateTime&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> v2Table <span class="keyword">struct</span> &#123; <span class="comment">// 需要修改的字段映射</span></span><br><span class="line">    Id    <span class="type">uint32</span> <span class="string">`gorm:&quot;column:id;AUTO_INCREMENT&quot;`</span></span><br><span class="line">    Md5Id <span class="type">string</span> <span class="string">`gorm:&quot;column:Md5Id&quot;`</span></span><br><span class="line">    Title        <span class="type">string</span> <span class="string">`gorm:&quot;column:Title&quot;`</span>        <span class="comment">// 全名称</span></span><br><span class="line">    <span class="comment">// 创建时间 - 只在第一次插入时设置</span></span><br><span class="line">    InsertTime time.Time <span class="string">`gorm:&quot;column:InsertTime;autoCreateTime&quot;`</span></span><br><span class="line">    <span class="comment">// 更新时间 - 每次更新时自动更新</span></span><br><span class="line">    UpTime       time.Time <span class="string">`gorm:&quot;column:UpTime;autoUpdateTime&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v1Table)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;v1Table&quot;</span> <span class="comment">// 数据库表的名称</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v2Table)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;v2Table&quot;</span> <span class="comment">// 数据库表的名称</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置数据库 参数</span></span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">    user   <span class="type">string</span></span><br><span class="line">    pass   <span class="type">string</span></span><br><span class="line">    adrr   <span class="type">string</span></span><br><span class="line">    port   <span class="type">string</span></span><br><span class="line">    dbname <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    db     *gorm.DB</span><br><span class="line">    dbOnce sync.Once <span class="comment">// 确保连接只初始化一次</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetDB 获取数据库连接实例 (线程安全)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDB</span><span class="params">()</span></span> *gorm.DB &#123;</span><br><span class="line">    <span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</span><br><span class="line">       dbOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">          initDB()</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initDB 初始化数据库连接 (只执行一次)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conf := &amp;config&#123;</span><br><span class="line">       user:   <span class="string">&quot;TestDBSql&quot;</span>,        <span class="comment">// 用户名</span></span><br><span class="line">       pass:   <span class="string">&quot;msEs3IlksfJi&quot;</span>, <span class="comment">// 密码</span></span><br><span class="line">       adrr:   <span class="string">&quot;127.0.0.1&quot;</span>,        <span class="comment">// 地址</span></span><br><span class="line">       port:   <span class="string">&quot;3306&quot;</span>,             <span class="comment">// 端口</span></span><br><span class="line">       dbname: <span class="string">&quot;TestDBSql&quot;</span>,        <span class="comment">// 数据库名称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dsn := fmt.Sprintf(<span class="string">&quot;%s:%s@tcp(%s:%s)/%s?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>,</span><br><span class="line">       conf.user, conf.pass, conf.adrr, conf.port, conf.dbname)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;</span><br><span class="line">       Logger: logger.Default.LogMode(logger.Info),</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(<span class="string">&quot;failed to connect database: &quot;</span> + err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================= 新增自动迁移逻辑 =================</span></span><br><span class="line">    <span class="comment">// 自动创建/更新表结构（注意：GORM的AutoMigrate只会新增字段，不会删除/修改已有字段）</span></span><br><span class="line">    err = db.AutoMigrate(</span><br><span class="line">       &amp;VideoTable&#123;&#125;,</span><br><span class="line">       &amp;MhTable&#123;&#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(<span class="string">&quot;auto migrate failed: &quot;</span> + err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置连接池</span></span><br><span class="line">    sqlDB, err := db.DB()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(<span class="string">&quot;failed to get underlying sql.DB: &quot;</span> + err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接池配置</span></span><br><span class="line">    sqlDB.SetMaxIdleConns(<span class="number">10</span>)                  <span class="comment">// 空闲连接数</span></span><br><span class="line">    sqlDB.SetMaxOpenConns(<span class="number">100</span>)                 <span class="comment">// 最大打开连接数</span></span><br><span class="line">    sqlDB.SetConnMaxLifetime(<span class="number">30</span> * time.Minute) <span class="comment">// 连接最大存活时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestClientDb</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    db := GetDB()</span><br><span class="line">    <span class="keyword">var</span> V1 v1Table</span><br><span class="line">    db.Where(<span class="string">&quot;id = ?&quot;</span>, <span class="number">1</span>).First(&amp;video)</span><br><span class="line">    ub := &amp;V1&#123;&#125;</span><br><span class="line">    err := db.Where(<span class="string">&quot;Title = ?&quot;</span>, <span class="string">&quot;测试&quot;</span>).Find(&amp;ub).Error</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;userBase:%+v&quot;</span>, ub)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特别说明："><a href="#特别说明：" class="headerlink" title="特别说明："></a>特别说明：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">InsertTime time.Time <span class="string">`gorm:&quot;column:InsertTime;autoCreateTime&quot;`</span> </span><br><span class="line"><span class="comment">// autoCreateTime: 只在记录创建时自动设置当前时间</span></span><br><span class="line"></span><br><span class="line">UpTime     time.Time <span class="string">`gorm:&quot;column:UpTime;autoUpdateTime&quot;`</span></span><br><span class="line"><span class="comment">// autoUpdateTime: 在创建和更新时都自动设置当前时间</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Go ORM mysql数据库模版&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/categories/Golang/"/>
    
    <category term="数据库" scheme="https://kanoc.gitee.io/categories/Golang/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/tags/Golang/"/>
    
    <category term="ORM" scheme="https://kanoc.gitee.io/tags/ORM/"/>
    
    <category term="mysql" scheme="https://kanoc.gitee.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Go_Gorm支持的数据类型</title>
    <link href="https://kanoc.gitee.io/2025/06/10/Go-Gorm%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://kanoc.gitee.io/2025/06/10/Go-Gorm%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2025-06-10T11:04:42.000Z</published>
    <updated>2025-06-10T11:08:16.820Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Go_Gorm支持的数据类型</strong></font></p><span id="more"></span><p>GORM 支持广泛的 Go 数据类型，并能自动将它们映射到对应的数据库类型。以下是 GORM 支持的主要数据类型及其在常见数据库（如 MySQL）中的映射关系：</p><hr><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a><strong>基础数据类型</strong></h3><table><thead><tr><th align="left">Go 类型</th><th align="left">MySQL 类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>bool</code></td><td align="left"><code>TINYINT(1)</code></td><td align="left">布尔值，true&#x3D;1, false&#x3D;0</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>INT</code></td><td align="left">32位整数</td></tr><tr><td align="left"><code>int8</code></td><td align="left"><code>TINYINT</code></td><td align="left">8位整数</td></tr><tr><td align="left"><code>int16</code></td><td align="left"><code>SMALLINT</code></td><td align="left">16位整数</td></tr><tr><td align="left"><code>int32</code></td><td align="left"><code>INT</code></td><td align="left">32位整数</td></tr><tr><td align="left"><code>int64</code></td><td align="left"><code>BIGINT</code></td><td align="left">64位整数</td></tr><tr><td align="left"><code>uint</code></td><td align="left"><code>INT UNSIGNED</code></td><td align="left">无符号32位整数</td></tr><tr><td align="left"><code>uint8</code></td><td align="left"><code>TINYINT UNSIGNED</code></td><td align="left">无符号8位整数</td></tr><tr><td align="left"><code>uint16</code></td><td align="left"><code>SMALLINT UNSIGNED</code></td><td align="left">无符号16位整数</td></tr><tr><td align="left"><code>uint32</code></td><td align="left"><code>INT UNSIGNED</code></td><td align="left">无符号32位整数</td></tr><tr><td align="left"><code>uint64</code></td><td align="left"><code>BIGINT UNSIGNED</code></td><td align="left">无符号64位整数</td></tr><tr><td align="left"><code>float32</code></td><td align="left"><code>FLOAT</code></td><td align="left">单精度浮点数</td></tr><tr><td align="left"><code>float64</code></td><td align="left"><code>DOUBLE</code></td><td align="left">双精度浮点数</td></tr><tr><td align="left"><code>string</code></td><td align="left"><code>VARCHAR(255)</code></td><td align="left">字符串（默认长度255），可通过标签指定长度</td></tr><tr><td align="left"><code>[]byte</code></td><td align="left"><code>BLOB</code>&#x2F;<code>LONGBLOB</code></td><td align="left">二进制数据</td></tr><tr><td align="left"><code>time.Time</code></td><td align="left"><code>DATETIME</code>&#x2F;<code>TIMESTAMP</code></td><td align="left">时间类型，默认精度到秒</td></tr></tbody></table><hr><h3 id="高级-特殊类型"><a href="#高级-特殊类型" class="headerlink" title="高级&#x2F;特殊类型"></a><strong>高级&#x2F;特殊类型</strong></h3><table><thead><tr><th align="left">Go 类型&#x2F;用法</th><th align="left">MySQL 类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>*int</code> &#x2F; <code>sql.NullInt64</code></td><td align="left"><code>INT NULL</code></td><td align="left">可空整数</td></tr><tr><td align="left"><code>*bool</code> &#x2F; <code>sql.NullBool</code></td><td align="left"><code>TINYINT(1) NULL</code></td><td align="left">可空布尔值</td></tr><tr><td align="left"><code>*string</code> &#x2F; <code>sql.NullString</code></td><td align="left"><code>VARCHAR(255) NULL</code></td><td align="left">可空字符串</td></tr><tr><td align="left"><code>*float64</code> &#x2F; <code>sql.NullFloat64</code></td><td align="left"><code>DOUBLE NULL</code></td><td align="left">可空浮点数</td></tr><tr><td align="left"><code>*time.Time</code> &#x2F; <code>sql.NullTime</code></td><td align="left"><code>DATETIME NULL</code></td><td align="left">可空时间</td></tr><tr><td align="left"><code>gorm.DeletedAt</code></td><td align="left"><code>DATETIME NULL</code></td><td align="left">软删除字段</td></tr><tr><td align="left"><code>json.RawMessage</code></td><td align="left"><code>JSON</code> (MySQL 5.7+)</td><td align="left">JSON 数据（需要数据库支持）</td></tr><tr><td align="left"><code>map[string]interface&#123;&#125;</code></td><td align="left"><code>JSON</code></td><td align="left">JSON 对象</td></tr><tr><td align="left"><code>[]string</code> &#x2F; <code>[]int</code></td><td align="left"><code>JSON</code></td><td align="left">数组（序列化为 JSON）</td></tr><tr><td align="left"><code>uuid.UUID</code> (github.com&#x2F;google&#x2F;uuid)</td><td align="left"><code>CHAR(36)</code></td><td align="left">UUID 类型</td></tr><tr><td align="left"><code>decimal.Decimal</code> (github.com&#x2F;shopspring&#x2F;decimal)</td><td align="left"><code>DECIMAL(65,30)</code></td><td align="left">高精度十进制数</td></tr></tbody></table><hr><h3 id="自定义类型处理"><a href="#自定义类型处理" class="headerlink" title="自定义类型处理"></a><strong>自定义类型处理</strong></h3><p>GORM 支持通过接口实现自定义类型：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyCustomType <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Valuer 接口 - 定义如何存储到数据库</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyCustomType)</span></span> Value() (driver.Value, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> strings.ToUpper(<span class="type">string</span>(m)), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Scanner 接口 - 定义如何从数据库读取</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyCustomType)</span></span> Scan(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> value == <span class="literal">nil</span> &#123;</span><br><span class="line">        *m = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> v, ok := value.([]<span class="type">byte</span>); ok &#123;</span><br><span class="line">        *m = MyCustomType(strings.ToLower(<span class="type">string</span>(v)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot convert %T to MyCustomType&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">uint</span></span><br><span class="line">    Role MyCustomType <span class="string">`gorm:&quot;type:VARCHAR(10)&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="类型映射控制"><a href="#类型映射控制" class="headerlink" title="类型映射控制"></a><strong>类型映射控制</strong></h3><p>可以通过 GORM 标签精确控制数据库类型：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID          <span class="type">uint</span>      <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">    Name        <span class="type">string</span>    <span class="string">`gorm:&quot;type:VARCHAR(100);not null&quot;`</span></span><br><span class="line">    Price       <span class="type">float64</span>   <span class="string">`gorm:&quot;type:DECIMAL(10,2)&quot;`</span></span><br><span class="line">    Description <span class="type">string</span>    <span class="string">`gorm:&quot;type:TEXT&quot;`</span></span><br><span class="line">    IsActive    <span class="type">bool</span>      <span class="string">`gorm:&quot;default:true&quot;`</span></span><br><span class="line">    CreatedAt   time.Time <span class="string">`gorm:&quot;type:TIMESTAMP;default:CURRENT_TIMESTAMP&quot;`</span></span><br><span class="line">    Metadata    JSON      <span class="string">`gorm:&quot;type:JSON&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 JSON 类型</span></span><br><span class="line"><span class="keyword">type</span> JSON <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j JSON)</span></span> Value() (driver.Value, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> json.Marshal(j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j *JSON)</span></span> Scan(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> value == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    b, ok := value.([]<span class="type">byte</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;type assertion to []byte failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> json.Unmarshal(b, &amp;j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="枚举类型处理"><a href="#枚举类型处理" class="headerlink" title="枚举类型处理"></a><strong>枚举类型处理</strong></h3><p>虽然 Go 没有原生枚举，但可以通过字符串+检查实现：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="type">uint</span></span><br><span class="line">    Status <span class="type">string</span> <span class="string">`gorm:&quot;type:ENUM(&#x27;active&#x27;, &#x27;inactive&#x27;, &#x27;pending&#x27;);default:&#x27;pending&#x27;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加检查约束</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeSave(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">    validStatus := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>&#123;<span class="string">&quot;active&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;inactive&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;pending&quot;</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> !validStatus[u.Status] &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;invalid status value&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="自动类型推断"><a href="#自动类型推断" class="headerlink" title="自动类型推断"></a><strong>自动类型推断</strong></h3><p>当使用 <code>AutoMigrate</code> 时，GORM 会根据 Go 类型自动创建合适的数据库列：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.AutoMigrate(&amp;Product&#123;&#125;)</span><br><span class="line"><span class="comment">// 会自动创建：</span></span><br><span class="line"><span class="comment">// - VARCHAR(255) for string</span></span><br><span class="line"><span class="comment">// - BIGINT for int64</span></span><br><span class="line"><span class="comment">// - FLOAT for float32</span></span><br><span class="line"><span class="comment">// - DOUBLE for float64</span></span><br><span class="line"><span class="comment">// - TINYINT(1) for bool</span></span><br><span class="line"><span class="comment">// - DATETIME for time.Time</span></span><br></pre></td></tr></table></figure><hr><h3 id="特殊注意事项"><a href="#特殊注意事项" class="headerlink" title="特殊注意事项"></a><strong>特殊注意事项</strong></h3><ol><li><p><strong>时间类型</strong>：</p><ul><li><code>time.Time</code> 默认映射为 <code>DATETIME</code></li><li>使用 <code>gorm:&quot;type:TIMESTAMP&quot;</code> 可指定为时间戳</li><li>使用 <code>gorm:&quot;autoCreateTime&quot;</code> &#x2F; <code>gorm:&quot;autoUpdateTime&quot;</code> 自动管理时间</li></ul></li><li><p><strong>JSON 支持</strong>：</p><ul><li>MySQL 5.7+ 原生支持 JSON 类型</li><li>旧版本可序列化为字符串存储</li></ul></li><li><p><strong>默认值</strong>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Active <span class="type">bool</span> <span class="string">`gorm:&quot;default:true&quot;`</span></span><br></pre></td></tr></table></figure></li><li><p><strong>大小限制</strong>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Description <span class="type">string</span> <span class="string">`gorm:&quot;size:5000&quot;`</span> <span class="comment">// TEXT 类型</span></span><br></pre></td></tr></table></figure></li><li><p><strong>自定义类型映射</strong>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">gorm:<span class="string">&quot;type:MEDIUMTEXT&quot;</span> <span class="comment">// 指定为 MEDIUMTEXT</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="数据库差异"><a href="#数据库差异" class="headerlink" title="数据库差异"></a><strong>数据库差异</strong></h3><table><thead><tr><th align="left">类型</th><th align="left">MySQL</th><th align="left">PostgreSQL</th><th align="left">SQLite</th></tr></thead><tbody><tr><td align="left">布尔值</td><td align="left">TINYINT(1)</td><td align="left">BOOLEAN</td><td align="left">BOOLEAN</td></tr><tr><td align="left">大文本</td><td align="left">LONGTEXT</td><td align="left">TEXT</td><td align="left">TEXT</td></tr><tr><td align="left">数组</td><td align="left">JSON</td><td align="left">ARRAY</td><td align="left">JSON</td></tr><tr><td align="left">JSON</td><td align="left">JSON (5.7+)</td><td align="left">JSONB</td><td align="left">JSON</td></tr><tr><td align="left">时间</td><td align="left">DATETIME</td><td align="left">TIMESTAMP</td><td align="left">DATETIME</td></tr><tr><td align="left">自增ID</td><td align="left">AUTO_INCREMENT</td><td align="left">SERIAL</td><td align="left">AUTOINCREMENT</td></tr></tbody></table><p>建议在模型定义中显式指定类型以确保跨数据库兼容性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Go_Gorm支持的数据类型&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/categories/Golang/"/>
    
    <category term="数据库" scheme="https://kanoc.gitee.io/categories/Golang/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://kanoc.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Golang" scheme="https://kanoc.gitee.io/tags/Golang/"/>
    
    <category term="ORM" scheme="https://kanoc.gitee.io/tags/ORM/"/>
    
    <category term="mysql" scheme="https://kanoc.gitee.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>GoLang的websocket编程</title>
    <link href="https://kanoc.gitee.io/2025/06/08/GoLang%E7%9A%84websocket%E7%BC%96%E7%A8%8B/"/>
    <id>https://kanoc.gitee.io/2025/06/08/GoLang%E7%9A%84websocket%E7%BC%96%E7%A8%8B/</id>
    <published>2025-06-08T05:03:35.000Z</published>
    <updated>2025-06-09T10:44:59.626Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>GoLang的websocket编程</strong></font></p><span id="more"></span><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gorilla/websocket&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> upgrader = websocket.Upgrader&#123;</span><br><span class="line">CheckOrigin: <span class="function"><span class="keyword">func</span><span class="params">(r *http.Request)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;, <span class="comment">// 解决跨域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleWebSocket</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">conn, err := upgrader.Upgrade(w, r, <span class="literal">nil</span>) <span class="comment">// HTTP 升级为 WebSocket</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;升级失败:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msgType, msg, err := conn.ReadMessage() <span class="comment">// 读取消息</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;读取错误:&quot;</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(msg)</span><br><span class="line">fmt.Println(reflect.TypeOf(msg))</span><br><span class="line">fmt.Println(reflect.TypeOf(msgType))</span><br><span class="line">log.Printf(<span class="string">&quot;收到: %s&quot;</span>, msg)</span><br><span class="line"><span class="comment">// 原样返回消息（实现 Echo 服务）</span></span><br><span class="line"><span class="keyword">if</span> err := conn.WriteMessage(msgType, msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;发送错误:&quot;</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/ws&quot;</span>, handleWebSocket)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1、核心代码实现"><a href="#1、核心代码实现" class="headerlink" title="1、核心代码实现"></a>1、核心代码实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字符串转换为字节切片，明确指定为文本消息类型</span></span><br><span class="line"><span class="keyword">if</span> err := conn.WriteMessage(websocket.TextMessage, []<span class="type">byte</span>(msg)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;消息推送失败: %v&quot;</span>, err)</span><br><span class="line">    <span class="comment">// 可选：返回错误信息给调用方</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;推送失败: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// websocket.TextMessage：适用于 UTF-8 编码的字符串（如 JSON/XML）</span></span><br><span class="line"><span class="comment">// websocket.BinaryMessage：适用于二进制数据（如图片/音视频）</span></span><br><span class="line"><span class="comment">// 字符串消息必须使用 TextMessage 类型</span></span><br></pre></td></tr></table></figure><h3 id="2、错误处理优化："><a href="#2、错误处理优化：" class="headerlink" title="2、错误处理优化："></a>2、错误处理优化：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := conn.WriteMessage(websocket.TextMessage, []<span class="type">byte</span>(msg)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 识别特定错误类型</span></span><br><span class="line">    <span class="keyword">if</span> websocket.IsCloseError(err, websocket.CloseNormalClosure) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;连接已正常关闭&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录原始错误日志</span></span><br><span class="line">    log.Printf(<span class="string">&quot;WS_ERR: %v | 消息: %s&quot;</span>, err, msg) </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;服务繁忙，请重试&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区分连接关闭和发送失败场景</span></span><br><span class="line"><span class="comment">// 生产环境建议用结构化日志（如 JSON 格式）</span></span><br></pre></td></tr></table></figure><h2 id="消息推送："><a href="#消息推送：" class="headerlink" title="消息推送："></a>消息推送：</h2><h3 id="1、设置字符串返回类型"><a href="#1、设置字符串返回类型" class="headerlink" title="1、设置字符串返回类型"></a>1、设置字符串返回类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设msg是字符串类型</span></span><br><span class="line">message := <span class="string">&quot;这是要返回的字符串消息&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串转换为字节切片</span></span><br><span class="line">msgBytes := []<span class="type">byte</span>(message)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送文本消息</span></span><br><span class="line"><span class="keyword">if</span> err := conn.WriteMessage(websocket.TextMessage, msgBytes); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    log.Println(<span class="string">&quot;发送消息失败:&quot;</span>, err)</span><br><span class="line">    <span class="comment">// 可以选择断开连接或进行其他处理</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、设置JSON返回类型"><a href="#2、设置JSON返回类型" class="headerlink" title="2、设置JSON返回类型"></a>2、设置<code>JSON</code>返回类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code <span class="type">int</span>    <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">    Data <span class="type">string</span> <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendJSON</span><span class="params">(conn *websocket.Conn, msg <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    resp := Response&#123;Code: <span class="number">200</span>, Data: msg&#125;</span><br><span class="line">    jsonData, _ := json.Marshal(resp)  <span class="comment">// 序列化为 JSON</span></span><br><span class="line">    <span class="keyword">return</span> conn.WriteMessage(websocket.TextMessage, jsonData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、-广播消息实现"><a href="#3、-广播消息实现" class="headerlink" title="3、 广播消息实现"></a>3、 广播消息实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clients = <span class="built_in">make</span>(<span class="keyword">map</span>[*websocket.Conn]<span class="type">bool</span>) <span class="comment">// 全局连接池</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> client := <span class="keyword">range</span> clients &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c *websocket.Conn)</span></span> &#123; <span class="comment">// 并发发送避免阻塞</span></span><br><span class="line">            <span class="keyword">if</span> err := c.WriteMessage(websocket.TextMessage, []<span class="type">byte</span>(msg)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">delete</span>(clients, c) <span class="comment">// 移除失效连接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(client)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⚠️-关键注意事项"><a href="#⚠️-关键注意事项" class="headerlink" title="⚠️ 关键注意事项"></a>⚠️ 关键注意事项</h3><ol><li><p><strong>并发安全</strong></p><ul><li>使用 <code>sync.Mutex</code> 保护共享资源（如 <code>clients</code> 连接池）</li><li>通道传递消息避免竞态条件：</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    Conn *websocket.Conn</span><br><span class="line">    Text <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">msgChan := <span class="built_in">make</span>(<span class="keyword">chan</span> Message, <span class="number">100</span>) <span class="comment">// 缓冲队列</span></span><br></pre></td></tr></table></figure></li><li><p><strong>性能优化</strong></p><ul><li>大消息（&gt; 64KB）启用分片传输：</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn.SetWriteDeadline(time.Now().Add(<span class="number">10</span> * time.Second)) <span class="comment">// 设置超时</span></span><br><span class="line">writer, _ := conn.NextWriter(websocket.TextMessage)</span><br><span class="line">io.Copy(writer, bytes.NewReader(largeData)) <span class="comment">// 流式写入</span></span><br><span class="line">writer.Close()</span><br></pre></td></tr></table></figure><ul><li>启用压缩减少带宽：</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">upgrader := websocket.Upgrader&#123;</span><br><span class="line">    EnableCompression: <span class="literal">true</span>, <span class="comment">// 开启压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>连接生命周期</strong></p><ul><li>心跳机制维持长连接：</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> time.Tick(<span class="number">30</span> * time.Second) &#123;</span><br><span class="line">        <span class="keyword">if</span> err := conn.WriteMessage(websocket.PingMessage, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// 心跳失败终止连接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;GoLang的websocket编程&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://kanoc.gitee.io/categories/Golang/"/>
    
    <category term="websocket" scheme="https://kanoc.gitee.io/categories/Golang/websocket/"/>
    
    
    <category term="websocket" scheme="https://kanoc.gitee.io/tags/websocket/"/>
    
    <category term="Go" scheme="https://kanoc.gitee.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu-apt安装ffmpeg最新版-ffmpeg6-or-ffmpeg7</title>
    <link href="https://kanoc.gitee.io/2025/06/04/Ubuntu-apt%E5%AE%89%E8%A3%85ffmpeg%E6%9C%80%E6%96%B0%E7%89%88-ffmpeg6-or-ffmpeg7/"/>
    <id>https://kanoc.gitee.io/2025/06/04/Ubuntu-apt%E5%AE%89%E8%A3%85ffmpeg%E6%9C%80%E6%96%B0%E7%89%88-ffmpeg6-or-ffmpeg7/</id>
    <published>2025-06-04T12:37:25.000Z</published>
    <updated>2025-06-15T06:02:38.220Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Ubuntu使用<code>apt</code>安装最新版本<code>FFmpeg</code></strong></font></p><span id="more"></span><h3 id="第一步：添加ppa源"><a href="#第一步：添加ppa源" class="headerlink" title="第一步：添加ppa源"></a>第一步：添加<code>ppa</code>源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二选一，重复使用会出现覆盖</span></span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:ubuntuhandbook1/ffmpeg7   <span class="comment"># ffmpeg7版本源</span></span><br><span class="line"><span class="comment"># sudo add-apt-repository ppa:ubuntuhandbook1/ffmpeg6   # ffmpeg6版本源</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除无效的 PPA仓库</span></span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository --remove ppa:ubuntuhandbook1/ffmpeg7</span><br><span class="line"><span class="built_in">sudo</span> apt update    <span class="comment"># 更新软件源列表</span></span><br></pre></td></tr></table></figure><h3 id="第二步：更新apt缓存"><a href="#第二步：更新apt缓存" class="headerlink" title="第二步：更新apt缓存"></a>第二步：更新<code>apt</code>缓存</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h3 id="第三步：安装ffmpeg"><a href="#第三步：安装ffmpeg" class="headerlink" title="第三步：安装ffmpeg"></a>第三步：安装<code>ffmpeg</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install ffmpeg</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 如果之前安装过 ：更新ffmpeg</span></span><br><span class="line"><span class="comment"># sudo apt upgrade ffmpeg    # 更新命令</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/06/04/kLrnaDMZRFsJQ75.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Ubuntu使用&lt;code&gt;apt&lt;/code&gt;安装最新版本&lt;code&gt;FFmpeg&lt;/code&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A5-安装教程" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
    <category term="ubuntu" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/ubuntu/"/>
    
    
    <category term="docker" scheme="https://kanoc.gitee.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>curl_cffi请求指南</title>
    <link href="https://kanoc.gitee.io/2025/05/27/curl-cffi%E8%AF%B7%E6%B1%82%E6%8C%87%E5%8D%97/"/>
    <id>https://kanoc.gitee.io/2025/05/27/curl-cffi%E8%AF%B7%E6%B1%82%E6%8C%87%E5%8D%97/</id>
    <published>2025-05-26T20:36:41.000Z</published>
    <updated>2025-06-10T01:11:53.358Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>curl_cffi请求指南</strong></font></p><span id="more"></span><h3 id="Post方式：multipart-form-data"><a href="#Post方式：multipart-form-data" class="headerlink" title="Post方式：multipart/form-data"></a>Post方式：<code>multipart/form-data</code></h3><p><code>&quot;Content-Type&quot;:&quot;multipart/form-data&quot;</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> curl_cffi <span class="keyword">import</span> requests, CurlMime</span><br><span class="line">mp = CurlMime()  <span class="comment"># 该类是 curl_cffi的上传文件类</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://192.168.2.3:8080/upload&quot;</span>  <span class="comment"># 请求地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文本内容 json</span></span><br><span class="line">payload = &#123;</span><br><span class="line">    <span class="string">&#x27;save_path&#x27;</span>: <span class="string">&#x27;/data/mp4_file/test3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;md5&#x27;</span>: <span class="string">&#x27;4b9975069087e0f0f9e13bf4111b7a03&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/Users/kama/水3.mp4&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data = file.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加文件到 multiple</span></span><br><span class="line">mp.addpart(</span><br><span class="line">    name=<span class="string">&quot;file&quot;</span>,</span><br><span class="line">    content_type=<span class="string">&quot;application/octet-stream&quot;</span>,</span><br><span class="line">    filename=<span class="string">&quot;水3.mp4&quot;</span>,</span><br><span class="line">    data=data,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始发送请求</span></span><br><span class="line">response = requests.post(url, data=payload, multipart=mp, impersonate=<span class="string">&quot;chrome120&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;curl_cffi请求指南&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://kanoc.gitee.io/categories/Python/"/>
    
    <category term="爬虫" scheme="https://kanoc.gitee.io/categories/Python/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Post请求" scheme="https://kanoc.gitee.io/categories/Python/%E7%88%AC%E8%99%AB/Post%E8%AF%B7%E6%B1%82/"/>
    
    
    <category term="request" scheme="https://kanoc.gitee.io/tags/request/"/>
    
    <category term="请求示例" scheme="https://kanoc.gitee.io/tags/%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B/"/>
    
    <category term="指南" scheme="https://kanoc.gitee.io/tags/%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu配置安装GPU转码</title>
    <link href="https://kanoc.gitee.io/2025/05/26/Ubuntu%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85GPU%E8%BD%AC%E7%A0%81/"/>
    <id>https://kanoc.gitee.io/2025/05/26/Ubuntu%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85GPU%E8%BD%AC%E7%A0%81/</id>
    <published>2025-05-26T14:07:58.000Z</published>
    <updated>2025-06-15T05:09:47.342Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#00b2c2 size=5 face=宋体><strong>Ubuntu配置安装GPU转码</strong></font></p><span id="more"></span><h2 id="ubuntu-测试使用-GPU-ffmpeg-转码视频"><a href="#ubuntu-测试使用-GPU-ffmpeg-转码视频" class="headerlink" title="ubuntu 测试使用 GPU-ffmpeg 转码视频"></a>ubuntu 测试使用 GPU-ffmpeg 转码视频</h2><h3 id="额外命令："><a href="#额外命令：" class="headerlink" title="额外命令："></a>额外命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsb_release -a   <span class="comment"># 查看发行版本及代号</span></span><br><span class="line">lspci | grep -i vga   <span class="comment"># 查看是否存在gpu</span></span><br></pre></td></tr></table></figure><h3 id="第一步：安装ffmpeg"><a href="#第一步：安装ffmpeg" class="headerlink" title="第一步：安装ffmpeg"></a>第一步：安装ffmpeg</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install ffmpeg</span><br></pre></td></tr></table></figure><h3 id="第二步：1-安装-NVIDIA-驱动"><a href="#第二步：1-安装-NVIDIA-驱动" class="headerlink" title="第二步：1. 安装 NVIDIA 驱动"></a>第二步：<strong>1. 安装 NVIDIA 驱动</strong></h3><h4 id="1-添加官方驱动仓库并更新"><a href="#1-添加官方驱动仓库并更新" class="headerlink" title="(1) 添加官方驱动仓库并更新"></a>(1) 添加官方驱动仓库并更新</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure><h4 id="2-查看推荐驱动版本"><a href="#2-查看推荐驱动版本" class="headerlink" title="(2) 查看推荐驱动版本"></a>(2) 查看推荐驱动版本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ubuntu-drivers devices</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">== /sys/devices/pci0000:00/0000:00:02.0/0000:03:00.0 ==</span><br><span class="line">modalias : pci:v000010DEd00001C82sv000010DEsd00001C82bc03sc00i00</span><br><span class="line">vendor   : NVIDIA Corporation</span><br><span class="line">model    : GP107 [GeForce GTX 1050 Ti]</span><br><span class="line">driver   : nvidia-driver-570-server - distro non-free</span><br><span class="line">driver   : nvidia-driver-550 - distro non-free</span><br><span class="line">driver   : nvidia-driver-418-server - distro non-free</span><br><span class="line">driver   : nvidia-driver-570 - distro non-free recommended</span><br><span class="line">driver   : nvidia-driver-545 - distro non-free</span><br><span class="line">driver   : nvidia-driver-535-server - distro non-free</span><br><span class="line">driver   : nvidia-driver-535 - distro non-free</span><br><span class="line">driver   : nvidia-driver-450-server - distro non-free</span><br><span class="line">driver   : nvidia-driver-390 - distro non-free</span><br><span class="line">driver   : nvidia-driver-470 - distro non-free</span><br><span class="line">driver   : nvidia-driver-470-server - distro non-free</span><br><span class="line">driver   : xserver-xorg-video-nouveau - distro free <span class="built_in">builtin</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-安装推荐的驱动（如-570-版本）"><a href="#3-安装推荐的驱动（如-570-版本）" class="headerlink" title="(3) 安装推荐的驱动（如 570 版本）"></a>(3) 安装推荐的驱动（如 570 版本）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install nvidia-driver-570</span><br></pre></td></tr></table></figure><h4 id="4-重启系统"><a href="#4-重启系统" class="headerlink" title="(4) 重启系统"></a>(4) 重启系统</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> reboot</span><br></pre></td></tr></table></figure><h4 id="5-验证驱动"><a href="#5-验证驱动" class="headerlink" title="(5) 验证驱动"></a>(5) 验证驱动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>正常输出应显示 GPU 状态：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 535.161.07   Driver Version: 535.161.07   CUDA Version: 12.2     |</span><br><span class="line">|-----------------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|=========================================+======================+======================|</span><br><span class="line">|   0  NVIDIA GeForce GTX 1050 Ti    Off  | 00000000:03:00.0 Off |                  N/A |</span><br><span class="line">| 30%   35C    P8              N/A /  75W |      0MiB /  4096MiB |      0%      Default |</span><br><span class="line">+-----------------------------------------+----------------------+----------------------+</span><br></pre></td></tr></table></figure><hr><h3 id="第三步：-安装-CUDA-工具包（可选）"><a href="#第三步：-安装-CUDA-工具包（可选）" class="headerlink" title="第三步： 安装 CUDA 工具包（可选）"></a><strong>第三步： 安装 CUDA 工具包（可选）</strong></h3><p>如果需开发 GPU 计算应用（如 AI、深度学习），安装 CUDA：</p><h4 id="1-访问-CUDA-Toolkit-Archive-选择版本（推荐-CUDA-11-8-或-12-x）"><a href="#1-访问-CUDA-Toolkit-Archive-选择版本（推荐-CUDA-11-8-或-12-x）" class="headerlink" title="(1) 访问 CUDA Toolkit Archive 选择版本（推荐 CUDA 11.8 或 12.x）"></a>(1) 访问 <a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA Toolkit Archive</a> 选择版本（推荐 CUDA 11.8 或 12.x）</h4><h4 id="2-通过命令行安装（以-CUDA-12-2-为例）"><a href="#2-通过命令行安装（以-CUDA-12-2-为例）" class="headerlink" title="(2) 通过命令行安装（以 CUDA 12.2 为例）"></a>(2) 通过命令行安装（以 CUDA 12.2 为例）</h4><ul><li>该命令需要去英伟达官网实时生成：<a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&target_arch=x86_64&Distribution=Ubuntu&target_version=22.04&target_type=deb_local">CUDA Toolkit 12.9 Downloads | NVIDIA Developer</a></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/cuda-ubuntu2204.pin</span><br><span class="line">sudo mv cuda-ubuntu2204.pin /etc/apt/preferences.d/cuda-repository-pin-600</span><br><span class="line">wget https://developer.download.nvidia.com/compute/cuda/12.9.0/local_installers/cuda-repo-ubuntu2204-12-9-local_12.9.0-575.51.03-1_amd64.deb</span><br><span class="line">sudo dpkg -i cuda-repo-ubuntu2204-12-9-local_12.9.0-575.51.03-1_amd64.deb</span><br><span class="line">sudo cp /var/cuda-repo-ubuntu2204-12-9-local/cuda-*-keyring.gpg /usr/share/keyrings/</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install cuda-toolkit-12-9</span><br></pre></td></tr></table></figure><h4 id="3-添加变量"><a href="#3-添加变量" class="headerlink" title="(3) 添加变量"></a>(3) 添加变量</h4><p>虽然系统显示 <code>cuda-toolkit-12-9</code> 已安装，但 <code>nvcc</code> 的路径未添加到系统环境变量中。此时需要手动将 CUDA 的二进制目录加入 <code>PATH</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/local/cuda/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment">## root 用户添加环境变量</span></span><br><span class="line">vim /etc/environment</span><br><span class="line">添加 PATH=<span class="string">&quot;/usr/local/cuda/bin&quot;</span></span><br></pre></td></tr></table></figure><h4 id="4-验证-CUDA"><a href="#4-验证-CUDA" class="headerlink" title="(4) 验证 CUDA"></a>(4) 验证 CUDA</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvcc --version</span><br></pre></td></tr></table></figure><p>正常输出应显示 CUDA 版本。</p><h3 id="第四步：-验证-GPU-加速是否生效"><a href="#第四步：-验证-GPU-加速是否生效" class="headerlink" title="第四步： 验证 GPU 加速是否生效"></a><strong>第四步： 验证 GPU 加速是否生效</strong></h3><h4 id="1、检查编码器"><a href="#1、检查编码器" class="headerlink" title="1、检查编码器"></a>1、检查编码器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -encoders | grep nvenc</span><br><span class="line"><span class="comment"># 应输出包含 h264_nvenc 的行</span></span><br></pre></td></tr></table></figure><p>正常输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@R7-13:~# ffmpeg -encoders | grep nvenc</span><br><span class="line">ffmpeg version 4.4.2-0ubuntu0.22.04.1 Copyright (c) 2000-2021 the FFmpeg developers</span><br><span class="line">  built with gcc 11 (Ubuntu 11.2.0-19ubuntu1)</span><br><span class="line">  configuration: --prefix=/usr --extra-version=0ubuntu0.22.04.1 --toolchain=hardened --libdir=/usr/lib/x86_64-linux-gnu --incdir=/usr/include/x86_64-linux-gnu --<span class="built_in">arch</span>=amd64 --enable-gpl --disable-stripping --enable-gnutls --enable-ladspa --enable-libaom --enable-libass --enable-libbluray --enable-libbs2b --enable-libcaca --enable-libcdio --enable-libcodec2 --enable-libdav1d --enable-libflite --enable-libfontconfig --enable-libfreetype --enable-libfribidi --enable-libgme --enable-libgsm --enable-libjack --enable-libmp3lame --enable-libmysofa --enable-libopenjpeg --enable-libopenmpt --enable-libopus --enable-libpulse --enable-librabbitmq --enable-librubberband --enable-libshine --enable-libsnappy --enable-libsoxr --enable-libspeex --enable-libsrt --enable-libssh --enable-libtheora --enable-libtwolame --enable-libvidstab --enable-libvorbis --enable-libvpx --enable-libwebp --enable-libx265 --enable-libxml2 --enable-libxvid --enable-libzimg --enable-libzmq --enable-libzvbi --enable-lv2 --enable-omx --enable-openal --enable-opencl --enable-opengl --enable-sdl2 --enable-pocketsphinx --enable-librsvg --enable-libmfx --enable-libdc1394 --enable-libdrm --enable-libiec61883 --enable-chromaprint --enable-frei0r --enable-libx264 --enable-shared</span><br><span class="line">  libavutil      56. 70.100 / 56. 70.100</span><br><span class="line">  libavcodec     58.134.100 / 58.134.100</span><br><span class="line">  libavformat    58. 76.100 / 58. 76.100</span><br><span class="line">  libavdevice    58. 13.100 / 58. 13.100</span><br><span class="line">  libavfilter     7.110.100 /  7.110.100</span><br><span class="line">  libswscale      5.  9.100 /  5.  9.100</span><br><span class="line">  libswresample   3.  9.100 /  3.  9.100</span><br><span class="line">  libpostproc    55.  9.100 / 55.  9.100</span><br><span class="line"> V....D h264_nvenc           NVIDIA NVENC H.264 encoder (codec h264)</span><br><span class="line"> V..... nvenc                NVIDIA NVENC H.264 encoder (codec h264)</span><br><span class="line"> V..... nvenc_h264           NVIDIA NVENC H.264 encoder (codec h264)</span><br><span class="line"> V..... nvenc_hevc           NVIDIA NVENC hevc encoder (codec hevc)</span><br><span class="line"> V....D hevc_nvenc           NVIDIA NVENC hevc encoder (codec hevc)</span><br></pre></td></tr></table></figure><h4 id="2、监控-GPU-使用情况"><a href="#2、监控-GPU-使用情况" class="headerlink" title="2、监控 GPU 使用情况"></a>2、监控 GPU 使用情况</h4><h5 id="2-1、nvidia-smi-watch-组合命令"><a href="#2-1、nvidia-smi-watch-组合命令" class="headerlink" title="2.1、nvidia-smi + watch 组合命令*"></a>2.1、<code>nvidia-smi</code> + <code>watch</code> 组合命令*</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每秒刷新一次 GPU 状态，适合快速查看核心利用率、显存占用和温度</span></span><br><span class="line">watch -n 1 nvidia-smi  <span class="comment"># Linux/macOS</span></span><br></pre></td></tr></table></figure><p>windows 方案：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="variable">$true</span>) &#123; nvidia-smi; Start-Sleep -Milliseconds 500 &#125;</span><br></pre></td></tr></table></figure><h5 id="2-2、nvtop（类-htop-工具）"><a href="#2-2、nvtop（类-htop-工具）" class="headerlink" title="2.2、nvtop（类 htop 工具）"></a>2.2、<strong><code>nvtop</code>（类 htop 工具）</strong></h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 支持交互式操作和动态排序，适合多 GPU 服务器</span></span><br><span class="line"><span class="built_in">sudo</span> apt install nvtop  <span class="comment"># Ubuntu/Debian</span></span><br><span class="line">nvtop</span><br></pre></td></tr></table></figure><h2 id="第四步：使用GPU转码"><a href="#第四步：使用GPU转码" class="headerlink" title="第四步：使用GPU转码"></a>第四步：使用GPU转码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地文件转码</span></span><br><span class="line">ffmpeg -nostats -loglevel warning -hwaccel cuda -i ace.mp4 -vf <span class="string">&quot;scale=720:1270,setsar=1/1&quot;</span> -c:v h264_nvenc -preset p3 -rc vbr -b:v 0 -cq 23 -multipass fullres -tune hq -c:a aac -r 30 -y 3.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带请求头</span></span><br><span class="line">ffmpeg -nostats -loglevel warning -hwaccel cuda -headers <span class="string">&quot;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36\r\nReferer: https://exx.tv/\r\n&quot;</span> -i <span class="string">&quot;https://xxx.m3u8&quot;</span> -vf <span class="string">&quot;scale=720:1270,setsar=1/1&quot;</span> -c:v h264_nvenc -preset p3 -rc vbr -b:v 0 -cq 23 -multipass fullres -tune hq -c:a aac -r 30 -y 3.mp4</span><br></pre></td></tr></table></figure><h4 id="命令详解："><a href="#命令详解：" class="headerlink" title="命令详解："></a>命令详解：</h4><h5 id="基础参数"><a href="#基础参数" class="headerlink" title="基础参数"></a><strong>基础参数</strong></h5><ol><li><strong><code>-nostats</code></strong><ul><li><strong>功能</strong>：禁用编码统计信息的输出。</li><li><strong>说明</strong>：默认情况下，FFmpeg 会实时显示比特率、帧数等统计信息，此参数可减少输出干扰。</li></ul></li><li><strong><code>-loglevel warning</code></strong><ul><li><strong>功能</strong>：设置日志级别为 <code>warning</code>。</li><li><strong>说明</strong>：仅显示警告和错误信息，抑制冗余日志，使输出更简洁。</li></ul></li><li><strong><code>-hwaccel cuda</code></strong><ul><li><strong>功能</strong>：启用 NVIDIA CUDA 硬件加速解码。</li><li><strong>说明</strong>：利用 GPU 加速视频解码流程，提升处理速度。</li></ul></li><li><strong><code>-i ace.mp4</code></strong><ul><li><strong>功能</strong>：指定输入文件为 <code>ace.mp4</code>。</li></ul></li></ol><hr><h5 id="视频处理参数"><a href="#视频处理参数" class="headerlink" title="视频处理参数"></a><strong>视频处理参数</strong></h5><ol><li><strong><code>-vf &quot;scale=720:1270,setsar=1/1&quot;</code></strong><ul><li><strong>功能</strong>：应用视频滤镜链。<ul><li><strong><code>scale=720:1270</code></strong>：将视频缩放至 <code>720x1270</code> 分辨率（注意宽高比可能被改变）。</li><li><strong><code>setsar=1/1</code></strong>：设置像素宽高比（Sample Aspect Ratio）为 1:1，确保方形像素显示。</li></ul></li><li><strong>说明</strong>：调整分辨率后需修正宽高比，避免播放时变形。</li></ul></li></ol><hr><h5 id="视频编码参数"><a href="#视频编码参数" class="headerlink" title="视频编码参数"></a><strong>视频编码参数</strong></h5><ol><li><strong><code>-c:v h264_nvenc</code></strong><ul><li><strong>功能</strong>：使用 NVIDIA NVENC 硬件编码器生成 H.264 视频流。</li><li><strong>说明</strong>：相比 CPU 编码（如 <code>libx264</code>），硬件编码速度更快，但压缩效率略低。</li></ul></li><li><strong><code>-preset p3</code></strong><ul><li><strong>功能</strong>：设置编码器预设为 <code>p3</code>。</li><li><strong>说明</strong>：NVENC 预设范围 <code>p1</code>（最快）到 <code>p7</code>（最慢但质量更好），<code>p3</code> 平衡速度与质量。</li></ul></li><li><strong><code>-rc vbr</code></strong><ul><li><strong>功能</strong>：使用可变比特率（Variable Bitrate）控制模式。</li><li><strong>说明</strong>：VBR 根据内容复杂度动态分配码率，相比 CBR（恒定码率）更节省存储。</li></ul></li><li><strong><code>-b:v 0</code></strong><ul><li><strong>功能</strong>：将视频目标比特率设为 <code>0</code>。</li><li><strong>说明</strong>：在 <code>-rc vbr</code> + <code>-cq</code> 模式下，此参数表示由质量参数（<code>-cq</code>）主导码率分配。</li></ul></li><li><strong><code>-cq 23</code></strong><ul><li><strong>功能</strong>：设置恒定质量模式的质量值为 <code>23</code>。</li><li><strong>说明</strong>：NVENC 的 <code>cq</code> 范围通常为 <code>0</code>（无损）到 <code>51</code>（最差），<code>23</code> 是常见高质量选择。</li></ul></li><li><strong><code>-multipass fullres</code></strong><ul><li><strong>功能</strong>：启用两趟编码（Two-Pass Encoding），使用全分辨率分析。</li><li><strong>说明</strong>：首趟分析视频内容，次趟优化码率分配，提升压缩效率（需更高计算资源）。</li></ul></li><li><strong><code>-tune hq</code></strong><ul><li><strong>功能</strong>：优化编码参数以追求高质量。</li><li><strong>说明</strong>：适用于对画质要求较高的场景，可能牺牲部分编码速度。</li></ul></li></ol><hr><h5 id="音频与帧率参数"><a href="#音频与帧率参数" class="headerlink" title="音频与帧率参数"></a><strong>音频与帧率参数</strong></h5><ol><li><strong><code>-c:a aac</code></strong><ul><li><strong>功能</strong>：使用 AAC 编码器压缩音频流。</li><li><strong>说明</strong>：AAC 是通用音频格式，平衡音质与文件大小。</li></ul></li><li><strong><code>-r 30</code></strong><ul><li><strong>功能</strong>：强制输出视频帧率为 <code>30 FPS</code>。</li><li><strong>说明</strong>：若输入帧率不一致，FFmpeg 会通过丢帧或插帧适配。</li></ul></li></ol><hr><h5 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a><strong>其他参数</strong></h5><ol><li><strong><code>-y</code></strong><ul><li><strong>功能</strong>：自动覆盖输出文件（<code>3.mp4</code>），无需用户确认。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#00b2c2 size=5 face=宋体&gt;&lt;strong&gt;Ubuntu配置安装GPU转码&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="_A5-安装教程" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
    <category term="ubuntu" scheme="https://kanoc.gitee.io/categories/A5-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/ubuntu/"/>
    
    
    <category term="转码" scheme="https://kanoc.gitee.io/tags/%E8%BD%AC%E7%A0%81/"/>
    
    <category term="gpu" scheme="https://kanoc.gitee.io/tags/gpu/"/>
    
    <category term="NVIDIA" scheme="https://kanoc.gitee.io/tags/NVIDIA/"/>
    
  </entry>
  
</feed>
